/*
 * @lc app=leetcode.cn id=191 lang=typescript
 *
 * [191] 位1的个数
 */

// @lc code=start
/**
 * 计算一个无符号整数的二进制表示中 '1' 的个数（也称为汉明重量）
 *
 * 优化实现思路：
 * 1. 使用 n & (n-1) 技巧消除二进制表示中的最低位的1
 * 2. 重复这个过程直到n变为0
 * 3. 操作的次数就是二进制中1的个数
 *
 * @param n 无符号32位整数
 * @returns 二进制表示中1的个数
 */
function hammingWeight(n: number): number {
  // 用于统计1的个数
  let count = 0;

  // 当n不为0时，说明还有1需要消除
  while (n !== 0) {
    // n & (n-1) 操作会消除n中最低位的1
    // 例如：n = 10100，n-1 = 10011，n & (n-1) = 10000
    n = n & (n - 1);

    // 每执行一次操作，就消除了一个1，计数器加1
    count++;
  }

  // 返回1的总数
  return count;
}
// @lc code=end

/**
 * 算法分析（优化版）：
 *
 * 示例：n = 19 (二进制: 10011)
 *
 * 初始：count = 0
 *
 * 第1次循环：
 * - n = 10011
 * - n-1 = 10010
 * - n & (n-1) = 10010 (消除了最低位的1)
 * - count = 1
 *
 * 第2次循环：
 * - n = 10010
 * - n-1 = 10001
 * - n & (n-1) = 10000 (消除了第二个1)
 * - count = 2
 *
 * 第3次循环：
 * - n = 10000
 * - n-1 = 01111
 * - n & (n-1) = 00000 (消除了第三个1)
 * - count = 3
 *
 * n = 0，循环结束，返回 count = 3
 *
 * 为什么 n & (n-1) 能消除最低位的1：
 * 1. n-1 会把最低位的1变成0，并把这个位右边的所有0变成1
 * 2. 当n和n-1进行与运算时，最低位的1肯定变成0（因为n-1在这一位是0）
 * 3. 这个位右边的位在n中都是0，在n-1中都是1，与运算后还是0
 * 4. 这个位左边的位在n和n-1中相同，与运算后保持不变
 * 5. 结果就是最低位的1被消除，其他位保持不变
 *
 * 时间复杂度：O(k)，其中k是整数二进制表示中1的个数，最坏情况下k=32，但对于稀疏的二进制数，性能明显优于逐位检查
 * 空间复杂度：O(1)，只使用了常数个变量
 */
