/*
 * @lc app=leetcode.cn id=4 lang=typescript
 *
 * [4] 寻找两个正序数组的中位数
 *
 * https://leetcode.cn/problems/median-of-two-sorted-arrays/description/
 *
 * algorithms
 * Hard (43.26%)
 * Likes:    7472
 * Dislikes: 0
 * Total Accepted:    1.3M
 * Total Submissions: 2.9M
 * Testcase Example:  '[1,3]\n[2]'
 *
 * 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
 *
 * 算法的时间复杂度应该为 O(log (m+n)) 。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums1 = [1,3], nums2 = [2]
 * 输出：2.00000
 * 解释：合并数组 = [1,2,3] ，中位数 2
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums1 = [1,2], nums2 = [3,4]
 * 输出：2.50000
 * 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
 *
 *
 *
 *
 *
 *
 * 提示：
 *
 *
 * nums1.length == m
 * nums2.length == n
 * 0 <= m <= 1000
 * 0 <= n <= 1000
 * 1 <= m + n <= 2000
 * -10^6 <= nums1[i], nums2[i] <= 10^6
 *
 *
 */

// @lc code=start
/**
 * 🎯 寻找两个正序数组的中位数 - 二分查找解法
 *
 * 💡 核心思想：
 * 1. 中位数的本质是将数组分为两个等长的部分，左半部分的最大值 ≤ 右半部分的最小值
 * 2. 不需要真正合并数组，只需要找到正确的"分割点"
 * 3. 在较短的数组上进行二分查找，确定分割位置
 * 4. 根据分割位置计算另一个数组的分割位置
 * 5. 验证分割是否正确，调整搜索范围
 *
 * 🔑 关键概念：
 * - 分割点：将数组分为左右两部分的位置
 * - 左半部分总长度：(len1 + len2 + 1) / 2
 * - 分割正确的条件：左半部分最大值 ≤ 右半部分最小值
 *
 * ⏰ 时间复杂度：O(log(min(m,n)))
 * 💾 空间复杂度：O(1)
 */
/**
 * 🎯 寻找两个正序数组的中位数 - 优化版二分查找
 *
 * 💡 核心思想：
 * 1. 在较短数组上进行二分查找，找到合适的分割点
 * 2. 通过分割点将两个数组分为左右两部分
 * 3. 确保左半部分最大值 ≤ 右半部分最小值
 * 4. 根据总长度奇偶性计算中位数
 *
 * ⏰ 时间复杂度：O(log(min(m,n)))
 * 💾 空间复杂度：O(1)
 */
function findMedianSortedArrays(nums1: number[], nums2: number[]): number {
  // 📏 获取两个数组的长度
  let len1 = nums1.length,
    len2 = nums2.length;

  // 🔄 确保 nums1 是较短的数组，优化二分查找效率
  // 在较短数组上二分可以减少搜索空间，提高性能
  if (len1 > len2) return findMedianSortedArrays(nums2, nums1);

  // 📊 计算总长度
  let len = len1 + len2;

  // 🎯 定义二分查找的边界
  let start = 0, // nums1 的最小分割位置（可以取0个元素）
    end = len1; // nums1 的最大分割位置（可以取全部元素）

  // 📝 声明分割长度变量
  let partLen1, // nums1 左半部分的长度
    partLen2; // nums2 左半部分的长度

  // 🔍 二分查找主循环
  while (start <= end) {
    // 🎯 计算 nums1 的分割位置
    // 使用位运算 >> 1 等价于除以2并向下取整，性能更好
    partLen1 = (start + end) >> 1;

    // 🧮 计算 nums2 的分割位置
    // 关键公式：((len + 1) >> 1) - partLen1
    //
    // 解释：
    // - (len + 1) >> 1 计算左半部分总长度
    // - 减去 partLen1 得到 nums2 需要贡献的元素个数
    // - +1 的作用：统一处理奇偶情况，奇数时左半部分多一个元素
    partLen2 = ((len + 1) >> 1) - partLen1;

    // 📊 获取分割点附近的关键元素
    //
    // L1, L2: 左半部分的最大值
    // R1, R2: 右半部分的最小值

    // 🔍 nums1 左半部分的最大值
    // 如果 partLen1 = 0，说明 nums1 不贡献左半部分元素，设为 -∞
    let L1 = partLen1 === 0 ? -Infinity : nums1[partLen1 - 1];

    // 🔍 nums2 左半部分的最大值
    // 如果 partLen2 = 0，说明 nums2 不贡献左半部分元素，设为 -∞
    let L2 = partLen2 === 0 ? -Infinity : nums2[partLen2 - 1];

    // 🔍 nums1 右半部分的最小值
    // 如果 partLen1 = len1，说明 nums1 全部在左半部分，设为 +∞
    let R1 = partLen1 === len1 ? Infinity : nums1[partLen1];

    // 🔍 nums2 右半部分的最小值
    // 如果 partLen2 = len2，说明 nums2 全部在左半部分，设为 +∞
    let R2 = partLen2 === len2 ? Infinity : nums2[partLen2];

    // ✅ 检查分割是否正确
    // 正确分割的条件：左半部分最大值 ≤ 右半部分最小值
    if (L1 > R2) {
      // 🔄 情况1：L1 > R2
      // 说明 nums1 左半部分取得太多，需要减少
      // 将搜索范围缩小到 [start, partLen1-1]
      end = partLen1 - 1;
    } else if (L2 > R1) {
      // 🔄 情况2：L2 > R1
      // 说明 nums1 左半部分取得太少，需要增加
      // 将搜索范围缩小到 [partLen1+1, end]
      start = partLen1 + 1;
    } else {
      // 🎊 情况3：L1 <= R2 && L2 <= R1
      // 找到了正确的分割点！

      // 🧮 根据总长度的奇偶性计算中位数
      return len % 2 === 0
        ? // 偶数长度：中位数 = (左半部分最大值 + 右半部分最小值) / 2
          (Math.max(L1, L2) + Math.min(R1, R2)) / 2
        : // 奇数长度：中位数 = 左半部分最大值（因为左半部分多一个元素）
          Math.max(L1, L2);
    }
  }

  // 🚫 理论上不会执行到这里，因为输入保证有解
  // 添加返回值避免编译错误
  return 0;
}

/**
 * 🧮 算法详细解释：
 *
 * 1️⃣ 分割概念：
 *    nums1: [a1, a2, a3 | a4, a5]     cut1=3，左侧3个元素
 *    nums2: [b1, b2 | b3, b4, b5, b6]  cut2=2，左侧2个元素
 *
 *    左半部分: [a1,a2,a3,b1,b2]  (5个元素)
 *    右半部分: [a4,a5,b3,b4,b5,b6]  (6个元素)
 *
 * 2️⃣ 正确分割的条件：
 *    - 左半部分长度 = ⌊(总长度+1)/2⌋
 *    - max(左半部分) ≤ min(右半部分)
 *    - 即：max(a3,b2) ≤ min(a4,b3)
 *
 * 3️⃣ 二分查找逻辑：
 *    - 如果 left1 > right2：nums1 取太多，需要减少 → right = cut1-1
 *    - 如果 left2 > right1：nums1 取太少，需要增加 → left = cut1+1
 *    - 否则找到正确分割
 *
 * 4️⃣ 中位数计算：
 *    - 奇数总长度：中位数 = max(left1, left2)
 *    - 偶数总长度：中位数 = (max(left1,left2) + min(right1,right2)) / 2
 */

/**
 * 📝 测试用例演示：
 *
 * 示例1: nums1=[1,3], nums2=[2]
 * - 总长度=3(奇数), 左半部分长度=2
 * - cut1=1, cut2=1
 * - left1=1, right1=3, left2=2, right2=∞
 * - 检查: 1≤∞ ✓, 2≤3 ✓
 * - 中位数 = max(1,2) = 2
 *
 * 示例2: nums1=[1,2], nums2=[3,4]
 * - 总长度=4(偶数), 左半部分长度=2
 * - cut1=1, cut2=1
 * - left1=1, right1=2, left2=3, right2=4
 * - 检查: 1≤4 ✓, 3≤2 ✗ → left2 > right1
 * - 调整: left = cut1+1 = 2
 * - 新的: cut1=2, cut2=0
 * - left1=2, right1=∞, left2=-∞, right2=3
 * - 检查: 2≤3 ✓, -∞≤∞ ✓
 * - 中位数 = (max(2,-∞) + min(∞,3))/2 = (2+3)/2 = 2.5
 *
 *
 * 🔍 深度解析：为什么 halfLen = ⌊(totalLen + 1) / 2⌋？
 *
 * 这个 +1 是算法的精髓，让我们用具体例子来理解：
 *
 * 📝 情况1：奇数总长度
 *
 * 例子：[1,2,3,4,5] (长度=5)
 * - 中位数：第3个元素 (索引2)
 * - 理想分割：左半部分[1,2,3]，右半部分[4,5]
 * - 左半部分应该有3个元素
 * - 计算：⌊(5+1)/2⌋ = ⌊3⌋ = 3 ✅
 * - 如果不加1：⌊5/2⌋ = ⌊2.5⌋ = 2 ❌ (左半部分只有2个，丢失中位数)
 *
 * 📝 情况2：偶数总长度
 *
 * 例子：[1,2,3,4] (长度=4)
 * - 中位数：第2,3个元素的平均值 (索引1,2)
 * - 理想分割：左半部分[1,2]，右半部分[3,4]
 * - 左半部分应该有2个元素
 * - 计算：⌊(4+1)/2⌋ = ⌊2.5⌋ = 2 ✅
 * - 如果不加1：⌊4/2⌋ = ⌊2⌋ = 2 ✅ (这种情况下加不加1结果相同)
 *
 * 🎯 核心理解：
 *
 * 1️⃣ **统一处理**：+1 让我们用同一个公式处理奇偶两种情况
 *
 * 2️⃣ **奇数优势**：奇数时，左半部分"多拿一个"，正好包含中位数
 *    - 奇数：左半部分 = (n+1)/2，右半部分 = (n-1)/2
 *    - 中位数 = max(左半部分)
 *
 * 3️⃣ **偶数平衡**：偶数时，左右平分，中位数需要两边各取一个
 *    - 偶数：左半部分 = n/2，右半部分 = n/2
 *    - 中位数 = (max(左半部分) + min(右半部分)) / 2
 *
 * 📊 对比表：
 *
 * | 总长度 | 不加1的左半部分 | 加1的左半部分 | 正确性 |
 * |--------|----------------|---------------|--------|
 * | 1      | ⌊1/2⌋=0        | ⌊2/2⌋=1       | ✅加1正确 |
 * | 2      | ⌊2/2⌋=1        | ⌊3/2⌋=1       | ✅都正确 |
 * | 3      | ⌊3/2⌋=1        | ⌊4/2⌋=2       | ✅加1正确 |
 * | 4      | ⌊4/2⌋=2        | ⌊5/2⌋=2       | ✅都正确 |
 * | 5      | ⌊5/2⌋=2        | ⌊6/2⌋=3       | ✅加1正确 |
 *
 * 🏆 结论：+1 确保了奇数情况下左半部分能包含中位数，是算法正确性的关键！
 *
 *
 * 🎬 完整执行示例：nums1=[1,3], nums2=[2]
 *
 * 初始状态：
 * - len1=2, len2=1, len=3
 * - start=0, end=2
 *
 * 第1轮循环：
 * - partLen1 = (0+2)>>1 = 1
 * - partLen2 = ((3+1)>>1) - 1 = 2-1 = 1
 * - L1 = nums1[0] = 1, R1 = nums1[1] = 3
 * - L2 = nums2[0] = 2, R2 = ∞
 * - 检查：L1(1) <= R2(∞) ✓, L2(2) <= R1(3) ✓
 * - 分割正确！len=3是奇数，返回 max(L1,L2) = max(1,2) = 2
 *
 * 分割结果验证：
 * - nums1: [1 | 3]     (左半部分1个，右半部分1个)
 * - nums2: [2 | ]      (左半部分1个，右半部分0个)
 * - 合并：左半部分[1,2]，右半部分[3]
 * - 中位数：左半部分最大值 = 2 ✅
 *
 *
 * 🎬 完整执行示例：nums1=[1,2], nums2=[3,4]
 *
 * 初始状态：
 * - len1=2, len2=2, len=4
 * - start=0, end=2
 *
 * 第1轮循环：
 * - partLen1 = (0+2)>>1 = 1
 * - partLen2 = ((4+1)>>1) - 1 = 2-1 = 1
 * - L1 = nums1[0] = 1, R1 = nums1[1] = 2
 * - L2 = nums2[0] = 3, R2 = nums2[1] = 4
 * - 检查：L1(1) <= R2(4) ✓, L2(3) <= R1(2) ✗
 * - L2 > R1，需要增加 nums1 的贡献：start = 1+1 = 2
 *
 * 第2轮循环：
 * - partLen1 = (2+2)>>1 = 2
 * - partLen2 = ((4+1)>>1) - 2 = 2-2 = 0
 * - L1 = nums1[1] = 2, R1 = ∞
 * - L2 = -∞, R2 = nums2[0] = 3
 * - 检查：L1(2) <= R2(3) ✓, L2(-∞) <= R1(∞) ✓
 * - 分割正确！len=4是偶数，返回 (max(L1,L2) + min(R1,R2))/2 = (2+3)/2 = 2.5
 *
 * 分割结果验证：
 * - nums1: [1,2 | ]    (左半部分2个，右半部分0个)
 * - nums2: [ | 3,4]    (左半部分0个，右半部分2个)
 * - 合并：左半部分[1,2]，右半部分[3,4]
 * - 中位数：(2+3)/2 = 2.5 ✅
 */
// @lc code=end
