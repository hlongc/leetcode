/*
 * @lc app=leetcode.cn id=994 lang=typescript
 *
 * [994] 腐烂的橘子
 *
 * https://leetcode.cn/problems/rotting-oranges/description/
 *
 * algorithms
 * Medium (55.13%)
 * Likes:    1102
 * Dislikes: 0
 * Total Accepted:    378K
 * Total Submissions: 685.6K
 * Testcase Example:  '[[2,1,1],[1,1,0],[0,1,1]]'
 *
 * 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：
 *
 *
 * 值 0 代表空单元格；
 * 值 1 代表新鲜橘子；
 * 值 2 代表腐烂的橘子。
 *
 *
 * 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。
 *
 * 返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
 * 输出：4
 *
 *
 * 示例 2：
 *
 *
 * 输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
 * 输出：-1
 * 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。
 *
 *
 * 示例 3：
 *
 *
 * 输入：grid = [[0,2]]
 * 输出：0
 * 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 10
 * grid[i][j] 仅为 0、1 或 2
 *
 *
 */

/**
 * 腐烂的橘子 - 多源BFS（广度优先搜索）
 *
 * 核心思路：
 * 这是一道经典的"多源最短路径"问题
 * 1. 将所有初始腐烂的橘子加入队列（多个起点）
 * 2. 使用BFS按层次扩散，每一层代表一分钟
 * 3. 统计新鲜橘子数量，每次腐烂就减1
 * 4. 如果最后还有新鲜橘子，说明无法全部腐烂，返回-1
 *
 * 【图解示例】
 *
 * 初始状态：
 * 2 1 1    分钟0: 有1个腐烂(2)，6个新鲜(1)
 * 1 1 0
 * 0 1 1
 *
 * 第1分钟：
 * 2 2 1    腐烂的橘子向四周扩散
 * 2 1 0    新腐烂: (0,1), (1,0)
 * 0 1 1    新鲜橘子: 6 → 4
 *
 * 第2分钟：
 * 2 2 2    继续扩散
 * 2 2 0    新腐烂: (0,2), (1,1)
 * 0 1 1    新鲜橘子: 4 → 2
 *
 * 第3分钟：
 * 2 2 2    继续扩散
 * 2 2 0    新腐烂: (2,1)
 * 0 2 1    新鲜橘子: 2 → 1
 *
 * 第4分钟：
 * 2 2 2    最后一个橘子腐烂
 * 2 2 0    新腐烂: (2,2)
 * 0 2 2    新鲜橘子: 1 → 0
 *
 * 答案: 4分钟
 *
 * 时间复杂度：O(m*n)，每个格子最多访问一次
 * 空间复杂度：O(m*n)，队列最多存储所有格子
 */
function orangesRotting(grid: number[][]): number {
  const m = grid.length;
  const n = grid[0].length;

  // 四个方向：上、右、下、左
  const directions = [
    [-1, 0], // 上
    [0, 1], // 右
    [1, 0], // 下
    [0, -1], // 左
  ];

  // 队列：存储腐烂橘子的坐标
  const queue: [number, number][] = [];
  // 新鲜橘子的数量
  let freshCount = 0;

  // 步骤1：遍历网格，初始化队列和统计新鲜橘子
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] === 2) {
        // 将所有初始腐烂的橘子加入队列
        queue.push([i, j]);
      } else if (grid[i][j] === 1) {
        // 统计新鲜橘子数量
        freshCount++;
      }
    }
  }

  // 边界情况：如果没有新鲜橘子，直接返回0
  if (freshCount === 0) return 0;

  // 经过的分钟数
  let minutes = 0;

  // 步骤2：BFS按层次遍历（每层代表一分钟）
  while (queue.length > 0) {
    // 当前层的橘子数量（这一分钟要处理的腐烂橘子）
    const levelSize = queue.length;

    // 标记这一分钟是否有新的橘子腐烂
    let hasRotted = false;

    // 处理当前层的所有腐烂橘子
    for (let i = 0; i < levelSize; i++) {
      const [x, y] = queue.shift()!;

      // 向四个方向扩散
      for (const [dx, dy] of directions) {
        const newX = x + dx;
        const newY = y + dy;

        // 检查边界和是否是新鲜橘子
        if (
          newX >= 0 &&
          newX < m &&
          newY >= 0 &&
          newY < n &&
          grid[newX][newY] === 1
        ) {
          // 标记为腐烂
          grid[newX][newY] = 2;
          // 加入队列，下一轮处理
          queue.push([newX, newY]);
          // 新鲜橘子数量减1
          freshCount--;
          // 标记有橘子腐烂
          hasRotted = true;
        }
      }
    }

    // 如果这一分钟有橘子腐烂，分钟数+1
    if (hasRotted) {
      minutes++;
    }
  }

  // 步骤3：检查是否还有新鲜橘子
  // 如果还有新鲜橘子，说明无法全部腐烂，返回-1
  return freshCount === 0 ? minutes : -1;
}

/**
 * 【关键点解析】
 *
 * 1. 多源BFS vs 单源BFS：
 *    - 单源BFS：从一个起点开始
 *    - 多源BFS：从多个起点同时开始（所有腐烂橘子）
 *    - 关键：将所有起点同时加入队列
 *
 * 2. 按层遍历：
 *    - 每次处理一层（当前queue.length个元素）
 *    - 每层代表一个时间单位（一分钟）
 *    - 使用levelSize固定当前层的大小
 *
 * 3. 为什么统计freshCount：
 *    - 避免最后再遍历一次grid检查
 *    - 时间复杂度从O(2mn)优化到O(mn)
 *
 * 4. 边界情况：
 *    - 初始就没有新鲜橘子 → 返回0
 *    - 有新鲜橘子但无法腐烂 → 返回-1
 *    - 队列为空时，检查freshCount
 */

/**
 * 【BFS层次遍历模板】
 *
 * while (queue.length > 0) {
 *     const levelSize = queue.length; // 固定当前层大小
 *
 *     for (let i = 0; i < levelSize; i++) {
 *         const node = queue.shift();
 *         // 处理当前节点
 *         // 将下一层节点加入队列
 *     }
 *
 *     level++; // 层数+1（或时间+1）
 * }
 *
 * 这个模板适用于：
 * - 树的层序遍历
 * - 最短路径问题
 * - 腐烂扩散问题
 * - 所有需要"按层/按时间"处理的BFS问题
 */

/**
 * 【易错点总结】
 *
 * 1. ❌ 坐标计算错误：
 *    错误：const newY = dy + x;
 *    正确：const newY = dy + y;
 *
 * 2. ❌ 多个腐烂橘子分别BFS：
 *    错误：对每个腐烂橘子单独调用BFS
 *    正确：所有腐烂橘子同时加入队列，一起扩散
 *
 * 3. ❌ 分钟计数错误：
 *    错误：每处理一个节点就加1
 *    正确：处理完一层（一轮扩散）才加1
 *
 * 4. ❌ 没有检查剩余新鲜橘子：
 *    错误：直接返回minutes
 *    正确：检查freshCount是否为0
 *
 * 5. ❌ 使用shift()性能问题：
 *    在大数据量下，shift()是O(n)操作
 *    优化：可以使用索引或双端队列
 */

/**
 * 【测试用例】
 *
 * 输入: [[2,1,1],[1,1,0],[0,1,1]]
 * 输出: 4
 *
 * 输入: [[2,1,1],[0,1,1],[1,0,1]]
 * 输出: -1  (左下角的橘子永远无法腐烂)
 *
 * 输入: [[0,2]]
 * 输出: 0   (没有新鲜橘子)
 */
// @lc code=end
