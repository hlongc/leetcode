/*
 * @lc app=leetcode.cn id=539 lang=typescript
 *
 * [539] 最小时间差
 *
 * https://leetcode.cn/problems/minimum-time-difference/description/
 *
 * algorithms
 * Medium (65.49%)
 * Likes:    270
 * Dislikes: 0
 * Total Accepted:    74K
 * Total Submissions: 113K
 * Testcase Example:  '["23:59","00:00"]'
 *
 * 给定一个 24 小时制（小时:分钟 "HH:MM"）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：timePoints = ["23:59","00:00"]
 * 输出：1
 *
 *
 * 示例 2：
 *
 *
 * 输入：timePoints = ["00:00","23:59","00:00"]
 * 输出：0
 *
 *
 *
 *
 * 提示：
 *
 *
 * 2 <= timePoints.length <= 2 * 10^4
 * timePoints[i] 格式为 "HH:MM"
 *
 *
 */

// @lc code=start
/**
 * 解题思路：转换为分钟数 + 排序
 *
 * 核心思想：
 * 1. 将所有时间转换为从 00:00 开始的分钟数（0-1439）
 * 2. 对分钟数排序
 * 3. 计算相邻时间的差值，找最小值
 * 4. 特别注意：还要考虑首尾的环形差值（跨越午夜）
 *
 * 关键点：
 * - 24小时 = 1440分钟
 * - 时间是环形的：23:59 和 00:00 只差1分钟
 * - 排序后，最小差值一定在相邻时间之间，或首尾之间
 *
 * 优化：
 * - 如果有重复时间，直接返回0
 * - 一天最多1440个不同时间，如果超过则必有重复（鸽巢原理）
 *
 * 时间复杂度：O(n log n)，主要是排序
 * 空间复杂度：O(n)，存储转换后的分钟数
 */
function findMinDifference(timePoints: string[]): number {
  const n = timePoints.length;

  // 优化：一天最多1440个不同时间点（0-1439分钟）
  // 如果时间点超过1440个，必然有重复，最小差值为0
  if (n > 1440) {
    return 0;
  }

  // 步骤1：将所有时间转换为分钟数
  const minutes: number[] = [];
  for (const time of timePoints) {
    const [hour, minute] = time.split(":").map(Number);
    // 转换为从00:00开始的分钟数
    // 例如："23:59" → 23*60 + 59 = 1439
    //      "00:00" → 0*60 + 0 = 0
    minutes.push(hour * 60 + minute);
  }

  // 步骤2：排序
  minutes.sort((a, b) => a - b);

  // 步骤3：计算相邻时间的最小差值
  let minDiff = Infinity;

  // 比较相邻时间点
  for (let i = 1; i < n; i++) {
    const diff = minutes[i] - minutes[i - 1];
    minDiff = Math.min(minDiff, diff);

    // 优化：如果已经找到差值为0，直接返回
    if (minDiff === 0) {
      return 0;
    }
  }

  // 步骤4：计算首尾的环形差值（跨越午夜）
  // 例如：23:59(1439) 和 00:00(0)
  // 正向差值：1439 - 0 = 1439分钟
  // 环形差值：1440 - 1439 + 0 = 1分钟 ✓
  const circularDiff = 1440 - minutes[n - 1] + minutes[0];
  minDiff = Math.min(minDiff, circularDiff);

  return minDiff;
}

/**
 * 算法图解：
 *
 * 示例1：timePoints = ["23:59","00:00"]
 *
 * 转换为分钟：
 * "23:59" → 1439
 * "00:00" → 0
 *
 * 排序后：[0, 1439]
 *
 * 相邻差值：
 * 1439 - 0 = 1439分钟
 *
 * 环形差值（首尾）：
 * 1440 - 1439 + 0 = 1分钟 ✓
 *
 * 结果：1
 *
 *
 * 示例2：timePoints = ["00:00","23:59","00:00"]
 *
 * 转换为分钟：[0, 1439, 0]
 * 排序后：[0, 0, 1439]
 *
 * 相邻差值：
 * 0 - 0 = 0 ✓
 *
 * 结果：0（有重复时间）
 *
 *
 * 示例3：timePoints = ["05:31","22:08","00:35"]
 *
 * 转换为分钟：
 * "05:31" → 5*60+31 = 331
 * "22:08" → 22*60+8 = 1328
 * "00:35" → 0*60+35 = 35
 *
 * 排序后：[35, 331, 1328]
 *
 * 相邻差值：
 * 331 - 35 = 296
 * 1328 - 331 = 997
 *
 * 环形差值：
 * 1440 - 1328 + 35 = 147 ✓
 *
 * 结果：147
 *
 *
 * 为什么要考虑环形差值？
 *
 * 时间是24小时循环的：
 * 23:59 → 00:00 → 00:01 → ...
 *
 * 最后一个时间和第一个时间可能跨越午夜：
 * 23:59 到 00:00 = 1分钟（不是1439分钟）
 *
 * 计算公式：
 * 环形差值 = 1440 - 最大值 + 最小值
 *         = (1440 - 最大值) + 最小值
 *         = 从最大值到午夜的分钟数 + 从午夜到最小值的分钟数
 *
 *
 * 关键优化：
 * 1. 鸽巢原理：超过1440个时间点必有重复
 * 2. 提前退出：发现差值为0立即返回
 * 3. 排序后只需比较相邻元素和首尾元素
 */
// @lc code=end
