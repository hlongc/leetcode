/*
 * @lc app=leetcode.cn id=260 lang=typescript
 *
 * [260] 只出现一次的数字 III
 *
 * https://leetcode.cn/problems/single-number-iii/description/
 *
 * algorithms
 * Medium (70.67%)
 * Likes:    944
 * Dislikes: 0
 * Total Accepted:    167.6K
 * Total Submissions: 237.3K
 * Testcase Example:  '[1,2,1,3,2,5]'
 *
 * 给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
 *
 * 你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,2,1,3,2,5]
 * 输出：[3,5]
 * 解释：[5, 3] 也是有效的答案。
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [-1,0]
 * 输出：[-1,0]
 *
 *
 * 示例 3：
 *
 *
 * 输入：nums = [0,1]
 * 输出：[1,0]
 *
 *
 *
 *
 * 提示：
 *
 *
 * 2 <= nums.length <= 3 * 10^4
 * -2^31 <= nums[i] <= 2^31 - 1
 * 除两个只出现一次的整数外，nums 中的其他数字都出现两次
 *
 *
 */

// @lc code=start
/**
 * 只出现一次的数字 III
 *
 * 题目要求：
 * - 数组中恰好有两个元素只出现一次，其余元素都出现两次
 * - 找出这两个只出现一次的元素
 * - 时间复杂度 O(n)，空间复杂度 O(1)
 *
 * 解题思路：
 * 1. 先对所有数字进行异或运算，由于相同数字异或为0，最终结果是两个单独数字的异或值
 * 2. 找到这个异或值中任意一个为1的位，这一位可以区分这两个数字
 * 3. 根据这一位将数组分为两组，每组包含一个单独的数字
 * 4. 分别对两组进行异或运算，得到两个单独的数字
 */
function singleNumber(nums: number[]): number[] {
  // 第一步：对所有数字进行异或运算
  // 由于相同的数字异或为0，最终结果是两个单独数字的异或值
  let xorAll = 0;
  for (const num of nums) {
    xorAll ^= num;
  }

  // 第二步：找到异或结果中最右边的1
  // 这个位置可以用来区分两个单独的数字

  /**
   * 为什么 x & (-x) 可以获取最右侧的1？
   *
   * 关键在于计算机中负数的表示方法：二进制补码
   *
   * 补码的计算规则：-x = ~x + 1 (按位取反后加1)
   *
   * 详细推导过程：
   * 假设 x = 12 (二进制: 1100)
   *
   * 步骤1：计算 -x
   * x  = 1100
   * ~x = 0011  (按位取反)
   * -x = ~x + 1 = 0011 + 0001 = 0100
   *
   * 步骤2：计算 x & (-x)
   * x    = 1100
   * -x   = 0100
   * x&-x = 0100  (只保留了最右边的1)
   *
   * 原理解释：
   * 当我们对x按位取反后加1时，会发生一个神奇的现象：
   * - 从最右边开始，遇到的第一个1会保持不变
   * - 这个1右边的所有0会变成1（取反）然后因为加1而全部进位变回0
   * - 这个1左边的所有位都会被取反
   *
   * 所以 x & (-x) 的结果中，只有最右边的1位置保持为1，其他位都是0
   */

  const rightmostBit = xorAll & -xorAll;

  /**
   * 更多示例：
   *
   * 例子1：x = 6 (二进制: 0110)
   * x  = 0110
   * ~x = 1001
   * -x = 1001 + 0001 = 1010
   * x & (-x) = 0110 & 1010 = 0010 = 2
   *
   * 例子2：x = 8 (二进制: 1000)
   * x  = 1000
   * ~x = 0111
   * -x = 0111 + 0001 = 1000
   * x & (-x) = 1000 & 1000 = 1000 = 8
   *
   * 例子3：x = 7 (二进制: 0111)
   * x  = 0111
   * ~x = 1000
   * -x = 1000 + 0001 = 1001
   * x & (-x) = 0111 & 1001 = 0001 = 1
   */

  // 第三步：根据这个位将数组分为两组
  let num1 = 0,
    num2 = 0;

  for (const num of nums) {
    // 检查当前数字在rightmostBit位置是否为1
    if (num & rightmostBit) {
      // 该位为1的数字分为一组
      num1 ^= num;
    } else {
      // 该位为0的数字分为另一组
      num2 ^= num;
    }
  }

  // 返回两个单独的数字
  return [num1, num2];
}

/**
 * 算法示例分析：
 * nums = [1,2,1,3,2,5]
 *
 * 第一步：全部异或
 * 1^2^1^3^2^5 = (1^1)^(2^2)^3^5 = 0^0^3^5 = 3^5 = 6 (二进制: 110)
 *
 * 第二步：找最右边的1
 * rightmostBit = 6 & (-6) = 110 & 010 = 010 = 2
 *
 * 第三步：按第1位(从右数第2位)分组
 * 第1位为0的数：1(001), 1(001), 3(011) → 1^1^3 = 3
 * 第1位为1的数：2(010), 2(010), 5(101) → 2^2^5 = 5
 *
 * 结果：[3, 5]
 */
// @lc code=end
