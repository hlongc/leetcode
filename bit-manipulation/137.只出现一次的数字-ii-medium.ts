/*
 * @lc app=leetcode.cn id=137 lang=typescript
 *
 * [137] 只出现一次的数字 II
 *
 * https://leetcode.cn/problems/single-number-ii/description/
 *
 * algorithms
 * Medium (72.40%)
 * Likes:    1297
 * Dislikes: 0
 * Total Accepted:    237.9K
 * Total Submissions: 328.5K
 * Testcase Example:  '[2,2,3,2]'
 *
 * 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
 *
 * 你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [2,2,3,2]
 * 输出：3
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [0,1,0,1,0,1,99]
 * 输出：99
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 3 * 10^4
 * -2^31 <= nums[i] <= 2^31 - 1
 * nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
 *
 *
 */

// @lc code=start
function singleNumber(nums: number[]): number {
  /**
   * 只出现一次的数字 II - 数字电路解法详解
   *
   * 🎯 核心理念：把每个二进制位想象成一个计数器，能计数 0→1→2→0（循环）
   *
   * 📊 用两个变量记录每个位的状态：
   * - ones：记录"出现1次"的位
   * - twos：记录"出现2次"的位
   * - 当某位出现3次时，自动重置为0
   *
   * 🔄 状态机转换（每个位独立计数）：
   * ┌─────────────────────────────────────────┐
   * │  当前状态     输入    下一状态           │
   * │  (twos,ones)   bit   (twos',ones')      │
   * ├─────────────────────────────────────────┤
   * │   (0,0)    +   0   →    (0,0)   [无变化]│
   * │   (0,0)    +   1   →    (0,1)   [第1次] │
   * │   (0,1)    +   0   →    (0,1)   [保持1次]│
   * │   (0,1)    +   1   →    (1,0)   [第2次] │
   * │   (1,0)    +   0   →    (1,0)   [保持2次]│
   * │   (1,0)    +   1   →    (0,0)   [第3次→重置]│
   * └─────────────────────────────────────────┘
   *
   * 💡 关键洞察：
   * - 出现1次的数字最终会留在ones中
   * - 出现3次的数字会被自动清零
   * - 每个位都独立计数，互不干扰
   *
   * 时间复杂度：O(n) - 只遍历一次数组
   * 空间复杂度：O(1) - 只用两个变量
   */

  let ones = 0; // 记录每个位出现1次的情况
  let twos = 0; // 记录每个位出现2次的情况

  for (const num of nums) {
    /**
     * 🔧 三步更新法：
     *
     * 步骤1: 更新twos
     * 如果ones中某位是1，且当前数字该位也是1，
     * 说明该位从"出现1次"变成"出现2次"
     */
    twos |= ones & num;

    /**
     * 步骤2: 更新ones
     * 异或操作：第1次遇到某位设为1，第2次遇到设为0
     * 这样ones就记录了"奇数次出现"的位
     */
    ones ^= num;

    /**
     * 步骤3: 清除出现3次的位
     * 如果ones和twos中同时有某位为1，说明该位出现了3次
     * 需要将该位在ones和twos中都清零（重置状态）
     */
    const threes = ones & twos; // 找到出现3次的位
    ones &= ~threes; // 在ones中清除这些位
    twos &= ~threes; // 在twos中清除这些位
  }

  return ones;
}

/**
 * 解法二：优化的位计数法
 * 相比原解法的优化点：
 * 1. 减少不必要的位检查
 * 2. 使用位操作代替取模运算
 * 3. 提前结束循环
 */
function singleNumberOptimized(nums: number[]): number {
  let result = 0;

  // 只检查有意义的位（最多32位）
  for (let i = 0; i < 32; i++) {
    let bitCount = 0;
    const mask = 1 << i;

    // 统计第i位上1的个数
    for (const num of nums) {
      if (num & mask) {
        bitCount++;
      }
    }

    // 使用位操作判断是否为3的倍数（更快）
    if (bitCount % 3 !== 0) {
      result |= mask;
    }
  }

  return result;
}

/**
 * 解法三：数学解法（适用于小数组）
 * 利用集合去重，然后计算差值
 * 时间复杂度：O(n)，空间复杂度：O(n)
 */
function singleNumberMath(nums: number[]): number {
  const uniqueNums = [...new Set(nums)];
  const sumUnique = uniqueNums.reduce((sum, num) => sum + num, 0);
  const sumAll = nums.reduce((sum, num) => sum + num, 0);

  // 3 * (a + b + c + ...) - (3a + 3b + 3c + ... + target) = 2 * target
  return (3 * sumUnique - sumAll) / 2;
}

/**
 * 性能对比分析：
 *
 * 1. 数字电路解法（推荐）：
 *    - 时间复杂度：O(n)
 *    - 空间复杂度：O(1)
 *    - 特点：最快，只遍历一次数组
 *
 * 2. 优化位计数法：
 *    - 时间复杂度：O(32n) = O(n)
 *    - 空间复杂度：O(1)
 *    - 特点：相比原解法有小幅优化
 *
 * 3. 数学解法：
 *    - 时间复杂度：O(n)
 *    - 空间复杂度：O(n)
 *    - 特点：思路简单，但需要额外空间
 *
 * 推荐使用数字电路解法，它是最优解！
 */

/**
 * 🎓 数字电路解法 - 通俗理解
 *
 * 💭 类比：想象成停车场计数器
 * - ones：记录"停了1辆车"的车位
 * - twos：记录"停了2辆车"的车位
 * - 当某个车位停了3辆车时，自动清空（因为题目说出现3次的要忽略）
 *
 * 📝 完整执行示例：nums = [2,2,3,2]
 *
 * 初始状态：ones=000, twos=000
 *
 * 🚗 第1次遇到数字2 (010)：
 *   步骤1: twos |= ones & 2 = 000 & 010 = 000 (twos保持000)
 *   步骤2: ones ^= 2 = 000 ^ 010 = 010 (ones变成010)
 *   步骤3: threes = ones & twos = 010 & 000 = 000 (没有3次)
 *   结果：ones=010, twos=000 ✅ 第1位"出现1次"
 *
 * 🚗 第2次遇到数字2 (010)：
 *   步骤1: twos |= ones & 2 = 010 & 010 = 010 (twos变成010)
 *   步骤2: ones ^= 2 = 010 ^ 010 = 000 (ones变成000)
 *   步骤3: threes = ones & twos = 000 & 010 = 000 (没有3次)
 *   结果：ones=000, twos=010 ✅ 第1位"出现2次"
 *
 * 🚙 第1次遇到数字3 (011)：
 *   步骤1: twos |= ones & 3 = 000 & 011 = 000 (twos保持010)
 *   步骤2: ones ^= 3 = 000 ^ 011 = 011 (ones变成011)
 *   步骤3: threes = ones & twos = 011 & 010 = 010 (第1位出现3次!)
 *           ones &= ~threes = 011 & ~010 = 011 & 101 = 001
 *           twos &= ~threes = 010 & ~010 = 010 & 101 = 000
 *   结果：ones=001, twos=000 ✅ 第1位重置，第0位"出现1次"
 *
 * 🚗 第3次遇到数字2 (010)：
 *   步骤1: twos |= ones & 2 = 001 & 010 = 000 (twos保持000)
 *   步骤2: ones ^= 2 = 001 ^ 010 = 011 (ones变成011)
 *   步骤3: threes = ones & twos = 011 & 000 = 000 (没有3次)
 *   结果：ones=011, twos=000 ✅ 第0位和第1位都"出现1次"
 *
 * 🎯 最终结果：ones = 011 = 3
 *
 * 解释：数字2出现了3次，被自动清零了；数字3出现了1次，保留在ones中！
 *
 * 🔍 为什么这样设计有效？
 * 1. 每个二进制位独立计数，互不干扰
 * 2. 用2个变量就能表示0/1/2三种状态（00/01/10）
 * 3. 当计数到3时自动重置为0（11→00）
 * 4. 最终只有出现1次的数字会留在ones中
 */

// @lc code=end
