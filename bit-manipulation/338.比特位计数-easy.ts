/*
 * @lc app=leetcode.cn id=338 lang=typescript
 *
 * [338] 比特位计数
 *
 * https://leetcode.cn/problems/counting-bits/description/
 *
 * algorithms
 * Easy (79.02%)
 * Likes:    1378
 * Dislikes: 0
 * Total Accepted:    367.6K
 * Total Submissions: 465K
 * Testcase Example:  '2'
 *
 * 给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans
 * 作为答案。
 *
 *
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：n = 2
 * 输出：[0,1,1]
 * 解释：
 * 0 --> 0
 * 1 --> 1
 * 2 --> 10
 *
 *
 * 示例 2：
 *
 *
 * 输入：n = 5
 * 输出：[0,1,1,2,1,2]
 * 解释：
 * 0 --> 0
 * 1 --> 1
 * 2 --> 10
 * 3 --> 11
 * 4 --> 100
 * 5 --> 101
 *
 *
 *
 *
 * 提示：
 *
 *
 * 0 <= n <= 10^5
 *
 *
 *
 *
 * 进阶：
 *
 *
 * 很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？
 * 你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）
 *
 *
 *
 *
 */

// @lc code=start
/**
 * 比特位计数
 *
 * 题目要求：
 * 对于 0 <= i <= n 中的每个 i，计算其二进制表示中 1 的个数
 * 返回一个长度为 n + 1 的数组作为答案
 *
 * 解题思路：
 * 利用动态规划思想，通过已计算的结果推导新结果
 * 关键观察：任何数字的1的个数都可以通过其"一半"推导出来
 */
function countBits(n: number): number[] {
  // 解法1：动态规划 + 右移位运算（推荐）
  // 创建结果数组，索引i对应数字i的比特位1的个数
  const dp: number[] = new Array(n + 1).fill(0);

  // 0的二进制中1的个数为0（基础情况）
  dp[0] = 0;

  // 从1开始计算每个数字的比特位1的个数
  for (let i = 1; i <= n; i++) {
    /**
     * 核心公式：dp[i] = dp[i >> 1] + (i & 1)
     *
     * 原理分析：
     * - i >> 1 表示将i右移一位，相当于i除以2（去掉最低位）
     * - i & 1 表示i的最低位是否为1（0或1）
     * - 一个数的1的个数 = 去掉最低位后的1的个数 + 最低位的值
     *
     * 例子：
     * i = 5 (101₂)
     * i >> 1 = 2 (10₂), dp[2] = 1
     * i & 1 = 1 (最低位为1)
     * dp[5] = dp[2] + 1 = 1 + 1 = 2 ✓
     */
    dp[i] = dp[i >> 1] + (i & 1);
  }

  return dp;

  // 解法2：动态规划 + 最低位1清除（Brian Kernighan算法变种）
  /*
  const dp: number[] = new Array(n + 1).fill(0);
  
  for (let i = 1; i <= n; i++) {
    // i & (i - 1) 会清除i的最低位1
    // 所以dp[i] = dp[i & (i - 1)] + 1
    dp[i] = dp[i & (i - 1)] + 1;
  }
  
  return dp;
  */

  // 解法3：动态规划 + 奇偶性
  /*
  const dp: number[] = new Array(n + 1).fill(0);
  
  for (let i = 1; i <= n; i++) {
    if (i % 2 === 0) {
      // 偶数：右移一位不会改变1的个数
      dp[i] = dp[i / 2];
    } else {
      // 奇数：比前一个偶数多一个1
      dp[i] = dp[i - 1] + 1;
    }
  }
  
  return dp;
  */
}

/**
 * 算法分析与示例：
 *
 * 示例：n = 5
 * 二进制表示：0(0), 1(1), 2(10), 3(11), 4(100), 5(101)
 * 1的个数：  [0,    1,     1,     2,     1,      2]
 *
 * 计算过程（解法1）：
 * dp[0] = 0 (基础情况)
 * dp[1] = dp[0] + 1 = 0 + 1 = 1
 * dp[2] = dp[1] + 0 = 1 + 0 = 1
 * dp[3] = dp[1] + 1 = 1 + 1 = 2
 * dp[4] = dp[2] + 0 = 1 + 0 = 1
 * dp[5] = dp[2] + 1 = 1 + 1 = 2
 *
 * 复杂度分析：
 * 时间复杂度：O(n) - 只需遍历一次
 * 空间复杂度：O(1) - 除了输出数组外，只使用常数额外空间
 *
 * 优势：
 * 1. 线性时间复杂度，满足进阶要求
 * 2. 不使用内置函数，满足进阶要求
 * 3. 利用位运算，效率高
 * 4. 代码简洁，易于理解
 */
// @lc code=end
