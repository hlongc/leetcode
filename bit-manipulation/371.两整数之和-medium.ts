/*
 * @lc app=leetcode.cn id=371 lang=typescript
 *
 * [371] 两整数之和
 *
 * https://leetcode.cn/problems/sum-of-two-integers/description/
 *
 * algorithms
 * Medium (63.14%)
 * Likes:    762
 * Dislikes: 0
 * Total Accepted:    132.3K
 * Total Submissions: 209.6K
 * Testcase Example:  '1\n2'
 *
 * 给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：a = 1, b = 2
 * 输出：3
 *
 *
 * 示例 2：
 *
 *
 * 输入：a = 2, b = 3
 * 输出：5
 *
 *
 *
 *
 * 提示：
 *
 *
 * -1000 <= a, b <= 1000
 *
 *
 */

// @lc code=start
function getSum(a: number, b: number): number {
  /**
   * 不使用加法和减法运算符计算两整数之和
   * 核心思想：使用位操作模拟加法过程
   *
   * 【原理详解】
   * 我们先回顾一下手工计算加法的过程：
   * 对于每一位，我们需要考虑：
   * 1. 当前位的数字相加
   * 2. 如果和 >= 2，则产生进位到下一位
   *
   * 用二进制思考更简单：
   * 0 + 0 = 0 (无进位)
   * 0 + 1 = 1 (无进位)
   * 1 + 0 = 1 (无进位)
   * 1 + 1 = 0 (有进位1到下一位)
   *
   * 【关键洞察】
   * 1. 异或运算 (XOR) a ^ b：
   *    - 0 ^ 0 = 0
   *    - 0 ^ 1 = 1
   *    - 1 ^ 0 = 1
   *    - 1 ^ 1 = 0  ← 这正是"不考虑进位的加法结果"！
   *
   * 2. 与运算 (AND) a & b：
   *    - 0 & 0 = 0
   *    - 0 & 1 = 0
   *    - 1 & 0 = 0
   *    - 1 & 1 = 1  ← 这标识了哪些位会产生进位！
   *
   * 3. 左移一位 << 1：
   *    - 因为进位要影响的是"下一位"，所以需要左移
   *
   * 【具体例子】
   * 计算 5 + 3：
   *
   * 5 = 101 (二进制)
   * 3 = 011 (二进制)
   *
   * 第一轮：
   * a = 101, b = 011
   * a ^ b = 101 ^ 011 = 110 (不考虑进位的和)
   * a & b = 101 & 011 = 001 (进位位置)
   * (a & b) << 1 = 001 << 1 = 010 (进位值)
   *
   * 现在 a = 110, b = 010，继续：
   *
   * 第二轮：
   * a = 110, b = 010
   * a ^ b = 110 ^ 010 = 100 (不考虑进位的和)
   * a & b = 110 & 010 = 010 (进位位置)
   * (a & b) << 1 = 010 << 1 = 100 (进位值)
   *
   * 现在 a = 100, b = 100，继续：
   *
   * 第三轮：
   * a = 100, b = 100
   * a ^ b = 100 ^ 100 = 000 (不考虑进位的和)
   * a & b = 100 & 100 = 100 (进位位置)
   * (a & b) << 1 = 100 << 1 = 1000 (进位值)
   *
   * 现在 a = 000, b = 1000，继续：
   *
   * 第四轮：
   * a = 000, b = 1000
   * a ^ b = 000 ^ 1000 = 1000 (不考虑进位的和)
   * a & b = 000 & 1000 = 0000 (没有进位了!)
   *
   * 结果：1000 (二进制) = 8 (十进制) ✓
   *
   * 算法步骤：
   * 1. 计算不考虑进位的和：a ^ b
   * 2. 计算进位：(a & b) << 1
   * 3. 将进位加到和上，重复此过程直到没有进位
   */

  while (b !== 0) {
    // 计算不考虑进位的和
    const sum = a ^ b;

    // 计算进位，需要左移一位
    const carry = (a & b) << 1;

    // 更新a为当前和，b为进位
    // 下一次循环会将进位加到和上
    a = sum;
    b = carry;
  }

  /*
   * 【核心原理总结】
   *
   * 1. 从人类加法思维开始：
   *    手工做加法时需要：逐位相加 + 处理进位
   *
   * 2. 二进制加法的四种情况：
   *    0 + 0 = 0  (无进位)
   *    0 + 1 = 1  (无进位)
   *    1 + 0 = 1  (无进位)
   *    1 + 1 = 10 (结果位是0，进位是1)
   *
   * 3. 关键洞察：拆分成两个独立操作
   *
   *    步骤1：不考虑进位的相加
   *    - 对比上面四种情况的"结果位"：0, 1, 1, 0
   *    - 这正好就是异或运算 XOR 的结果！
   *    - a ^ b 给出了"忽略进位的加法结果"
   *
   *    步骤2：计算进位
   *    - 什么时候会产生进位？只有当两个位都是1时
   *    - 这正好就是与运算 AND 的结果！
   *    - a & b 告诉我们哪些位会产生进位
   *    - (a & b) << 1 把进位放到正确的位置（左移一位）
   *
   * 4. 为什么要循环？
   *    因为进位本身可能会产生新的进位！
   *    例如：111 + 001，最右边1+1产生进位，这个进位和中间的1相加又产生进位...
   *    所以需要重复这个过程，直到没有进位为止。
   *
   * 5. 直观理解：
   *    想象有两台机器：
   *    - 机器A（XOR）：专门计算"不考虑进位的相加"
   *    - 机器B（AND+左移）：专门计算"哪里需要进位"
   *    不断让这两台机器协作，直到机器B说"没有进位了"，
   *    那么机器A的结果就是最终答案！
   */

  return a;
}
// @lc code=end
