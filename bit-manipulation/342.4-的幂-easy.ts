/*
 * @lc app=leetcode.cn id=342 lang=typescript
 *
 * [342] 4的幂
 *
 * https://leetcode.cn/problems/power-of-four/description/
 *
 * algorithms
 * Easy (53.64%)
 * Likes:    388
 * Dislikes: 0
 * Total Accepted:    164.6K
 * Total Submissions: 306.8K
 * Testcase Example:  '16'
 *
 * 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。
 *
 * 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4^x
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：n = 16
 * 输出：true
 *
 *
 * 示例 2：
 *
 *
 * 输入：n = 5
 * 输出：false
 *
 *
 * 示例 3：
 *
 *
 * 输入：n = 1
 * 输出：true
 *
 *
 *
 *
 * 提示：
 *
 *
 * -2^31 <= n <= 2^31 - 1
 *
 *
 *
 *
 * 进阶：你能不使用循环或者递归来完成本题吗？
 *
 */

// @lc code=start
/**
 * 4的幂
 *
 * 题目要求：
 * 判断给定整数是否是4的幂次方
 * 即：是否存在整数x使得n == 4^x
 *
 * 关键观察：
 * 4的幂的特点：
 * 1. 必须是正数
 * 2. 必须是2的幂（只有一个1位）
 * 3. 这个1位必须在偶数位置上（从右数，0-indexed）
 */
function isPowerOfFour(n: number): boolean {
  // 解法1：位运算 + 掩码（推荐）
  // 4的幂的二进制表示中，1只能出现在偶数位置（0, 2, 4, 6...）
  // 0x55555555 = 01010101010101010101010101010101₂
  // 这个掩码在偶数位置上都是1，奇数位置上都是0
  // return n > 0 && (n & (n - 1)) === 0 && (n & 0x55555555) !== 0;

  // 解法2：模运算
  // 4的幂对3取模的结果必定是1
  // 因为4 ≡ 1 (mod 3)，所以4^k ≡ 1^k ≡ 1 (mod 3)

  return n > 0 && (n & (n - 1)) === 0 && n % 3 === 1;

  // 解法3：数学方法
  // 如果n是4的幂，那么log₄(n)应该是整数
  // 可以转换为：log(n) / log(4) 是否为整数
  /*
  if (n <= 0) return false;
  const logResult = Math.log(n) / Math.log(4);
  return Math.abs(logResult - Math.round(logResult)) < 1e-10;
  */

  // 解法4：递归/循环方法
  /*
  if (n <= 0) return false;
  if (n === 1) return true;
  if (n % 4 !== 0) return false;
  return isPowerOfFour(n / 4);
  */
}

/**
 * 为什么原代码有问题？
 *
 * 原代码：n > 0 && n % 4 === 0 && (n & (n - 1)) === 0
 *
 * 问题分析：
 * 条件 (n & (n - 1)) === 0 只能判断n是2的幂
 * 条件 n % 4 === 0 只能判断n是4的倍数
 * 但是这两个条件结合并不能保证n是4的幂
 *
 * 反例：n = 8
 * 8 > 0 ✓
 * 8 % 4 === 0 ✓
 * 8 & 7 === 0 ✓ (8是2的幂)
 * 但8不是4的幂！8 = 2³，而4的幂应该是4⁰, 4¹, 4², ...
 *
 * 核心问题：需要区分"2的幂"和"4的幂"
 */

/**
 * 4的幂的二进制特征分析：
 *
 * 4⁰ = 1  = 1₂        (第0位)
 * 4¹ = 4  = 100₂      (第2位)
 * 4² = 16 = 10000₂    (第4位)
 * 4³ = 64 = 1000000₂  (第6位)
 *
 * 规律：4的幂的二进制表示中，唯一的1总是在偶数位置上！
 *
 * 对比2的幂：
 * 2¹ = 2  = 10₂       (第1位，奇数位置)
 * 2³ = 8  = 1000₂     (第3位，奇数位置)
 *
 * 掩码0x55555555的作用：
 * 0x55555555 = 01010101010101010101010101010101₂
 * 这个掩码与n进行按位与运算：
 * - 如果n的1在偶数位置，结果非0
 * - 如果n的1在奇数位置，结果为0
 *
 * 示例验证：
 * n = 16 (10000₂):
 * 16 & 0x55555555 = 10000₂ & 01010101...₂ = 10000₂ ≠ 0 ✓
 *
 * n = 8 (1000₂):
 * 8 & 0x55555555 = 1000₂ & 01010101...₂ = 0000₂ = 0 ✗
 */
// @lc code=end
