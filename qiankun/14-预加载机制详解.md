# 问题14：qiankun 如何实现应用的预加载（prefetch）？预加载策略有哪几种？

## 📌 预加载的概念

**预加载（Prefetch）**：在用户还没有访问某个应用时，提前下载该应用的资源（HTML、JS、CSS），当用户真正访问时，资源已在缓存中，实现秒开。

## 🎯 当前qiankun的预加载状态

**重要说明：** 在qiankun的最新版本中，prefetch功能的代码被注释掉了：

```typescript
// packages/qiankun/src/apis/registerMicroApps.ts: 48-52
export function start(opts: StartOpts = {}) {
    if (!started) {
        // frameworkConfiguration = { prefetch: true, singular: true, sandbox: true, ...opts };
        // const { prefetch, urlRerouteOnly = defaultUrlRerouteOnly, ...importEntryOpts } = frameworkConfiguration;

        // if (prefetch) {
        //   doPrefetchStrategy(microApps, prefetch, importEntryOpts);
        // }

        startSingleSpa(opts);
        started = true;
        frameworkStartedDefer.resolve();
    }
}
```

**原因：** qiankun正在重构底层loader实现，从import-html-entry迁移到新的流式加载方案。

## 📚 预加载的理论实现（基于旧版本）

虽然当前版本注释了，但理解预加载机制仍然很重要。以下是预加载的实现原理：

### 1. 预加载策略类型

```typescript
type PrefetchStrategy =
    | boolean                    // true/false
    | 'all'                      // 预加载所有应用
    | string[]                   // 预加载指定的应用列表
    | ((apps: RegistrableApp[]) => { criticalAppNames: string[]; minorAppsName: string[] });  // 自定义函数
```

### 2. doPrefetchStrategy 实现原理

```javascript
// 预加载策略实现（伪代码，基于旧版本）
function doPrefetchStrategy(apps, prefetch, importEntryOpts) {
    // 策略1: false - 不预加载
    if (prefetch === false) {
        return;
    }

    // 策略2: true - 首屏完成后，空闲时预加载其他应用
    if (prefetch === true) {
        // 获取首屏应用
        const firstScreenApps = apps.filter(app => 
            typeof app.activeRule === 'string' && 
            window.location.pathname.startsWith(app.activeRule)
        );
        
        // 获取其他应用
        const otherApps = apps.filter(app => !firstScreenApps.includes(app));
        
        // 首屏加载完成后预加载
        window.addEventListener('load', () => {
            requestIdleCallback(() => {
                prefetchApps(otherApps, importEntryOpts);
            });
        });
        
        return;
    }

    // 策略3: 'all' - 立即预加载所有应用
    if (prefetch === 'all') {
        prefetchApps(apps, importEntryOpts);
        return;
    }

    // 策略4: string[] - 预加载指定应用
    if (Array.isArray(prefetch)) {
        const appsToPreload = apps.filter(app => prefetch.includes(app.name));
        prefetchApps(appsToPreload, importEntryOpts);
        return;
    }

    // 策略5: function - 自定义预加载逻辑
    if (typeof prefetch === 'function') {
        const { criticalAppNames = [], minorAppsName = [] } = prefetch(apps);
        
        // 关键应用：立即预加载
        const criticalApps = apps.filter(app => criticalAppNames.includes(app.name));
        prefetchApps(criticalApps, importEntryOpts);
        
        // 次要应用：空闲时预加载
        const minorApps = apps.filter(app => minorAppsName.includes(app.name));
        requestIdleCallback(() => {
            prefetchApps(minorApps, importEntryOpts);
        });
    }
}
```

### 3. prefetchApps 核心实现

```javascript
// 预加载应用列表
function prefetchApps(apps, importEntryOpts) {
    apps.forEach(app => {
        // 使用 import-html-entry 预加载
        importEntry(app.entry, importEntryOpts).then(({ getExternalScripts, getExternalStyleSheets }) => {
            // 触发资源下载（但不执行）
            getExternalScripts();  // 下载所有 JS
            getExternalStyleSheets();  // 下载所有 CSS
            
            // 资源会被缓存到 import-html-entry 的缓存中
            // 用户访问时直接从缓存读取
        });
    });
}
```

## 🎨 五种预加载策略详解

### 策略1: false（禁用预加载）

```javascript
start({
    prefetch: false  // 完全禁用预加载
});

// 适用场景：
// - 用户网络很慢
// - 服务器资源有限
// - 希望节省带宽
```

### 策略2: true（智能预加载，默认推荐）

```javascript
start({
    prefetch: true  // 首屏完成后，空闲时预加载其他应用
});

// 工作流程：
// 1. 页面加载，首屏应用正常加载
// 2. 首屏加载完成（window.onload）
// 3. 浏览器空闲时（requestIdleCallback）
// 4. 预加载其他未激活的应用

// 优点：
// - 不影响首屏性能
// - 充分利用空闲时间
// - 平衡性能和用户体验
```

**实际效果：**

```javascript
// 注册了3个应用
registerMicroApps([
    { name: 'home', activeRule: '/' },       // 首屏应用
    { name: 'about', activeRule: '/about' }, // 其他应用
    { name: 'user', activeRule: '/user' }    // 其他应用
]);

start({ prefetch: true });

// 时间线：
// t=0ms: 用户访问 /
// t=0-1000ms: 加载 home 应用
// t=1000ms: window.onload 触发
// t=1000ms: 浏览器空闲，开始预加载 about 和 user
// t=2000ms: about 和 user 的资源下载完成
// 
// 用户点击跳转到 /about
// t=2500ms: about 应用秒开（资源已缓存）✓
```

### 策略3: 'all'（立即预加载所有应用）

```javascript
start({
    prefetch: 'all'  // 立即预加载所有应用
});

// 工作流程：
// 1. start() 调用时立即开始预加载
// 2. 并行下载所有应用的资源
// 3. 不管用户是否会访问

// 优点：
// - 所有应用都秒开
// - 用户体验最佳

// 缺点：
// - 消耗大量带宽
// - 可能影响首屏性能
// - 加载了用户可能不会访问的应用

// 适用场景：
// - 应用数量少（2-3个）
// - 用户网络好
// - 对用户体验要求极高
```

### 策略4: string[]（预加载指定应用）

```javascript
start({
    prefetch: ['about', 'products']  // 只预加载这两个应用
});

// 适用场景：
// - 明确知道用户最可能访问的应用
// - 根据用户角色/权限预加载
// - 精确控制预加载范围

// 示例：根据用户角色
const userRole = getCurrentUserRole();

let appsToPreload = [];
if (userRole === 'admin') {
    appsToPreload = ['admin-dashboard', 'user-management'];
} else if (userRole === 'user') {
    appsToPreload = ['user-profile', 'user-settings'];
}

start({
    prefetch: appsToPreload
});
```

### 策略5: 自定义函数（最灵活）

```javascript
start({
    prefetch: (apps) => {
        // 返回关键应用和次要应用
        return {
            criticalAppNames: ['about', 'products'],  // 立即预加载
            minorAppsName: ['blog', 'contact']        // 空闲时预加载
        };
    }
});

// 工作流程：
// 1. criticalAppNames: 立即预加载（高优先级）
// 2. minorAppsName: requestIdleCallback 预加载（低优先级）
```

**高级自定义示例：**

```javascript
start({
    prefetch: (apps) => {
        const now = new Date().getHours();
        const userRole = getCurrentUserRole();
        const networkSpeed = getNetworkSpeed();

        // 根据时间、角色、网络状况动态决定预加载策略
        if (networkSpeed === 'slow') {
            // 慢速网络：不预加载
            return {
                criticalAppNames: [],
                minorAppsName: []
            };
        }

        if (userRole === 'admin') {
            // 管理员：预加载管理相关应用
            return {
                criticalAppNames: ['admin-dashboard'],
                minorAppsName: ['user-management', 'system-settings']
            };
        }

        if (now >= 9 && now <= 18) {
            // 工作时间：预加载工作相关应用
            return {
                criticalAppNames: ['workspace', 'documents'],
                minorAppsName: ['calendar', 'emails']
            };
        }

        // 默认策略
        return {
            criticalAppNames: apps.filter(app => app.priority === 'high').map(app => app.name),
            minorAppsName: apps.filter(app => app.priority === 'low').map(app => app.name)
        };
    }
});
```

## 🔧 手动实现预加载

既然qiankun当前版本注释了prefetch，我们可以手动实现：

### 方案1: 使用 import-html-entry

```javascript
import { importEntry } from 'import-html-entry';

// 预加载函数
async function prefetchApp(entry, fetch) {
    try {
        const { getExternalScripts, getExternalStyleSheets } = await importEntry(entry, { fetch });
        
        // 触发下载
        await Promise.all([
            getExternalScripts(),
            getExternalStyleSheets()
        ]);
        
        console.log(`预加载完成: ${entry}`);
    } catch (error) {
        console.error(`预加载失败: ${entry}`, error);
    }
}

// 在 start 后手动预加载
start();

// 首屏加载完成后预加载
window.addEventListener('load', () => {
    requestIdleCallback(() => {
        prefetchApp('http://localhost:8080');  // 预加载应用A
        prefetchApp('http://localhost:8081');  // 预加载应用B
    });
});
```

### 方案2: 使用 link rel="prefetch"

```javascript
// 在主应用的 HTML 中添加 prefetch 标签
function addPrefetchLinks(apps) {
    apps.forEach(app => {
        // 预加载 HTML
        const htmlLink = document.createElement('link');
        htmlLink.rel = 'prefetch';
        htmlLink.href = app.entry;
        document.head.appendChild(htmlLink);

        // 如果知道资源 URL，可以直接预加载
        if (app.scripts) {
            app.scripts.forEach(script => {
                const scriptLink = document.createElement('link');
                scriptLink.rel = 'prefetch';
                scriptLink.href = script;
                scriptLink.as = 'script';
                document.head.appendChild(scriptLink);
            });
        }

        if (app.styles) {
            app.styles.forEach(style => {
                const styleLink = document.createElement('link');
                styleLink.rel = 'prefetch';
                styleLink.href = style;
                styleLink.as = 'style';
                document.head.appendChild(styleLink);
            });
        }
    });
}

// 使用
addPrefetchLinks([
    {
        name: 'app1',
        entry: 'http://localhost:8080/index.html',
        scripts: ['http://localhost:8080/main.js'],
        styles: ['http://localhost:8080/main.css']
    }
]);
```

### 方案3: Service Worker预加载

```javascript
// sw.js
self.addEventListener('install', (event) => {
    event.waitUntil(
        caches.open('qiankun-apps-v1').then((cache) => {
            return cache.addAll([
                'http://localhost:8080/index.html',
                'http://localhost:8080/main.js',
                'http://localhost:8080/main.css',
                'http://localhost:8081/index.html',
                'http://localhost:8081/app.js',
            ]);
        })
    );
});

// 主应用注册 Service Worker
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
}
```

## ⚡ 预加载的性能优化

### 1. requestIdleCallback 的使用

```javascript
// 浏览器空闲时才预加载，不影响主线程
function prefetchWhenIdle(apps) {
    requestIdleCallback(
        () => {
            apps.forEach(app => prefetchApp(app.entry));
        },
        { timeout: 2000 }  // 最多等待2秒
    );
}

// 兼容性处理
const requestIdleCallback = window.requestIdleCallback || function(cb) {
    const start = Date.now();
    return setTimeout(() => {
        cb({
            didTimeout: false,
            timeRemaining() {
                return Math.max(0, 50 - (Date.now() - start));
            }
        });
    }, 1);
};
```

### 2. 网络状况检测

```javascript
// 只在良好的网络环境下预加载
function shouldPrefetch() {
    // 检查 Network Information API
    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    
    if (!connection) {
        return true;  // 无法检测，默认允许
    }

    // 慢速网络（2G/3G）不预加载
    const slowConnections = ['slow-2g', '2g', '3g'];
    if (slowConnections.includes(connection.effectiveType)) {
        return false;
    }

    // 省流量模式不预加载
    if (connection.saveData) {
        return false;
    }

    return true;
}

// 使用
if (shouldPrefetch()) {
    prefetchApps(apps);
}
```

### 3. 优先级队列

```javascript
// 按优先级预加载
class PrefetchQueue {
    constructor() {
        this.highPriority = [];
        this.lowPriority = [];
        this.isRunning = false;
    }

    add(app, priority = 'low') {
        if (priority === 'high') {
            this.highPriority.push(app);
        } else {
            this.lowPriority.push(app);
        }

        if (!this.isRunning) {
            this.run();
        }
    }

    async run() {
        this.isRunning = true;

        // 先加载高优先级
        while (this.highPriority.length > 0) {
            const app = this.highPriority.shift();
            await prefetchApp(app.entry);
        }

        // 再加载低优先级（空闲时）
        requestIdleCallback(async () => {
            while (this.lowPriority.length > 0) {
                const app = this.lowPriority.shift();
                await prefetchApp(app.entry);
            }
            this.isRunning = false;
        });
    }
}

// 使用
const queue = new PrefetchQueue();
queue.add({ entry: 'http://localhost:8080' }, 'high');
queue.add({ entry: 'http://localhost:8081' }, 'low');
```

## 🎓 面试要点

### 预加载策略

1. **false**: 禁用预加载
2. **true**: 智能预加载（首屏完成后空闲时）
3. **'all'**: 立即预加载所有应用
4. **string[]**: 预加载指定应用
5. **function**: 自定义预加载逻辑

### 核心原理

1. **不执行代码**：只下载资源，不执行脚本
2. **利用缓存**：import-html-entry 的缓存机制
3. **空闲时加载**：requestIdleCallback
4. **网络感知**：根据网络状况调整策略

### 性能优化

1. **首屏优先**：不影响首屏加载
2. **优先级队列**：关键应用优先加载
3. **网络检测**：慢速网络不预加载
4. **省流量模式**：尊重用户设置

### 当前状态

1. **功能被注释**：qiankun最新版本正在重构
2. **手动实现**：可以自己实现预加载逻辑
3. **理解原理**：为future版本做准备

## 💡 为什么需要预加载？

### 问题场景

```
用户点击导航 → 下载 HTML (200ms)
                ↓
             下载 JS (500ms)
                ↓
             下载 CSS (300ms)
                ↓
             执行 JS (100ms)
                ↓
             渲染页面
                
总耗时: 1100ms（用户等待）
```

### 预加载后

```
空闲时预加载：
    下载 HTML (200ms) ✓ 缓存
    下载 JS (500ms)   ✓ 缓存
    下载 CSS (300ms)  ✓ 缓存

用户点击导航 → 从缓存读取 (0ms)
                ↓
             执行 JS (100ms)
                ↓
             渲染页面

总耗时: 100ms（秒开！）
```

### 权衡

```
预加载的代价：
- 消耗带宽
- 占用浏览器资源
- 可能加载用户不会访问的应用

预加载的收益：
- 大幅提升加载速度
- 更好的用户体验
- 降低跳出率

关键：选择合适的策略！
```

qiankun的预加载机制虽然当前被注释，但其设计理念值得学习：通过智能的预加载策略，在不影响首屏性能的前提下，大幅提升后续页面的加载速度！

