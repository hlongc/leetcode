# 问题23：qiankun 提供了哪些样式隔离方案？strictStyleIsolation 和 experimentalStyleIsolation 的区别是什么？

## 📌 样式隔离的必要性

### 问题场景

```css
/* 主应用的样式 */
.title { 
    font-size: 24px; 
    color: blue; 
}

/* 子应用的样式 */
.title { 
    font-size: 16px; 
    color: red; 
}

/* 结果：样式冲突！
   后加载的样式会覆盖先加载的样式
   主应用的 .title 可能变成红色
   或子应用的 .title 可能变成蓝色 */
```

## 🎯 qiankun 的三种样式隔离方案

### 1. 不开启隔离（默认）

```javascript
start({
    sandbox: true,
    // 不配置样式隔离
});
```

**特点：**
- ✅ 最简单
- ✅ 性能最好
- ❌ 没有样式隔离
- ❌ 可能有样式冲突

**适用场景：**
- 主应用和子应用的样式命名规范统一（如 BEM）
- 使用 CSS Modules、CSS-in-JS
- 应用数量少，可控

### 2. strictStyleIsolation（严格样式隔离）

```javascript
start({
    sandbox: {
        strictStyleIsolation: true  // ⭐ 开启严格隔离
    }
});
```

**实现方式：** Shadow DOM

**特点：**
- ✅ 完全隔离
- ✅ 浏览器原生支持
- ❌ 兼容性问题（弹窗、全局样式等）
- ❌ 可能破坏某些组件

**原理：**

```javascript
// qiankun 会将子应用包裹在 Shadow DOM 中

// 原始容器
<div id="subapp-container"></div>

// 开启 strictStyleIsolation 后
<div id="subapp-container">
    #shadow-root (open)  ⭐ Shadow DOM
        <style>
            /* 子应用的样式，只在 Shadow DOM 内生效 */
            .title { color: red; }
        </style>
        <div id="root">
            <!-- 子应用的内容 -->
        </div>
</div>

// 主应用的样式无法穿透 Shadow DOM
// 子应用的样式无法影响外部
```

### 3. experimentalStyleIsolation（实验性样式隔离）

```javascript
start({
    sandbox: {
        experimentalStyleIsolation: true  // ⭐ 开启实验性隔离
    }
});
```

**实现方式：** Scoped CSS（添加属性选择器）

**特点：**
- ✅ 兼容性好
- ✅ 不破坏 DOM 结构
- ⚠️ 隔离不完全
- ⚠️ 运行时改写样式，有性能开销

**原理：**

```css
/* 子应用的原始样式 */
.title { color: red; }
.content { padding: 10px; }

/* qiankun 改写后 */
.title[data-qiankun="react-app"] { color: red; }
.content[data-qiankun="react-app"] { padding: 10px; }
```

```html
<!-- 容器也会添加属性 -->
<div id="subapp-container" data-qiankun="react-app">
    <div class="title">标题</div>
    <div class="content">内容</div>
</div>
```

## 📊 三种方案对比

| 特性 | 无隔离 | strictStyleIsolation | experimentalStyleIsolation |
|------|--------|---------------------|---------------------------|
| **实现方式** | 无 | Shadow DOM | Scoped CSS |
| **隔离程度** | 无 | 完全隔离 | 部分隔离 |
| **兼容性** | ✅ 完美 | ⚠️ 有问题 | ✅ 良好 |
| **性能** | ✅ 最好 | ✅ 好 | ⚠️ 运行时改写 |
| **弹窗** | ✅ 正常 | ❌ 样式丢失 | ✅ 正常 |
| **全局样式** | ✅ 可用 | ❌ 不可用 | ✅ 可用 |
| **适用场景** | 可控的应用 | 样式完全独立 | 大部分场景 |

## 🔍 详细对比

### strictStyleIsolation 的优缺点

#### 优点

```javascript
// 1. 完全隔离
// 主应用和子应用的样式互不影响

/* 主应用 */
.button { background: blue; }

/* 子应用（在 Shadow DOM 中）*/
.button { background: red; }

// 主应用的按钮：蓝色 ✓
// 子应用的按钮：红色 ✓
// 完全隔离，不冲突

// 2. 浏览器原生支持
// 不需要运行时改写样式
// 性能好
```

#### 缺点

```javascript
// 1. 弹窗问题
// 很多 UI 库的弹窗会挂载到 document.body

// 子应用代码
Modal.show({
    title: '提示',
    content: '这是一个弹窗'
});

// 弹窗 DOM 结构
document.body.appendChild(modalElement);

// 问题：
// 弹窗在 Shadow DOM 外部
// 子应用的样式在 Shadow DOM 内部
// 弹窗没有样式！ ❌

// 2. 全局样式库无法使用
// Ant Design、Element UI 等

<link rel="stylesheet" href="https://cdn.com/antd.min.css">

// 这些样式在 Shadow DOM 外
// 子应用内的组件无法应用这些样式 ❌

// 3. :host 选择器问题
// Shadow DOM 需要特殊的 CSS 写法

/* 普通 CSS */
.container { width: 100%; }

/* Shadow DOM CSS */
:host(.container) { width: 100%; }

// 需要改写样式，成本高
```

### experimentalStyleIsolation 的优缺点

#### 优点

```javascript
// 1. 兼容性好
// 弹窗、全局样式都能正常工作

// 2. 不破坏 DOM 结构
// 不使用 Shadow DOM

// 3. 大部分情况有效
// 对于类选择器、ID选择器等，隔离有效
```

#### 缺点

```javascript
// 1. 标签选择器无法隔离
/* 子应用样式 */
div { margin: 0; }
p { line-height: 1.5; }

/* 改写后 */
div[data-qiankun="app"] { margin: 0; }
p[data-qiankun="app"] { line-height: 1.5; }

// 但如果子应用动态创建了元素：
const div = document.createElement('div');
document.body.appendChild(div);  // 挂载到 body

// 这个 div 没有 data-qiankun 属性
// 样式不会生效 ⚠️

// 2. 运行时改写，有性能开销
// 每个样式规则都要改写
// CSS 越多，开销越大

// 3. 某些选择器可能改写失败
/* 伪类、伪元素 */
::before { content: ''; }
:hover { background: red; }

/* 改写可能有问题 */
::before[data-qiankun="app"] { content: ''; }  // ❌ 无效
:hover[data-qiankun="app"] { background: red; }  // ❌ 无效
```

## 🎨 如何选择样式隔离方案？

### 决策树

```
是否需要样式隔离？
├─ 否 → 不开启隔离
│   ├─ 使用 CSS Modules
│   ├─ 使用 BEM 命名规范
│   └─ 手动添加应用前缀
│
└─ 是 → 需要隔离
    │
    ├─ 使用弹窗/全局样式库？
    │   ├─ 是 → experimentalStyleIsolation
    │   │   ├─ 兼容性好
    │   │   └─ 大部分场景满足
    │   │
    │   └─ 否 → strictStyleIsolation
    │       ├─ 完全隔离
    │       └─ 样式完全独立
    │
    └─ 性能要求极高？
        └─ 不开启隔离 + 手动处理
```

### 推荐配置

```javascript
// 场景1: 标准业务应用（推荐）
start({
    sandbox: {
        experimentalStyleIsolation: true  // 兼容性好，大部分场景有效
    }
});

// 场景2: 样式完全独立的应用
start({
    sandbox: {
        strictStyleIsolation: true  // 完全隔离
    }
});

// 场景3: 可控的应用（团队规范好）
start({
    sandbox: true  // 不开启样式隔离
});
// 配合：
// - CSS Modules
// - CSS-in-JS (styled-components)
// - BEM 命名规范
// - 统一的样式前缀
```

## 🎓 面试要点

### 三种方案

1. **不隔离**：最简单，需要规范约束
2. **strictStyleIsolation**：Shadow DOM，完全隔离
3. **experimentalStyleIsolation**：Scoped CSS，部分隔离

### 核心区别

1. **实现原理**：Shadow DOM vs 属性选择器
2. **隔离程度**：完全隔离 vs 部分隔离
3. **兼容性**：有问题 vs 良好
4. **适用场景**：独立应用 vs 通用场景

### 选择依据

1. **是否使用弹窗**：是 → experimental
2. **是否使用全局样式库**：是 → experimental
3. **是否要求完全隔离**：是 → strict
4. **团队规范**：好 → 不隔离

qiankun 提供了多种样式隔离方案，满足不同场景的需求，开发者可以根据实际情况灵活选择！

