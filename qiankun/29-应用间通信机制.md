# 问题29：qiankun 如何实现应用间通信？全局状态管理（globalState）的实现原理是什么？

## 📌 应用间通信的需求

### 典型场景

```javascript
// 场景1: 用户信息共享
// 主应用登录后，所有子应用都需要知道用户信息

// 场景2: 主题切换
// 用户在设置应用中切换主题，其他应用需要同步

// 场景3: 消息通知
// 消息中心有新消息，需要通知所有应用更新未读数

// 场景4: 应用间协作
// 应用A的操作需要通知应用B刷新数据
```

## 🎯 qiankun 的通信方案

### 1. initGlobalState（官方推荐）

虽然源码中没有找到（可能在旧版本），但这是 qiankun 官方文档中的推荐方案。

#### 实现原理

```javascript
// 简化版 globalState 实现

function initGlobalState(initialState = {}) {
    // 全局状态
    let globalState = initialState;
    
    // 监听器列表
    const listeners = new Set();

    // 发布状态变更
    const emitGlobalState = (state, prevState) => {
        listeners.forEach(listener => {
            listener(state, prevState);
        });
    };

    // MicroAppStateActions
    const actions = {
        // 监听状态变化
        onGlobalStateChange: (callback, fireImmediately = false) => {
            listeners.add(callback);
            
            if (fireImmediately) {
                callback(globalState, globalState);
            }
            
            // 返回取消监听的函数
            return () => {
                listeners.delete(callback);
            };
        },

        // 设置状态
        setGlobalState: (state) => {
            const prevState = { ...globalState };
            globalState = { ...globalState, ...state };
            
            // 通知所有监听器
            emitGlobalState(globalState, prevState);
        },

        // 获取状态
        getGlobalState: () => {
            return { ...globalState };
        },

        // 卸载（清理监听器）
        offGlobalStateChange: () => {
            listeners.clear();
        }
    };

    return actions;
}
```

#### 使用方式

```javascript
// ===== 主应用 =====
import { initGlobalState } from 'qiankun';

// 初始化全局状态
const actions = initGlobalState({
    user: { id: 1, name: 'Admin' },
    theme: 'light',
    unreadCount: 0
});

// 监听状态变化
actions.onGlobalStateChange((state, prev) => {
    console.log('主应用：状态变化', state, prev);
    
    // 更新主应用 UI
    updateHeader(state.user);
    updateTheme(state.theme);
});

// 修改状态
actions.setGlobalState({
    user: { id: 1, name: 'Admin', avatar: 'url' }
});

// 注册子应用时传递 actions
registerMicroApps([
    {
        name: 'react-app',
        entry: '//localhost:8080',
        container: '#container',
        activeRule: '/react-app',
        props: { globalState: actions }  // ⭐ 传递给子应用
    }
]);
```

```javascript
// ===== 子应用 =====
export async function mount(props) {
    const { globalState } = props;

    // 监听状态变化
    globalState.onGlobalStateChange((state, prev) => {
        console.log('子应用：状态变化', state, prev);
        
        // 更新子应用
        if (state.theme !== prev.theme) {
            updateTheme(state.theme);
        }
    }, true);  // true: 立即触发一次

    // 修改状态
    globalState.setGlobalState({
        unreadCount: 5
    });

    // 挂载应用
    ReactDOM.render(<App globalState={globalState} />, props.container);
}
```

### 2. Props 传递（最简单）

```javascript
// 主应用向子应用传递数据

registerMicroApps([
    {
        name: 'react-app',
        entry: '//localhost:8080',
        container: '#container',
        activeRule: '/react-app',
        props: {
            // ⭐ 传递数据
            user: { id: 1, name: 'Admin' },
            config: { apiBase: 'https://api.com' },
            
            // ⭐ 传递方法
            onMessage: (msg) => {
                console.log('收到子应用消息:', msg);
            }
        }
    }
]);

// 子应用接收
export async function mount(props) {
    const { user, config, onMessage } = props;
    
    console.log('用户信息:', user);
    console.log('配置:', config);
    
    // 调用主应用方法
    onMessage('子应用已挂载');
}
```

**缺点：**
- 单向通信（主 → 子）
- 子应用无法主动通知主应用（除非主应用传递回调）

### 3. 自定义事件（推荐）

```javascript
// ===== 主应用 =====
class AppCommunicator {
    constructor() {
        this.eventBus = new EventTarget();
    }

    // 发送事件
    emit(eventName, data) {
        this.eventBus.dispatchEvent(new CustomEvent(eventName, {
            detail: data
        }));
    }

    // 监听事件
    on(eventName, callback) {
        this.eventBus.addEventListener(eventName, (e) => {
            callback(e.detail);
        });
    }

    // 取消监听
    off(eventName, callback) {
        this.eventBus.removeEventListener(eventName, callback);
    }
}

const communicator = new AppCommunicator();

// 监听事件
communicator.on('userLogin', (user) => {
    console.log('用户登录:', user);
    updateHeader(user);
});

// 传递给子应用
registerMicroApps([
    {
        name: 'react-app',
        props: { communicator }
    }
]);
```

```javascript
// ===== 子应用 =====
export async function mount(props) {
    const { communicator } = props;

    // 监听主应用事件
    communicator.on('themeChange', (theme) => {
        console.log('主题变化:', theme);
        updateTheme(theme);
    });

    // 发送事件给主应用
    communicator.emit('userLogin', {
        id: 1,
        name: 'User'
    });
}
```

### 4. 共享状态库（Redux/MobX）

```javascript
// ===== 主应用：创建共享 Store =====
import { createStore } from 'redux';

const store = createStore(reducer);

// 传递给子应用
registerMicroApps([
    {
        name: 'react-app',
        props: { store }
    }
]);

// 主应用监听状态
store.subscribe(() => {
    const state = store.getState();
    console.log('状态变化:', state);
});
```

```javascript
// ===== 子应用：使用共享 Store =====
export async function mount(props) {
    const { store } = props;

    // 获取状态
    const state = store.getState();
    console.log('当前状态:', state);

    // 修改状态
    store.dispatch({
        type: 'UPDATE_USER',
        payload: { id: 1, name: 'User' }
    });

    // 监听状态变化
    const unsubscribe = store.subscribe(() => {
        const newState = store.getState();
        // 更新 UI
    });

    // 卸载时取消监听
    return () => {
        unsubscribe();
    };
}
```

### 5. LocalStorage / SessionStorage

```javascript
// ===== 主应用 =====
// 更新用户信息
function updateUser(user) {
    localStorage.setItem('shared_user', JSON.stringify(user));
    
    // 触发 storage 事件
    window.dispatchEvent(new StorageEvent('storage', {
        key: 'shared_user',
        newValue: JSON.stringify(user)
    }));
}

// 监听其他应用的更新
window.addEventListener('storage', (e) => {
    if (e.key === 'shared_user') {
        const user = JSON.parse(e.newValue);
        console.log('用户信息更新:', user);
    }
});
```

```javascript
// ===== 子应用 =====
export async function mount(props) {
    // 读取共享数据
    const user = JSON.parse(localStorage.getItem('shared_user'));

    // 监听变化
    window.addEventListener('storage', (e) => {
        if (e.key === 'shared_user') {
            const newUser = JSON.parse(e.newValue);
            // 更新 UI
        }
    });

    // 更新数据
    localStorage.setItem('shared_user', JSON.stringify({
        id: 1,
        name: 'Updated User'
    }));
}
```

## 📊 通信方案对比

| 方案 | 复杂度 | 性能 | 灵活性 | 推荐度 |
|------|-------|------|--------|--------|
| Props | 低 | 高 | 低 | ⭐⭐⭐ |
| globalState | 中 | 高 | 中 | ⭐⭐⭐⭐ |
| 自定义事件 | 中 | 高 | 高 | ⭐⭐⭐⭐⭐ |
| 共享 Store | 高 | 中 | 高 | ⭐⭐⭐⭐ |
| Storage | 低 | 中 | 低 | ⭐⭐ |

## 🎓 面试要点

### 五种通信方式

1. **initGlobalState**：qiankun 官方方案
2. **Props**：简单直接
3. **自定义事件**：灵活强大
4. **共享 Store**：适合复杂状态
5. **Storage**：简单但有限制

### globalState 原理

1. **观察者模式**：状态变化通知所有监听器
2. **不可变更新**：每次返回新对象
3. **生命周期管理**：注册和注销监听

### 选择依据

1. **简单通信**：Props
2. **实时同步**：globalState 或自定义事件
3. **复杂状态**：共享 Store
4. **跨标签页**：Storage

应用间通信是微前端协作的关键，选择合适的方案能大大提升开发效率！

