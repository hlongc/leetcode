# 问题30：在生产环境中使用 qiankun 需要注意哪些问题？如何处理版本兼容性、浏览器兼容性等问题？

## 📌 生产环境检查清单

### 🔧 1. 配置检查

#### 1.1 生产环境配置

```javascript
// ✅ 生产环境配置
start({
    prefetch: true,              // 开启预加载
    singular: true,              // 单实例模式（稳定）
    sandbox: {
        strictStyleIsolation: false,
        experimentalStyleIsolation: true  // 开启样式隔离
    },
    fetch: productionFetch,      // 自定义 fetch（添加监控）
    
    // 错误处理
    // ...根据版本配置
});

// ❌ 避免的配置
start({
    sandbox: false,  // ❌ 不要关闭沙箱
    // ❌ 不要在生产环境使用 strictStyleIsolation（兼容性问题）
});
```

#### 1.2 子应用配置

```javascript
// 确保每个子应用都正确导出生命周期
export async function bootstrap(props) {
    console.log('[生产] bootstrap', props);
}

export async function mount(props) {
    console.log('[生产] mount', props);
    // 必须的挂载逻辑
}

export async function unmount(props) {
    console.log('[生产] unmount', props);
    // ⭐ 必须彻底清理资源
    ReactDOM.unmountComponentAtNode(props.container);
    
    // 清理全局监听
    window.removeEventListener('resize', handleResize);
    
    // 清理定时器
    clearInterval(timer);
    clearTimeout(timeout);
}
```

### 🌐 2. 跨域处理

#### 2.1 CORS 配置

```javascript
// 后端（子应用服务器）配置 CORS

// Express
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', 'https://main-app.com');
    res.header('Access-Control-Allow-Credentials', 'true');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    next();
});

// Nginx
location / {
    add_header Access-Control-Allow-Origin https://main-app.com;
    add_header Access-Control-Allow-Credentials true;
    add_header Access-Control-Allow-Methods 'GET, POST, PUT, DELETE';
    add_header Access-Control-Allow-Headers 'Content-Type, Authorization';
}
```

#### 2.2 自定义 fetch 处理跨域

```javascript
function createProductionFetch() {
    return async (url, options = {}) => {
        try {
            const response = await window.fetch(url, {
                ...options,
                credentials: 'include',  // 携带 cookies
                mode: 'cors'
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            return response;
        } catch (error) {
            // 错误上报
            reportError({
                type: 'fetch-error',
                url,
                error: error.message
            });

            throw error;
        }
    };
}

start({
    fetch: createProductionFetch()
});
```

### 🔒 3. 安全性

#### 3.1 CSP（内容安全策略）

```html
<!-- 设置 CSP -->
<meta http-equiv="Content-Security-Policy" 
      content="
        default-src 'self';
        script-src 'self' 'unsafe-eval' https://cdn.jsdelivr.net;
        style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
        connect-src 'self' https://api.example.com;
      ">
```

**注意：**
- `'unsafe-eval'`：qiankun 的沙箱需要使用 eval
- `'unsafe-inline'`：内联样式需要

#### 3.2 XSS 防护

```javascript
// 验证子应用入口
function validateAppEntry(entry) {
    const allowedDomains = [
        'localhost',
        'your-domain.com',
        'cdn.your-domain.com'
    ];

    try {
        const url = new URL(entry);
        if (!allowedDomains.some(domain => url.hostname.includes(domain))) {
            throw new Error('不允许的域名');
        }
        return true;
    } catch (error) {
        console.error('无效的应用入口:', entry);
        return false;
    }
}

// 注册前验证
const validApps = apps.filter(app => validateAppEntry(app.entry));
registerMicroApps(validApps);
```

### 🔍 4. 监控和错误处理

#### 4.1 全局错误监控

```javascript
// 统一的错误处理
function setupErrorMonitoring() {
    // JS 错误
    window.addEventListener('error', (event) => {
        reportError({
            type: 'js-error',
            message: event.message,
            filename: event.filename,
            line: event.lineno,
            column: event.colno,
            stack: event.error?.stack,
            timestamp: Date.now()
        });
    });

    // Promise 错误
    window.addEventListener('unhandledrejection', (event) => {
        reportError({
            type: 'promise-error',
            message: event.reason?.message || event.reason,
            stack: event.reason?.stack,
            timestamp: Date.now()
        });
    });

    // qiankun 错误
    window.addEventListener('single-spa:routing-event', (event) => {
        if (event.detail.type === 'error') {
            reportError({
                type: 'qiankun-error',
                appName: event.detail.appName,
                message: event.detail.error?.message,
                stack: event.detail.error?.stack,
                timestamp: Date.now()
            });
        }
    });
}

setupErrorMonitoring();
```

#### 4.2 性能监控

```javascript
// 监控各应用的加载性能
registerMicroApps(apps, {
    beforeLoad: (app) => {
        performance.mark(`${app.name}-load-start`);
    },
    afterMount: (app) => {
        performance.mark(`${app.name}-load-end`);
        performance.measure(
            `${app.name}-load`,
            `${app.name}-load-start`,
            `${app.name}-load-end`
        );

        const measure = performance.getEntriesByName(`${app.name}-load`)[0];
        
        // 上报性能数据
        reportPerformance({
            appName: app.name,
            loadTime: measure.duration,
            timestamp: Date.now()
        });
    }
});
```

### 🌍 5. 浏览器兼容性

#### 5.1 Polyfill

```javascript
// polyfill.js
import 'core-js/stable';
import 'regenerator-runtime/runtime';

// Proxy polyfill（不完美，但可以部分支持）
if (!window.Proxy) {
    require('proxy-polyfill');
}

// fetch polyfill
if (!window.fetch) {
    require('whatwg-fetch');
}

// CustomEvent polyfill（IE）
if (typeof window.CustomEvent !== 'function') {
    function CustomEvent(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: null };
        const evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    }
    window.CustomEvent = CustomEvent;
}
```

#### 5.2 浏览器检测和降级

```javascript
// 检测浏览器能力
function detectBrowserCapabilities() {
    return {
        proxy: typeof Proxy !== 'undefined',
        customElements: typeof window.customElements !== 'undefined',
        shadowDOM: typeof document.createElement('div').attachShadow === 'function',
        es6: typeof Symbol !== 'undefined'
    };
}

// 根据能力调整配置
const capabilities = detectBrowserCapabilities();

start({
    sandbox: capabilities.proxy,  // 不支持 Proxy 则关闭沙箱
    strictStyleIsolation: capabilities.shadowDOM && false,  // 生产环境不建议开启
    experimentalStyleIsolation: true
});
```

### 📦 6. 版本管理

#### 6.1 主应用与子应用版本协议

```javascript
// 定义版本协议
const APP_PROTOCOL_VERSION = '1.0.0';

// 主应用
registerMicroApps([
    {
        name: 'react-app',
        entry: '//localhost:8080',
        props: {
            protocolVersion: APP_PROTOCOL_VERSION
        }
    }
]);

// 子应用验证
export async function bootstrap(props) {
    const { protocolVersion } = props;
    
    // 检查版本兼容性
    if (!isCompatible(protocolVersion, REQUIRED_VERSION)) {
        throw new Error(`版本不兼容: 需要 ${REQUIRED_VERSION}, 当前 ${protocolVersion}`);
    }
}
```

#### 6.2 qiankun 版本

```javascript
// package.json
{
    "dependencies": {
        "qiankun": "^2.10.0"  // 锁定大版本
    }
}

// 主应用和所有子应用使用相同的 qiankun 大版本
// 避免 API 不兼容
```

### 🚀 7. 部署策略

#### 7.1 资源部署

```javascript
// 主应用和子应用分开部署

// 主应用
https://main.example.com/
    ├── index.html
    ├── main.js
    └── vendors.js

// 子应用A
https://app-a.example.com/
    ├── index.html
    ├── main.js
    └── vendors.js

// 子应用B
https://app-b.example.com/
    ├── index.html
    ├── main.js
    └── vendors.js

// 或使用同一域名不同路径
https://example.com/
    ├── main/          # 主应用
    ├── app-a/         # 子应用A
    └── app-b/         # 子应用B
```

#### 7.2 灰度发布

```javascript
// 根据用户灰度策略选择应用版本

function getAppEntry(appName, userInfo) {
    const isGrayUser = checkGrayList(userInfo.id);
    
    if (isGrayUser) {
        // 灰度用户使用新版本
        return `https://cdn.example.com/${appName}/v2/index.html`;
    } else {
        // 普通用户使用稳定版本
        return `https://cdn.example.com/${appName}/v1/index.html`;
    }
}

registerMicroApps([
    {
        name: 'react-app',
        entry: getAppEntry('react-app', currentUser),
        // ...
    }
]);
```

### ⚡ 8. 性能优化

#### 8.1 CDN 加速

```javascript
// 所有静态资源使用 CDN
const CDN_BASE = 'https://cdn.example.com';

// 子应用配置
registerMicroApps([
    {
        name: 'react-app',
        entry: `${CDN_BASE}/react-app/index.html`,
        // ...
    }
]);

// webpack 配置
module.exports = {
    output: {
        publicPath: process.env.NODE_ENV === 'production'
            ? 'https://cdn.example.com/react-app/'
            : '/'
    }
};
```

#### 8.2 HTTP/2

```nginx
# Nginx 配置
server {
    listen 443 ssl http2;  # ⭐ 启用 HTTP/2
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    # ...
}

# HTTP/2 优势：
# - 多路复用（一个连接加载多个资源）
# - 头部压缩
# - 服务器推送
```

### 🐛 9. 常见问题处理

#### 9.1 子应用加载失败

```javascript
// 自动重试机制
registerMicroApps(apps, {
    beforeLoad: async (app) => {
        let retries = 3;
        let error;
        
        while (retries > 0) {
            try {
                // 验证应用可访问性
                await fetch(app.entry, { method: 'HEAD' });
                return;
            } catch (e) {
                error = e;
                retries--;
                
                if (retries > 0) {
                    console.log(`应用 ${app.name} 加载失败，重试中... (剩余${retries}次)`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
            }
        }
        
        // 显示错误页面
        showErrorPage(app.name, '应用加载失败，请刷新重试');
        throw error;
    }
});
```

#### 9.2 样式冲突

```javascript
// CSS 重置作用域限制
// 主应用
#main-app {
    * { margin: 0; padding: 0; }
}

// 子应用
#subapp-container {
    * { 
        /* 子应用的重置样式 */
    }
}

// 避免全局 * 选择器
```

#### 9.3 内存泄漏

```javascript
// 检测内存泄漏
let memoryCheckTimer;

function startMemoryMonitoring() {
    memoryCheckTimer = setInterval(() => {
        if (performance.memory) {
            const { usedJSHeapSize, jsHeapSizeLimit } = performance.memory;
            const usage = (usedJSHeapSize / jsHeapSizeLimit * 100).toFixed(2);
            
            console.log(`内存使用: ${usage}%`);
            
            if (usage > 90) {
                console.warn('内存使用过高，可能存在内存泄漏');
                
                // 上报警告
                reportWarning({
                    type: 'memory-leak',
                    usage,
                    timestamp: Date.now()
                });
            }
        }
    }, 30000);  // 每30秒检查一次
}

// 确保子应用正确清理
export async function unmount(props) {
    // 清理所有资源
    clearAllTimers();
    clearAllListeners();
    clearAllConnections();
    
    // React 卸载
    ReactDOM.unmountComponentAtNode(props.container);
}
```

### 📊 10. 监控和日志

#### 10.1 应用状态监控

```javascript
// 监控所有应用的状态
const appStatusMonitor = {
    apps: new Map(),
    
    updateStatus(appName, status) {
        this.apps.set(appName, {
            status,
            timestamp: Date.now()
        });
        
        // 上报状态
        reportAppStatus(appName, status);
    }
};

registerMicroApps(apps, {
    beforeLoad: (app) => appStatusMonitor.updateStatus(app.name, 'loading'),
    afterMount: (app) => appStatusMonitor.updateStatus(app.name, 'mounted'),
    beforeUnmount: (app) => appStatusMonitor.updateStatus(app.name, 'unmounting'),
    afterUnmount: (app) => appStatusMonitor.updateStatus(app.name, 'unmounted')
});
```

#### 10.2 用户行为追踪

```javascript
// 追踪用户在微应用间的跳转
window.addEventListener('single-spa:routing-event', (event) => {
    const { newUrl, oldUrl } = event.detail;
    
    // 上报路由变化
    analytics.track('route_change', {
        from: oldUrl,
        to: newUrl,
        timestamp: Date.now()
    });
});
```

## 🎓 面试要点

### 配置

1. **沙箱必开**：生产环境必须开启沙箱
2. **样式隔离**：推荐 experimentalStyleIsolation
3. **预加载**：根据实际情况配置
4. **错误处理**：自定义 fetch 添加重试和监控

### 跨域

1. **CORS 配置**：后端正确配置
2. **credentials**：携带凭证
3. **自定义 fetch**：统一处理

### 安全

1. **CSP**：合理配置内容安全策略
2. **入口验证**：验证子应用来源
3. **XSS 防护**：过滤用户输入
4. **HTTPS**：生产环境必须使用

### 兼容性

1. **Polyfill**：为老浏览器提供支持
2. **降级方案**：不支持 Proxy 时的处理
3. **浏览器检测**：根据能力调整配置

### 监控

1. **错误监控**：捕获所有错误
2. **性能监控**：监控加载时间
3. **状态监控**：应用状态变化
4. **用户行为**：路由跳转、交互

### 运维

1. **灰度发布**：逐步发布新版本
2. **版本管理**：主应用和子应用版本协议
3. **内存监控**：检测内存泄漏
4. **日志收集**：完整的日志系统

## 💡 生产环境检查清单

```markdown
部署前检查：
□ 沙箱已开启
□ 样式隔离已配置
□ 跨域配置正确
□ 错误处理完善
□ 性能监控就位
□ 所有子应用生命周期正确导出
□ 资源已压缩
□ CDN 已配置
□ HTTPS 已启用
□ CSP 已配置
□ 灰度方案已准备
□ 回滚方案已准备

运行时监控：
□ 应用加载成功率
□ 平均加载时间
□ 错误率
□ 内存使用
□ 用户行为路径
```

生产环境的 qiankun 应用需要在稳定性、性能、安全性等多个维度做好准备，确保系统的健壮运行！

