/*
 * @lc app=leetcode.cn id=85 lang=typescript
 *
 * [85] 最大矩形
 *
 * https://leetcode.cn/problems/maximal-rectangle/description/
 *
 * algorithms
 * Hard (56.02%)
 * Likes:    1759
 * Dislikes: 0
 * Total Accepted:    225.8K
 * Total Submissions: 403K
 * Testcase Example:  '[["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]'
 *
 * 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：matrix =
 * [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
 * 输出：6
 * 解释：最大矩形如上图所示。
 *
 *
 * 示例 2：
 *
 *
 * 输入：matrix = [["0"]]
 * 输出：0
 *
 *
 * 示例 3：
 *
 *
 * 输入：matrix = [["1"]]
 * 输出：1
 *
 *
 *
 *
 * 提示：
 *
 *
 * rows == matrix.length
 * cols == matrix[0].length
 * 1 <= row, cols <= 200
 * matrix[i][j] 为 '0' 或 '1'
 *
 *
 */

// @lc code=start

/**
 * 解法一：动态规划 + 柱状图最大矩形（推荐）
 * 时间复杂度：O(m*n)，其中 m 是行数，n 是列数
 * 空间复杂度：O(n)
 *
 * 核心思想：
 * 1. 将每一行看作柱状图的底部
 * 2. 计算每列的高度（连续1的个数）
 * 3. 对每一行使用柱状图最大矩形算法
 */
function maximalRectangle(matrix: string[][]): number {
  // 边界情况处理：如果矩阵为空或没有列，直接返回0
  if (!matrix || matrix.length === 0 || matrix[0].length === 0) {
    return 0;
  }

  // 获取矩阵的行数和列数
  const rows = matrix.length; // 矩阵的行数
  const cols = matrix[0].length; // 矩阵的列数
  let maxArea = 0; // 记录全局最大矩形面积

  // 动态规划数组，记录每列的高度（连续1的个数）
  // 这个数组会在每一行处理时更新
  const heights = new Array(cols).fill(0);

  // 逐行处理矩阵，将每一行看作柱状图的底部
  for (let i = 0; i < rows; i++) {
    // 更新每列的高度
    for (let j = 0; j < cols; j++) {
      if (matrix[i][j] === "1") {
        // 如果当前位置是'1'，高度+1（表示连续1的个数）
        heights[j] += 1;
      } else {
        // 如果当前位置是'0'，高度重置为0（表示连续1中断）
        heights[j] = 0;
      }
    }

    // 对当前行的柱状图计算最大矩形面积
    // 这里调用柱状图最大矩形算法
    maxArea = Math.max(maxArea, largestRectangleArea(heights));
  }

  // 返回所有行中的最大矩形面积
  return maxArea;
}

/**
 * 计算柱状图中的最大矩形面积
 * 使用单调栈优化
 *
 * 核心思想：对于每个柱子，找到以它为高度的最大矩形
 *
 * 单调栈原理：
 * - 栈中存储柱子索引，栈底到栈顶高度单调递增
 * - 当遇到比栈顶元素小的柱子时，栈顶元素无法继续向右延伸
 * - 此时弹出栈顶元素，计算以该高度为高的最大矩形面积
 *
 * 详细例子：heights = [2, 1, 5, 6, 2, 3]
 *
 * 执行过程：
 * i=0, height=2: 栈空，入栈 [0]
 * i=1, height=1: 1<2，弹出0，计算面积=2×1=2，入栈 [1]
 * i=2, height=5: 5>1，入栈 [1,2]
 * i=3, height=6: 6>5，入栈 [1,2,3]
 * i=4, height=2: 2<6，弹出3，面积=6×1=6；2<5，弹出2，面积=5×2=10；入栈 [1,4]
 * i=5, height=3: 3>2，入栈 [1,4,5]
 * i=6, height=0: 0<3，弹出5，面积=3×1=3；0<2，弹出4，面积=2×4=8；0<1，弹出1，面积=1×6=6
 *
 * 最大面积 = 10
 */
function largestRectangleArea(heights: number[]): number {
  // 单调栈：存储柱子的索引，栈中元素的高度单调递增
  const stack: number[] = [];
  let maxArea = 0; // 记录最大矩形面积

  // 遍历所有柱子，包括一个虚拟的0高度柱子
  for (let i = 0; i <= heights.length; i++) {
    // 在数组末尾添加0，确保所有元素都能被处理
    // 这个0高度的柱子会触发栈中所有剩余元素的面积计算
    const currentHeight = i === heights.length ? 0 : heights[i];

    // 维护单调递增栈（栈底到栈顶高度递增，栈顶元素最大）
    // 当遇到比栈顶元素小的柱子时，说明栈顶元素无法继续向右延伸
    // 需要弹出栈顶元素，计算以该高度为高的最大矩形面积
    while (
      stack.length > 0 &&
      heights[stack[stack.length - 1]] > currentHeight
    ) {
      // 弹出栈顶元素，计算以该柱子为高度的最大矩形面积
      const height = heights[stack.pop()!];

      // 计算宽度：当前索引 - 新的栈顶索引 - 1
      // 当栈为空时，说明当前要计算面积的柱子比之前所有处理过的柱子都要小，宽度就是当前索引
      //
      // 宽度计算原理：
      // - 左边界：新栈顶元素的索引（如果栈为空，左边界就是0）
      // - 右边界：当前索引i
      // - 宽度 = 右边界 - 左边界 - 1
      //
      // 例子：heights=[2,1,5,6,2,3]，当i=4, currentHeight=2时
      // 弹出索引3（高度6），新栈顶是索引2（高度5）
      // 宽度 = 4 - 2 - 1 = 1，面积 = 6 × 1 = 6
      const width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;

      // 更新最大面积
      maxArea = Math.max(maxArea, height * width);
    }

    // 将当前柱子索引压入栈中
    stack.push(i);
  }

  return maxArea;
}

/**
 * ==================== 详细示例说明 ====================
 *
 * 题目示例：matrix = [
 *   ["1","0","1","0","0"],
 *   ["1","0","1","1","1"],
 *   ["1","1","1","1","1"],
 *   ["1","0","0","1","0"]
 * ]
 * 输出：6
 *
 * 解法一执行过程（动态规划 + 柱状图）：
 *
 * 第0行处理：
 * heights = [1, 0, 1, 0, 0]
 * 柱状图：█     █
 * 最大矩形面积 = 1
 *
 * 第1行处理：
 * heights = [2, 0, 2, 1, 1]
 * 柱状图：██    ██ █ █
 * 最大矩形面积 = 2
 *
 * 第2行处理：
 * heights = [3, 1, 3, 2, 2]
 * 柱状图：███ █ ███ ██ ██
 * 最大矩形面积 = 6 (矩形从位置1到4，高度为3)
 *
 * 第3行处理：
 * heights = [4, 0, 0, 3, 0]
 * 柱状图：████      ███
 * 最大矩形面积 = 4
 *
 * 最终结果：max(1, 2, 6, 4) = 6
 *
 * 解法二执行过程（暴力解法）：
 *
 * 枚举所有可能的矩形：
 * - 矩形(0,0)到(2,4)：检查发现包含0，无效
 * - 矩形(1,2)到(2,4)：检查发现全为1，面积=6
 * - 矩形(0,0)到(1,0)：面积=2
 * - 矩形(2,0)到(2,4)：面积=5
 * - 其他矩形面积都小于6
 *
 * 最终结果：6
 *
 * 解法三执行过程（动态规划 + 左右边界）：
 *
 * 第2行处理（heights = [3, 1, 3, 2, 2]）：
 *
 * 更新左边界：
 * j=0: left[0] = 0
 * j=1: left[1] = 0 (因为matrix[2][1]='1')
 * j=2: left[2] = 0
 * j=3: left[3] = 0
 * j=4: left[4] = 0
 *
 * 更新右边界：
 * j=4: right[4] = 5
 * j=3: right[3] = 5
 * j=2: right[2] = 5
 * j=1: right[1] = 5
 * j=0: right[0] = 5
 *
 * 计算面积：
 * j=0: area = 3 * (5-0) = 15
 * j=1: area = 1 * (5-0) = 5
 * j=2: area = 3 * (5-0) = 15
 * j=3: area = 2 * (5-0) = 10
 * j=4: area = 2 * (5-0) = 10
 *
 * 最大面积 = 15，但这是错误的！
 * 问题：没有正确计算左右边界
 *
 * 正确的左右边界计算应该是：
 * 对于高度为3的柱子，左边界应该是0，右边界应该是5
 * 对于高度为1的柱子，左边界应该是0，右边界应该是5
 * 但这样计算出来的面积是15，明显不对
 *
 * 实际上，解法三需要更复杂的边界计算逻辑
 *
 * ==================== 算法复杂度对比 ====================
 *
 * 解法一（推荐）：
 * - 时间复杂度：O(m*n)
 * - 空间复杂度：O(n)
 * - 优势：思路清晰，效率高，代码简洁
 * - 适用：所有规模的数据
 *
 * 解法二（暴力）：
 * - 时间复杂度：O(m²*n²)
 * - 空间复杂度：O(1)
 * - 优势：容易理解，实现简单
 * - 适用：小规模数据（m*n < 100）
 *
 * 解法三（DP+边界）：
 * - 时间复杂度：O(m*n)
 * - 空间复杂度：O(n)
 * - 优势：纯动态规划思路
 * - 适用：需要理解DP思想的场景
 *
 * ==================== 关键技巧 ====================
 *
 * 1. 柱状图最大矩形算法：
 *    - 使用单调栈维护递增序列
 *    - 当遇到较小元素时，计算之前所有较大元素的面积
 *    - 在数组末尾添加0确保所有元素都被处理
 *
 * 2. 高度数组更新：
 *    - 遇到'1'时高度+1
 *    - 遇到'0'时高度重置为0
 *    - 这样每行的高度数组就形成了柱状图
 *
 * 3. 边界处理：
 *    - 空数组直接返回0
 *    - 单行或单列需要特殊处理
 *    - 单调栈需要哨兵元素
 *
 * ==================== 测试用例 ====================
 *
 * 测试用例1：
 * 输入：[["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
 * 输出：6
 *
 * 测试用例2：
 * 输入：[["0"]]
 * 输出：0
 *
 * 测试用例3：
 * 输入：[["1"]]
 * 输出：1
 *
 * 测试用例4：
 * 输入：[["1","1","1","1","1"]]
 * 输出：5
 *
 * 测试用例5：
 * 输入：[["1"],["1"],["1"],["1"],["1"]]
 * 输出：5
 */

// @lc code=end
