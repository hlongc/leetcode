/*
 * @lc app=leetcode.cn id=735 lang=typescript
 *
 * [735] 小行星碰撞
 *
 * https://leetcode.cn/problems/asteroid-collision/description/
 *
 * algorithms
 * Medium (42.99%)
 * Likes:    564
 * Dislikes: 0
 * Total Accepted:    115.5K
 * Total Submissions: 268.5K
 * Testcase Example:  '[5,10,-5]'
 *
 * 给定一个整数数组 asteroids，表示在同一行的小行星。数组中小行星的索引表示它们在空间中的相对位置。
 *
 * 对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。
 *
 *
 * 找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：asteroids = [5,10,-5]
 * 输出：[5,10]
 * 解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。
 *
 * 示例 2：
 *
 *
 * 输入：asteroids = [8,-8]
 * 输出：[]
 * 解释：8 和 -8 碰撞后，两者都发生爆炸。
 *
 * 示例 3：
 *
 *
 * 输入：asteroids = [10,2,-5]
 * 输出：[10]
 * 解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。
 *
 * 示例 4：
 *
 *
 * 输入：asteroids = [3,5,-6,2,-1,4]
 * 输出：[-6,2,4]
 * 解释：小行星 -6 使小行星 3 和 5 爆炸，然后继续向左移动。在另一边，小行星 2 使小行星 -1 爆炸，然后继续向右移动，没有碰撞小行星
 * 4。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 2 <= asteroids.length <= 10^4
 * -1000 <= asteroids[i] <= 1000
 * asteroids[i] != 0
 *
 *
 */

// @lc code=start
/**
 * 解题思路：栈模拟碰撞过程
 *
 * 核心思想：
 * 使用栈来模拟小行星的碰撞过程
 *
 * 碰撞规则：
 * 1. 只有当栈顶是向右(>0)，当前是向左(<0)时才会碰撞
 * 2. 其他情况（同向或背离）不会碰撞，直接入栈
 *
 * 碰撞结果：
 * - |栈顶| > |当前|：当前爆炸，栈顶保留
 * - |栈顶| < |当前|：栈顶爆炸，当前继续与下一个栈顶比较
 * - |栈顶| = |当前|：两者都爆炸
 *
 * 算法流程：
 * 1. 遍历每个小行星
 * 2. 如果当前向左移动，检查是否与栈顶碰撞
 * 3. 处理连续碰撞（当前小行星可能连续击碎多个栈顶）
 * 4. 如果当前小行星存活，入栈
 *
 * 时间复杂度：O(n)，每个元素最多入栈出栈一次
 * 空间复杂度：O(n)，栈的空间
 */
function asteroidCollision(asteroids: number[]): number[] {
  const stack: number[] = [];

  for (const asteroid of asteroids) {
    // 标记当前小行星是否存活
    let alive = true;

    // 当前小行星向左移动(<0)，且栈顶向右移动(>0)时，会发生碰撞
    while (
      alive &&
      asteroid < 0 &&
      stack.length > 0 &&
      stack[stack.length - 1] > 0
    ) {
      const top = stack[stack.length - 1];

      // 比较绝对值大小
      if (Math.abs(top) < Math.abs(asteroid)) {
        // 栈顶较小，栈顶爆炸，当前继续与下一个栈顶比较
        stack.pop();
      } else if (Math.abs(top) === Math.abs(asteroid)) {
        // 大小相同，两者都爆炸
        stack.pop();
        alive = false;
      } else {
        // 栈顶较大，当前爆炸
        alive = false;
      }
    }

    // 如果当前小行星存活，入栈
    if (alive) {
      stack.push(asteroid);
    }
  }

  return stack;
}

/**
 * 算法图解：
 *
 * 示例1：asteroids = [5,10,-5]
 *
 * 处理 5：
 * stack = [5]
 *
 * 处理 10：
 * 10 > 0，不会与栈顶碰撞
 * stack = [5, 10]
 *
 * 处理 -5：
 * -5 < 0，栈顶 10 > 0，会碰撞
 * |10| > |-5|，-5 爆炸
 * stack = [5, 10] ✓
 *
 *
 * 示例2：asteroids = [8,-8]
 *
 * 处理 8：
 * stack = [8]
 *
 * 处理 -8：
 * -8 < 0，栈顶 8 > 0，会碰撞
 * |8| = |-8|，两者都爆炸
 * stack = [] ✓
 *
 *
 * 示例3：asteroids = [10,2,-5]
 *
 * 处理 10：
 * stack = [10]
 *
 * 处理 2：
 * stack = [10, 2]
 *
 * 处理 -5：
 * -5 < 0，栈顶 2 > 0，会碰撞
 * |2| < |-5|，2 爆炸，-5 继续
 * 栈顶变为 10，继续碰撞
 * |10| > |-5|，-5 爆炸
 * stack = [10] ✓
 *
 *
 * 示例4：asteroids = [3,5,-6,2,-1,4]
 *
 * 处理 3：stack = [3]
 * 处理 5：stack = [3, 5]
 *
 * 处理 -6：
 * 与 5 碰撞：|5| < |-6|，5 爆炸
 * 与 3 碰撞：|3| < |-6|，3 爆炸
 * stack = [-6]
 *
 * 处理 2：
 * 2 > 0，-6 < 0，方向相反但不会碰撞（背离）
 * stack = [-6, 2]
 *
 * 处理 -1：
 * 与 2 碰撞：|2| > |-1|，-1 爆炸
 * stack = [-6, 2]
 *
 * 处理 4：
 * stack = [-6, 2, 4] ✓
 *
 *
 * 碰撞条件总结：
 *
 * 会碰撞：
 * - 栈顶 > 0（向右）且 当前 < 0（向左）
 * - 例如：[5, -3] → 相向而行
 *
 * 不会碰撞：
 * - 栈顶 > 0，当前 > 0（同向右）
 * - 栈顶 < 0，当前 < 0（同向左）
 * - 栈顶 < 0，当前 > 0（背离）
 * - 例如：[5, 3]、[-5, -3]、[-5, 3]
 *
 *
 * 关键点：
 * 1. 使用 while 循环处理连续碰撞
 * 2. 只有向右和向左相遇才会碰撞
 * 3. 用 alive 标记当前小行星是否存活
 * 4. 栈存储最终存活的小行星
 */
// @lc code=end
