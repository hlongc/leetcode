/*
 * @lc app=leetcode.cn id=287 lang=typescript
 *
 * [287] 寻找重复数
 *
 * https://leetcode.cn/problems/find-the-duplicate-number/description/
 *
 * algorithms
 * Medium (66.78%)
 * Likes:    2676
 * Dislikes: 0
 * Total Accepted:    553.6K
 * Total Submissions: 828.5K
 * Testcase Example:  '[1,3,4,2,2]'
 *
 * 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。
 *
 * 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
 *
 * 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,3,4,2,2]
 * 输出：2
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [3,1,3,4,2]
 * 输出：3
 *
 *
 * 示例 3 :
 *
 *
 * 输入：nums = [3,3,3,3,3]
 * 输出：3
 *
 *
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= n <= 10^5
 * nums.length == n + 1
 * 1 <= nums[i] <= n
 * nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次
 *
 *
 *
 *
 * 进阶：
 *
 *
 * 如何证明 nums 中至少存在一个重复的数字?
 * 你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？
 *
 *
 */

// @lc code=start
function findDuplicate(nums: number[]): number {
  /*
   * ==================== 核心思想 ====================
   * 使用弗洛伊德判圈算法（Floyd's Cycle Detection Algorithm）
   *
   * 1. 将数组看作链表：nums[i] 表示从位置 i 指向位置 nums[i] 的边
   * 2. 由于数组中存在重复数字，这个"链表"必然存在环
   * 3. 环的入口就是重复的数字
   *
   * 为什么会有环？
   * - 数组长度为 n+1，元素范围是 [1, n]
   * - 从索引 0 开始遍历：0 → nums[0] → nums[nums[0]] → ...
   * - 由于有重复数字，必然存在两个不同的索引指向同一个位置
   * - 这形成了环，环的入口就是重复的数字
   *
   * 示例：nums = [1,3,4,2,2]
   * 链表结构：0 → 1 → 3 → 2 → 4 → 2 → 4 → ... (形成环)
   * 环的入口是位置2，对应数字2，这就是重复的数字
   */

  /*
   * ==================== 算法步骤 ====================
   * 第一阶段：找到快慢指针的相遇点
   * - 慢指针每次走一步：slow = nums[slow]
   * - 快指针每次走两步：fast = nums[nums[fast]]
   * - 当快慢指针相遇时，说明存在环
   *
   * 第二阶段：找到环的入口点（重复数字）
   * - 将快指针重置到起点
   * - 两个指针都每次走一步
   * - 当它们再次相遇时，相遇点就是环的入口
   */

  // 第一阶段：找到快慢指针的相遇点
  // 初始化快慢指针都在起点（索引0）
  let slow = 0;
  let fast = 0;

  // 快慢指针移动，直到相遇
  do {
    slow = nums[slow]; // 慢指针走一步
    fast = nums[nums[fast]]; // 快指针走两步
  } while (slow !== fast);

  // 第二阶段：找到环的入口点（重复数字）
  // 将快指针重置到起点，两个指针都每次走一步
  fast = 0;
  while (slow !== fast) {
    slow = nums[slow]; // 慢指针继续从相遇点走
    fast = nums[fast]; // 快指针从起点开始走
  }

  /*
   * ==================== 数学证明 ====================
   * 设：
   * - 起点到环入口的距离为 a
   * - 环入口到相遇点的距离为 b
   * - 相遇点到环入口的距离为 c
   *
   * 第一阶段结束时：
   * - 慢指针走了：a + b
   * - 快指针走了：a + b + c + b = a + 2b + c
   *
   * 由于快指针速度是慢指针的2倍：
   * 2(a + b) = a + 2b + c
   * 2a + 2b = a + 2b + c
   * a = c
   *
   * 因此，从起点走 a 步和从相遇点走 c 步会到达同一个位置（环的入口）
   * 这就是为什么第二阶段算法能够找到环入口的原理
   */

  // 返回环的入口点，这就是重复的数字
  return slow;
}
// @lc code=end
