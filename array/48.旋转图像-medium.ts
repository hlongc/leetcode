/*
 * @lc app=leetcode.cn id=48 lang=typescript
 *
 * [48] 旋转图像
 *
 * https://leetcode.cn/problems/rotate-image/description/
 *
 * algorithms
 * Medium (78.97%)
 * Likes:    2129
 * Dislikes: 0
 * Total Accepted:    842.2K
 * Total Submissions: 1.1M
 * Testcase Example:  '[[1,2,3],[4,5,6],[7,8,9]]'
 *
 * 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
 *
 * 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
 * 输出：[[7,4,1],[8,5,2],[9,6,3]]
 *
 *
 * 示例 2：
 *
 *
 * 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
 * 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 *
 *
 *
 *
 * 提示：
 *
 *
 * n == matrix.length == matrix[i].length
 * 1 <= n <= 20
 * -1000 <= matrix[i][j] <= 1000
 *
 *
 *
 *
 */

// @lc code=start
/**
 Do not return anything, modify matrix in-place instead.
 */
function rotate(matrix: number[][]): void {
  const n = matrix.length;

  // 方法1：先转置，再水平翻转
  // 这是最直观的方法，容易理解和实现

  // 第一步：转置矩阵（沿主对角线翻转）
  // 将 matrix[i][j] 与 matrix[j][i] 交换
  for (let i = 0; i < n; i++) {
    for (let j = i; j < n; j++) {
      // 只遍历上三角，避免重复交换
      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
    }
  }

  // 第二步：水平翻转（左右翻转）
  // 将每行的元素左右对称交换
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < Math.floor(n / 2); j++) {
      // 只遍历左半部分，避免重复交换
      [matrix[i][j], matrix[i][n - 1 - j]] = [
        matrix[i][n - 1 - j],
        matrix[i][j],
      ];
    }
  }
}

/*
🎯 核心思想：先转置，再水平翻转
- 顺时针旋转90度 = 转置 + 水平翻转
- 这是最直观和容易理解的方法

📊 详细例子：matrix = [[1,2,3],[4,5,6],[7,8,9]]

原始矩阵：
1 2 3
4 5 6  
7 8 9

第一步：转置（沿主对角线翻转）
交换 matrix[i][j] 与 matrix[j][i]

i=0: j=0,1,2
- (0,0): 1↔1 (不变)
- (0,1): 2↔4 → [1,4,3][2,5,6][7,8,9]
- (0,2): 3↔7 → [1,4,7][2,5,6][3,8,9]

i=1: j=1,2  
- (1,1): 5↔5 (不变)
- (1,2): 6↔8 → [1,4,7][2,5,8][3,6,9]

i=2: j=2
- (2,2): 9↔9 (不变)

转置后：
1 4 7
2 5 8
3 6 9

第二步：水平翻转（左右翻转）
交换每行的左右对称元素

第0行：[1,4,7] → [7,4,1]
第1行：[2,5,8] → [8,5,2]  
第2行：[3,6,9] → [9,6,3]

最终结果：
7 4 1
8 5 2
9 6 3

🔑 关键理解：

1. 为什么转置+翻转=旋转90度？
   - 转置：将行变成列
   - 水平翻转：将列的顺序反转
   - 组合效果：顺时针旋转90度

2. 为什么只遍历上三角？
   - 转置时，matrix[i][j] 和 matrix[j][i] 是对称的
   - 如果遍历全部，会交换两次，结果不变
   - 只遍历上三角避免重复交换

3. 为什么只遍历左半部分？
   - 水平翻转时，matrix[i][j] 和 matrix[i][n-1-j] 是对称的
   - 遍历全部会交换两次，结果不变
   - 只遍历左半部分避免重复交换

📈 另一个例子：4x4矩阵
原始：[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]

转置后：
5  2  13 15
1  4  3  14
9  8  6  12
11 10 7  16

水平翻转后：
15 13 2  5
14 3  4  1
12 6  8  9
16 7  10 11

⚡ 复杂度分析：
时间复杂度：O(n²) - 需要访问每个元素
空间复杂度：O(1) - 原地操作，只用了常数额外空间

🔄 替代方法：四元素旋转
也可以直接进行四元素循环交换，但理解起来更复杂：
- 对于位置(i,j)，顺时针90度后到达(j, n-1-i)
- 需要找到四个位置的循环关系进行交换
*/
// @lc code=end
