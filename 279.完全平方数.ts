/*
 * @lc app=leetcode.cn id=279 lang=typescript
 *
 * [279] 完全平方数
 */

// @lc code=start
/**
 * 求组成正整数n的最少完全平方数个数
 * 题目要求：给定正整数n，找到若干个完全平方数（比如1, 4, 9, 16, ...）使得它们的和等于n
 * 并返回所需的最少完全平方数个数
 *
 * 解题思路：动态规划
 * 1. 定义状态：dp[i]表示组成整数i所需的最少完全平方数个数
 * 2. 状态转移方程：dp[i] = min(dp[i], dp[i - j*j] + 1)，其中j*j <= i
 * 3. 初始状态：dp[i] = i，相当于全部用1来组成（最差情况）
 *
 * 例如：
 * - dp[1] = 1（1个1）
 * - dp[2] = 2（2个1）
 * - dp[3] = 3（3个1）
 * - dp[4] = 1（1个4，比4个1更优）
 * - dp[5] = 2（1个4 + 1个1，比5个1更优）
 *
 * 时间复杂度：O(n * sqrt(n))，对于每个数i，我们需要尝试sqrt(i)种完全平方数
 * 空间复杂度：O(n)，用于存储dp数组
 *
 * @param n 目标正整数
 * @return 组成n的最少完全平方数个数
 */
function numSquares(n: number): number {
  // 创建dp数组
  // dp[i]表示组成数字i所需的最少完全平方数个数
  const dp: number[] = new Array(n + 1).fill(0);

  // 枚举每个数字
  for (let i = 1; i <= n; i++) {
    // 初始化为最差情况：全部由1组成，即需要i个数
    dp[i] = i;

    // 枚举所有可能的完全平方数j*j，其中j*j <= i
    for (let j = 1; j * j <= i; j++) {
      // 状态转移：尝试使用一个j*j，然后递归查找剩余部分(i-j*j)的最优解
      // dp[i-j*j] + 1 表示使用一个j*j和组成(i-j*j)所需的最少平方数个数
      // "+1"表示使用了一个j*j
      dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
    }
  }

  // 返回组成n所需的最少完全平方数个数
  return dp[n];
}
// @lc code=end
