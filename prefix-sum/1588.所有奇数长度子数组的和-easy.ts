/*
 * @lc app=leetcode.cn id=1588 lang=typescript
 *
 * [1588] 所有奇数长度子数组的和
 *
 * https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/description/
 *
 * algorithms
 * Easy (82.39%)
 * Likes:    293
 * Dislikes: 0
 * Total Accepted:    78.6K
 * Total Submissions: 95.4K
 * Testcase Example:  '[1,4,2,5,3]'
 *
 * 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。
 *
 * 子数组 定义为原数组中的一个连续子序列。
 *
 * 请你返回 arr 中 所有奇数长度子数组的和 。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：arr = [1,4,2,5,3]
 * 输出：58
 * 解释：所有奇数长度子数组和它们的和为：
 * [1] = 1
 * [4] = 4
 * [2] = 2
 * [5] = 5
 * [3] = 3
 * [1,4,2] = 7
 * [4,2,5] = 11
 * [2,5,3] = 10
 * [1,4,2,5,3] = 15
 * 我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
 *
 * 示例 2：
 *
 *
 * 输入：arr = [1,2]
 * 输出：3
 * 解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。
 *
 * 示例 3：
 *
 *
 * 输入：arr = [10,11,12]
 * 输出：66
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= arr.length <= 100
 * 1 <= arr[i] <= 1000
 *
 *
 *
 *
 * 进阶：
 *
 * 你可以设计一个 O(n) 时间复杂度的算法解决此问题吗？
 *
 */

// @lc code=start

/**
 * 方法一：前缀和 + 暴力枚举（时间复杂度 O(n²)）
 * 思路：
 * 1. 先计算前缀和数组，方便快速计算任意子数组的和
 * 2. 枚举所有奇数长度的子数组，累加它们的和
 */
function sumOddLengthSubarrays_prefixSum(arr: number[]): number {
  const n = arr.length;
  // 前缀和数组：prefixSum[i] 表示 arr[0...i-1] 的和
  const prefixSum: number[] = Array(n + 1).fill(0);

  // 构建前缀和数组
  for (let i = 1; i <= n; i++) {
    prefixSum[i] = prefixSum[i - 1] + arr[i - 1];
  }

  let result = 0;

  // 枚举所有子数组的起始位置 i
  for (let i = 0; i < n; i++) {
    // 枚举奇数长度：1, 3, 5, 7...
    for (let len = 1; i + len <= n; len += 2) {
      // 利用前缀和快速计算 arr[i...i+len-1] 的和
      const sum = prefixSum[i + len] - prefixSum[i];
      result += sum;
    }
  }

  return result;
}

/**
 * 方法二：数学方法（时间复杂度 O(n)）- 最优解
 *
 * ═══════════════════════════════════════════════════════════════
 * 核心思想：计算每个元素在所有奇数长度子数组中出现的次数
 * ═══════════════════════════════════════════════════════════════
 *
 * 【问题转换】
 * 原问题：计算所有奇数长度子数组的和
 * 转换后：计算每个元素的贡献 = 元素值 × 该元素出现在奇数长度子数组中的次数
 *
 * ═══════════════════════════════════════════════════════════════
 * 【详细图解示例】arr = [1, 4, 2, 5, 3]
 * ═══════════════════════════════════════════════════════════════
 *
 * 索引：         0  1  2  3  4
 * 元素：        [1, 4, 2, 5, 3]
 *
 * ───────────────────────────────────────────────────────────────
 * 步骤1：以 arr[2] = 2 为例，找出包含它的所有奇数长度子数组
 * ───────────────────────────────────────────────────────────────
 *
 *     左边部分    当前元素   右边部分
 *     ─────────    ───     ─────────
 *     [1, 4]        2       [5, 3]
 *      ↑  ↑        ↑        ↑  ↑
 *     索引0,1     索引2    索引3,4
 *
 * 【重要】当前元素（索引2的元素2）一定在子数组中！
 * 我们要计算的是：左边选几个 + 当前元素 + 右边选几个
 *
 * 左边可选择的元素（不包括当前元素）：
 *   索引2左边有：索引0的1、索引1的4
 *
 *   - 选 0 个：[]          → 子数组从当前元素开始 [2...]
 *   - 选 1 个：[4]         → 子数组从索引1开始 [4,2...]
 *   - 选 2 个：[1,4]       → 子数组从索引0开始 [1,4,2...]
 *
 *   共 3 种选择（leftCount = i + 1 = 2 + 1 = 3）
 *
 * 右边可选择的元素（不包括当前元素）：
 *   索引2右边有：索引3的5、索引4的3
 *
 *   - 选 0 个：[]          → 子数组到当前元素结束 [...2]
 *   - 选 1 个：[5]         → 子数组到索引3结束 [...2,5]
 *   - 选 2 个：[5,3]       → 子数组到索引4结束 [...2,5,3]
 *
 *   共 3 种选择（rightCount = n - i = 5 - 2 = 3）
 *
 * 所有可能的组合（3×3=9种）：
 *   左0右0: [2]
 *   左0右1: [2,5]
 *   左0右2: [2,5,3]         ← 奇数长度 ✓
 *   左1右0: [4,2]
 *   左1右1: [4,2,5]         ← 奇数长度 ✓
 *   左1右2: [4,2,5,3]
 *   左2右0: [1,4,2]         ← 奇数长度 ✓
 *   左2右1: [1,4,2,5]
 *   左2右2: [1,4,2,5,3]     ← 奇数长度 ✓
 *
 * 但我们只需要奇数长度的！
 *
 * ───────────────────────────────────────────────────────────────
 * 步骤2：如何保证子数组长度是奇数？
 * ───────────────────────────────────────────────────────────────
 *
 * 子数组长度 = 左边选的个数 + 1（当前元素） + 右边选的个数
 *            = left + 1 + right
 *
 * 要让长度为奇数，必须满足：left + 1 + right 是奇数
 * 因为 1 是奇数，所以需要：left + right 是偶数
 *
 * left + right 为偶数的两种情况：
 *   ① left 是偶数 AND right 是偶数  （偶 + 偶 = 偶）
 *   ② left 是奇数 AND right 是奇数  （奇 + 奇 = 偶）
 *
 * ───────────────────────────────────────────────────────────────
 * 步骤3：计算左右两边奇数和偶数的选择方案数
 * ───────────────────────────────────────────────────────────────
 *
 * 左边（leftCount = 3，可选0、1、2个元素）：
 *   选择范围：[0, 1, 2]
 *   - 偶数选择：0、2 → leftEven = 2 种
 *   - 奇数选择：1    → leftOdd = 1 种
 *
 * 右边（rightCount = 3，可选0、1、2个元素）：
 *   选择范围：[0, 1, 2]
 *   - 偶数选择：0、2 → rightEven = 2 种
 *   - 奇数选择：1    → rightOdd = 1 种
 *
 * 【关键公式】在 0 到 n-1 的范围内（共 n 个数）：
 *   - 偶数个数 = Math.ceil(n / 2)   （向上取整）
 *   - 奇数个数 = Math.floor(n / 2)  （向下取整）
 *
 * 验证：
 *   leftCount = 3，范围 [0, 1, 2]
 *     leftEven = Math.ceil(3/2) = 2 ✓（0和2）
 *     leftOdd = Math.floor(3/2) = 1 ✓（1）
 *
 *   leftCount = 4，范围 [0, 1, 2, 3]
 *     leftEven = Math.ceil(4/2) = 2 ✓（0和2）
 *     leftOdd = Math.floor(4/2) = 2 ✓（1和3）
 *
 * ───────────────────────────────────────────────────────────────
 * 步骤4：计算奇数长度子数组的数量
 * ───────────────────────────────────────────────────────────────
 *
 * 奇数长度子数组数 = leftEven × rightEven + leftOdd × rightOdd
 *                 = 2 × 2 + 1 × 1
 *                 = 4 + 1
 *                 = 5
 *
 * ───────────────────────────────────────────────────────────────
 * 步骤5：列举验证（包含 arr[2]=2 的所有奇数长度子数组）
 * ───────────────────────────────────────────────────────────────
 *
 * 从上面的9种组合中筛选出奇数长度的：
 *
 * 1. [2]         = 0个左边 + [2] + 0个右边
 *                长度 = 0 + 1 + 0 = 1（奇数）✓ 因为 0+0=偶数
 *
 * 2. [2,5,3]     = 0个左边 + [2] + 2个右边[5,3]
 *                长度 = 0 + 1 + 2 = 3（奇数）✓ 因为 0+2=偶数
 *
 * 3. [4,2,5]     = 1个左边[4] + [2] + 1个右边[5]
 *                长度 = 1 + 1 + 1 = 3（奇数）✓ 因为 1+1=偶数
 *
 * 4. [1,4,2]     = 2个左边[1,4] + [2] + 0个右边
 *                长度 = 2 + 1 + 0 = 3（奇数）✓ 因为 2+0=偶数
 *
 * 5. [1,4,2,5,3] = 2个左边[1,4] + [2] + 2个右边[5,3]
 *                长度 = 2 + 1 + 2 = 5（奇数）✓ 因为 2+2=偶数
 *
 * 共 5 个！与计算结果 leftEven×rightEven + leftOdd×rightOdd = 2×2 + 1×1 = 5 一致 ✓
 *
 * 【总结规律】
 * 要得到奇数长度：(左边个数 + 右边个数) 必须是偶数
 * - 左偶右偶：如上面的 1,2,4,5
 * - 左奇右奇：如上面的 3
 *
 * ───────────────────────────────────────────────────────────────
 * 步骤6：计算元素贡献
 * ───────────────────────────────────────────────────────────────
 *
 * arr[2] = 2 出现在 5 个奇数长度子数组中
 * 贡献 = 2 × 5 = 10
 *
 * ═══════════════════════════════════════════════════════════════
 * 【完整示例】arr = [1, 4, 2, 5, 3]，计算所有元素的贡献
 * ═══════════════════════════════════════════════════════════════
 *
 * i=0, arr[0]=1: leftCount=1, rightCount=5
 *   leftEven=1, leftOdd=0, rightEven=3, rightOdd=2
 *   次数 = 1×3 + 0×2 = 3
 *   贡献 = 1 × 3 = 3
 *   包含的奇数长度子数组：[1], [1,4,2], [1,4,2,5,3]
 *
 * i=1, arr[1]=4: leftCount=2, rightCount=4
 *   leftEven=1, leftOdd=1, rightEven=2, rightOdd=2
 *   次数 = 1×2 + 1×2 = 4
 *   贡献 = 4 × 4 = 16
 *   包含的奇数长度子数组：[4], [1,4,2], [4,2,5], [1,4,2,5,3]
 *
 * i=2, arr[2]=2: leftCount=3, rightCount=3
 *   leftEven=2, leftOdd=1, rightEven=2, rightOdd=1
 *   次数 = 2×2 + 1×1 = 5
 *   贡献 = 2 × 5 = 10
 *   包含的奇数长度子数组：[2], [1,4,2], [4,2,5], [2,5,3], [1,4,2,5,3]
 *
 * i=3, arr[3]=5: leftCount=4, rightCount=2
 *   leftEven=2, leftOdd=2, rightEven=1, rightOdd=1
 *   次数 = 2×1 + 2×1 = 4
 *   贡献 = 5 × 4 = 20
 *   包含的奇数长度子数组：[5], [4,2,5], [2,5,3], [1,4,2,5,3]
 *
 * i=4, arr[4]=3: leftCount=5, rightCount=1
 *   leftEven=3, leftOdd=2, rightEven=1, rightOdd=0
 *   次数 = 3×1 + 2×0 = 3
 *   贡献 = 3 × 3 = 9
 *   包含的奇数长度子数组：[3], [2,5,3], [1,4,2,5,3]
 *
 * 总和 = 3 + 16 + 10 + 20 + 9 = 58 ✓ 正确！
 */
function sumOddLengthSubarrays(arr: number[]): number {
  const n = arr.length;
  let result = 0;

  // 遍历每个元素，计算它在所有奇数长度子数组中出现的次数
  for (let i = 0; i < n; i++) {
    // 左边可选的位置数（包括不选）：0, 1, 2, ..., i
    // 例如：i=2 时，可以选 0 个（不选）、1 个（只选索引1）、2 个（选索引0和1）
    const leftCount = i + 1;

    // 右边可选的位置数（包括不选）：0, 1, 2, ..., n-i-1
    // 例如：i=2, n=5 时，可以选 0 个（不选）、1 个（只选索引3）、2 个（选索引3和4）
    const rightCount = n - i;

    // 【关键】计算奇数和偶数的选择方案数
    // leftCount = 3，范围 [0, 1, 2]，偶数有 0, 2（2个），奇数有 1（1个）
    // leftCount = 4，范围 [0, 1, 2, 3]，偶数有 0, 2（2个），奇数有 1, 3（2个）
    //
    // 规律：在 0 到 n-1 的范围内
    //   - 偶数个数 = Math.ceil(n / 2)  （向上取整）
    //   - 奇数个数 = Math.floor(n / 2) （向下取整）
    const leftEven = Math.ceil(leftCount / 2);
    const leftOdd = Math.floor(leftCount / 2);

    const rightEven = Math.ceil(rightCount / 2);
    const rightOdd = Math.floor(rightCount / 2);

    // 奇数长度子数组数 = (左偶 × 右偶) + (左奇 × 右奇)
    // 因为：left(偶数) + 1 + right(偶数) = 奇数
    //      left(奇数) + 1 + right(奇数) = 奇数
    const oddLengthCount = leftEven * rightEven + leftOdd * rightOdd;

    // 累加该元素的贡献
    result += arr[i] * oddLengthCount;
  }

  return result;
}
// @lc code=end
