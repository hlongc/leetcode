/*
 * @lc app=leetcode.cn id=974 lang=typescript
 *
 * [974] 和可被 K 整除的子数组
 *
 * https://leetcode.cn/problems/subarray-sums-divisible-by-k/description/
 *
 * algorithms
 * Medium (49.76%)
 * Likes:    559
 * Dislikes: 0
 * Total Accepted:    79.9K
 * Total Submissions: 160.3K
 * Testcase Example:  '[4,5,0,-2,-3,1]\n5'
 *
 * 给定一个整数数组 nums 和一个整数 k ，返回其中元素之和可被 k 整除的非空 子数组 的数目。
 *
 * 子数组 是数组中 连续 的部分。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [4,5,0,-2,-3,1], k = 5
 * 输出：7
 * 解释：
 * 有 7 个子数组满足其元素之和可被 k = 5 整除：
 * [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2,
 * -3]
 *
 *
 * 示例 2:
 *
 *
 * 输入: nums = [5], k = 9
 * 输出: 0
 *
 *
 *
 *
 * 提示:
 *
 *
 * 1 <= nums.length <= 3 * 10^4
 * -10^4 <= nums[i] <= 10^4
 * 2 <= k <= 10^4
 *
 *
 */

// @lc code=start

/**
 * 和可被K整除的子数组 - 前缀和 + 取模优化
 *
 * ═══════════════════════════════════════════════════════════════
 * 核心原理：同余定理 + 前缀和
 * ═══════════════════════════════════════════════════════════════
 *
 * 【问题分析】
 * 找出有多少个连续子数组，它们的和能被 k 整除
 *
 * 【数学原理】
 * 如果子数组 [i+1, j] 的和能被 k 整除，则：
 *   (prefixSum[j] - prefixSum[i]) % k === 0
 *
 * 根据同余定理：
 *   (a - b) % k === 0  ⟺  a % k === b % k
 *
 * 所以：
 *   prefixSum[j] % k === prefixSum[i] % k
 *
 * 结论：只要两个位置的前缀和对k取模结果相同，它们之间的子数组和就能被k整除！
 *
 * ═══════════════════════════════════════════════════════════════
 * 【具体例子】nums = [4, 5, 0, -2, -3, 1], k = 5
 * ═══════════════════════════════════════════════════════════════
 *
 * 索引:     0   1   2   3    4   5
 * 元素:    [4,  5,  0, -2,  -3,  1]
 * 前缀和:   4   9   9   7    4   5
 * 对5取模:  4   4   4   2    4   0
 *          ↑   ↑   ↑        ↑
 *          └───┴───┴────────┘
 *        这些位置的余数都是4！
 *
 * 【逐步模拟】
 *
 * 初始化：modCount = {0: 1}  ← 余数0出现1次（空数组）
 * count = 0
 *
 * ─────────────────────────────────────────────────────────────
 * i=0, nums[0]=4:
 * ─────────────────────────────────────────────────────────────
 * prefixSum = 4
 * mod = 4 % 5 = 4
 *
 * 查找：modCount中有余数4吗？没有
 * count = 0
 *
 * 更新：modCount = {0: 1, 4: 1}
 *
 * ─────────────────────────────────────────────────────────────
 * i=1, nums[1]=5:
 * ─────────────────────────────────────────────────────────────
 * prefixSum = 4 + 5 = 9
 * mod = 9 % 5 = 4
 *
 * 查找：modCount中有余数4吗？有！出现了1次
 *   这意味着从位置0+1到位置1的子数组 [5] 和能被5整除 ✓
 * count = 0 + 1 = 1
 *
 * 更新：modCount = {0: 1, 4: 2}  ← 余数4现在出现了2次
 *
 * ─────────────────────────────────────────────────────────────
 * i=2, nums[2]=0:
 * ─────────────────────────────────────────────────────────────
 * prefixSum = 9 + 0 = 9
 * mod = 9 % 5 = 4
 *
 * 查找：modCount中有余数4吗？有！出现了2次
 *   从位置0+1到位置2: [5, 0] ✓
 *   从位置1+1到位置2: [0] ✓
 * count = 1 + 2 = 3
 *
 * 更新：modCount = {0: 1, 4: 3}
 *
 * ─────────────────────────────────────────────────────────────
 * i=3, nums[3]=-2:
 * ─────────────────────────────────────────────────────────────
 * prefixSum = 9 + (-2) = 7
 * mod = 7 % 5 = 2
 *
 * 查找：modCount中有余数2吗？没有
 * count = 3
 *
 * 更新：modCount = {0: 1, 4: 3, 2: 1}
 *
 * ─────────────────────────────────────────────────────────────
 * i=4, nums[4]=-3:
 * ─────────────────────────────────────────────────────────────
 * prefixSum = 7 + (-3) = 4
 * mod = 4 % 5 = 4
 *
 * 查找：modCount中有余数4吗？有！出现了3次
 *   从位置0+1到位置4: [5, 0, -2, -3] ✓
 *   从位置1+1到位置4: [0, -2, -3] ✓
 *   从位置2+1到位置4: [-2, -3] ✓
 * count = 3 + 3 = 6
 *
 * 更新：modCount = {0: 1, 4: 4, 2: 1}
 *
 * ─────────────────────────────────────────────────────────────
 * i=5, nums[5]=1:
 * ─────────────────────────────────────────────────────────────
 * prefixSum = 4 + 1 = 5
 * mod = 5 % 5 = 0
 *
 * 查找：modCount中有余数0吗？有！出现了1次
 *   从开始到位置5: [4, 5, 0, -2, -3, 1] ✓
 * count = 6 + 1 = 7
 *
 * 最终答案：7 ✓
 *
 * ═══════════════════════════════════════════════════════════════
 * 【负数取模的处理】
 * ═══════════════════════════════════════════════════════════════
 *
 * JavaScript/TypeScript中，负数取模可能得到负数：
 *   -7 % 5 = -2  （而不是3）
 *
 * 但我们需要正的余数，所以要调整：
 *   mod = ((prefixSum % k) + k) % k
 *
 * 例如：
 *   prefixSum = -7, k = 5
 *   原始: -7 % 5 = -2
 *   调整: ((-7 % 5) + 5) % 5 = (-2 + 5) % 5 = 3 % 5 = 3 ✓
 *
 * 这样保证余数始终在 [0, k-1] 范围内
 *
 * ═══════════════════════════════════════════════════════════════
 * 【优化前后对比】
 * ═══════════════════════════════════════════════════════════════
 *
 * 优化前（你的代码）：
 *   - 对每个元素，遍历整个map检查 (currentSum - key) % k === 0
 *   - 时间复杂度：O(n²)  ❌ 超时
 *
 * 优化后（使用取模）：
 *   - 直接查找相同余数的前缀和
 *   - 时间复杂度：O(n)  ✓ 高效
 */
function subarraysDivByK(nums: number[], k: number): number {
  // 哈希表：key是前缀和对k的余数，value是该余数出现的次数
  const modCount = new Map<number, number>();

  // 初始化：余数0出现1次（表示空数组，前缀和为0）
  modCount.set(0, 1);

  let prefixSum = 0; // 当前前缀和
  let count = 0; // 可被k整除的子数组个数

  for (const num of nums) {
    // 更新前缀和
    prefixSum += num;

    // 计算当前前缀和对k的余数
    // 使用 ((prefixSum % k) + k) % k 处理负数情况
    // 确保余数在 [0, k-1] 范围内
    const mod = ((prefixSum % k) + k) % k;

    // 【关键】查找之前是否有相同余数的前缀和
    // 如果有，说明从那些位置到当前位置的子数组和能被k整除
    // 因为：两个前缀和余数相同 → 它们的差能被k整除
    if (modCount.has(mod)) {
      count += modCount.get(mod)!;
    }

    // 记录当前余数的出现次数
    modCount.set(mod, (modCount.get(mod) || 0) + 1);
  }

  return count;
}

/**
 * ═══════════════════════════════════════════════════════════════
 * 【复杂度分析】
 * ═══════════════════════════════════════════════════════════════
 *
 * 时间复杂度：O(n)
 * - 只遍历数组一次
 * - 哈希表的查找和插入都是 O(1)
 *
 * 空间复杂度：O(min(n, k))
 * - 余数最多有 k 种（0 到 k-1）
 * - 哈希表最多存储 min(n, k) 个键值对
 *
 * ═══════════════════════════════════════════════════════════════
 * 【总结】
 * ═══════════════════════════════════════════════════════════════
 *
 * 核心技巧：
 *   1. 用前缀和的差值表示子数组和
 *   2. 用取模运算判断能否被k整除
 *   3. 同余定理：余数相同的前缀和，它们的差能被k整除
 *   4. 哈希表记录每个余数出现的次数
 *   5. 处理负数取模，确保余数为正
 */
// @lc code=end
