/*
 * @lc app=leetcode.cn id=560 lang=typescript
 *
 * [560] 和为 K 的子数组
 *
 * https://leetcode.cn/problems/subarray-sum-equals-k/description/
 *
 * algorithms
 * Medium (45.50%)
 * Likes:    2898
 * Dislikes: 0
 * Total Accepted:    866.6K
 * Total Submissions: 1.9M
 * Testcase Example:  '[1,1,1]\n2'
 *
 * 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
 *
 * 子数组是数组中元素的连续非空序列。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,1,1], k = 2
 * 输出：2
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [1,2,3], k = 3
 * 输出：2
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 2 * 10^4
 * -1000 <= nums[i] <= 1000
 * -10^7 <= k <= 10^7
 *
 *
 */

// @lc code=start

/**
 * 和为K的子数组 - 前缀和 + 哈希表优化
 *
 * ═══════════════════════════════════════════════════════════════
 * 核心原理：前缀和的差值思想
 * ═══════════════════════════════════════════════════════════════
 *
 * 【问题分析】
 * 给定数组 nums 和目标值 k，找出有多少个连续子数组的和等于 k
 *
 * 【前缀和定义】
 * prefixSum[i] = nums[0] + nums[1] + ... + nums[i-1]
 * 表示从索引0到索引i-1的所有元素之和
 *
 * 【关键洞察】
 * 如果我们知道：
 * - prefixSum[j] = 从索引0到j-1的和
 * - prefixSum[i] = 从索引0到i-1的和（i < j）
 *
 * 那么：从索引i到j-1的子数组和 = prefixSum[j] - prefixSum[i]
 *
 * 如果这个子数组和等于k，则：
 *   prefixSum[j] - prefixSum[i] = k
 *   推导出：prefixSum[i] = prefixSum[j] - k
 *
 * 所以，当我们遍历到位置j时，只需要找之前有多少个位置i满足：
 *   prefixSum[i] = currentPrefixSum - k
 *
 * ═══════════════════════════════════════════════════════════════
 * 【具体例子】nums = [1, 2, 3, -2, 1], k = 3
 * ═══════════════════════════════════════════════════════════════
 *
 * 索引:  0   1   2   3   4
 * 元素: [1,  2,  3, -2,  1]
 *
 * 前缀和（从头开始累加）：
 *   位置 -1: prefixSum = 0  （初始状态，表示空数组）
 *   位置  0: prefixSum = 1  （0 + 1）
 *   位置  1: prefixSum = 3  （1 + 2）
 *   位置  2: prefixSum = 6  （3 + 3）
 *   位置  3: prefixSum = 4  （6 - 2）
 *   位置  4: prefixSum = 5  （4 + 1）
 *
 * ───────────────────────────────────────────────────────────────
 * 【逐步模拟】k = 3
 * ───────────────────────────────────────────────────────────────
 *
 * 初始化：
 * prefixSumCount = {0: 1}  ← 前缀和0出现1次（表示空数组）
 * count = 0
 *
 * ─────────────────────────────────────────────────────────────
 * 遍历 i=0, nums[0]=1:
 * ─────────────────────────────────────────────────────────────
 * currentPrefixSum = 0 + 1 = 1
 *
 * 寻找：有没有前缀和为 (1 - 3) = -2 的位置？
 *   没有！所以 count 不变
 *
 * 记录：prefixSumCount = {0: 1, 1: 1}
 * count = 0
 *
 * ─────────────────────────────────────────────────────────────
 * 遍历 i=1, nums[1]=2:
 * ─────────────────────────────────────────────────────────────
 * currentPrefixSum = 1 + 2 = 3
 *
 * 寻找：有没有前缀和为 (3 - 3) = 0 的位置？
 *   有！prefixSumCount[0] = 1
 *   这意味着：从位置-1之后（即从索引0开始）到当前位置的子数组和为k
 *   子数组：[1, 2]，和 = 3 ✓
 *
 * count += 1  →  count = 1
 *
 * 记录：prefixSumCount = {0: 1, 1: 1, 3: 1}
 *
 * ─────────────────────────────────────────────────────────────
 * 遍历 i=2, nums[2]=3:
 * ─────────────────────────────────────────────────────────────
 * currentPrefixSum = 3 + 3 = 6
 *
 * 寻找：有没有前缀和为 (6 - 3) = 3 的位置？
 *   有！prefixSumCount[3] = 1（这是在位置1记录的）
 *   这意味着：从位置1之后（即从索引2开始）到当前位置的子数组和为k
 *   子数组：[3]，和 = 3 ✓
 *
 * count += 1  →  count = 2
 *
 * 记录：prefixSumCount = {0: 1, 1: 1, 3: 1, 6: 1}
 *
 * ─────────────────────────────────────────────────────────────
 * 遍历 i=3, nums[3]=-2:
 * ─────────────────────────────────────────────────────────────
 * currentPrefixSum = 6 + (-2) = 4
 *
 * 寻找：有没有前缀和为 (4 - 3) = 1 的位置？
 *   有！prefixSumCount[1] = 1（这是在位置0记录的）
 *   这意味着：从位置0之后（即从索引1开始）到当前位置的子数组和为k
 *   子数组：[2, 3, -2]，和 = 2+3-2 = 3 ✓
 *
 * count += 1  →  count = 3
 *
 * 记录：prefixSumCount = {0: 1, 1: 1, 3: 1, 6: 1, 4: 1}
 *
 * ─────────────────────────────────────────────────────────────
 * 遍历 i=4, nums[4]=1:
 * ─────────────────────────────────────────────────────────────
 * currentPrefixSum = 4 + 1 = 5
 *
 * 寻找：有没有前缀和为 (5 - 3) = 2 的位置？
 *   没有！所以 count 不变
 *
 * 记录：prefixSumCount = {0: 1, 1: 1, 3: 1, 6: 1, 4: 1, 5: 1}
 * count = 3
 *
 * ═══════════════════════════════════════════════════════════════
 * 【为什么要记录前缀和的出现次数？】
 * ═══════════════════════════════════════════════════════════════
 *
 * 例子：nums = [1, -1, 1, -1, 1], k = 0
 *
 * 前缀和序列：0 → 1 → 0 → 1 → 0 → 1
 *
 * 当遍历到最后一个元素，currentPrefixSum = 1，需要找 1-0=1
 * 前缀和1出现了3次（在位置0、2、4），所以有3个子数组：
 *   - 从位置0+1到位置5: [-1, 1, -1, 1] = 0 ✓
 *   - 从位置2+1到位置5: [1, -1, 1] = 0 ✗ 不对，应该是[-1,1]
 *
 * 让我重新算：
 * i=0: sum=1, 找sum=1，没有，记录{0:1, 1:1}
 * i=1: sum=0, 找sum=0，有1个，count=1 ([1,-1])，记录{0:2, 1:1}
 * i=2: sum=1, 找sum=1，有1个，count=2 ([-1,1])，记录{0:2, 1:2}
 * i=3: sum=0, 找sum=0，有2个，count=4，记录{0:3, 1:2}
 *   这2个对应：[1,-1,1,-1] 和 [-1,1,-1]
 * i=4: sum=1, 找sum=1，有2个，count=6，记录{0:3, 1:3}
 *   这2个对应：[-1,1,-1,1] 和 [1,-1,1]
 *
 * 所以需要记录每个前缀和出现的次数！
 *
 * ═══════════════════════════════════════════════════════════════
 * 【为什么初始化 prefixSumCount.set(0, 1)？】
 * ═══════════════════════════════════════════════════════════════
 *
 * 这表示"空数组"的前缀和为0，出现了1次
 * 这样可以处理"从数组开头到某个位置"的子数组
 *
 * 例如：nums = [3], k = 3
 * 当遍历到索引0，currentPrefixSum = 3
 * 寻找：prefixSum = 3 - 3 = 0
 * 因为初始化了{0: 1}，所以能找到，count = 1
 * 表示子数组[3]的和为k ✓
 */
function subarraySum(nums: number[], k: number): number {
  // 哈希表：key是前缀和，value是该前缀和出现的次数
  const prefixSumCount = new Map<number, number>();

  // 初始化：前缀和为0出现1次（表示空数组，用于处理从头开始的子数组）
  prefixSumCount.set(0, 1);

  let currentPrefixSum = 0; // 当前位置的前缀和
  let count = 0; // 和为k的子数组个数

  // 遍历数组
  for (const num of nums) {
    // 更新当前前缀和：从数组开头到当前位置的累加和
    currentPrefixSum += num;

    // 【关键】计算目标前缀和
    // 如果之前存在某个位置的前缀和为 targetPrefixSum，
    // 那么从那个位置的下一个位置到当前位置的子数组和就是k
    //
    // 因为：currentPrefixSum - targetPrefixSum = k
    // 所以：targetPrefixSum = currentPrefixSum - k
    const targetPrefixSum = currentPrefixSum - k;

    // 如果目标前缀和存在，说明找到了若干个和为k的子数组
    // 加上该前缀和出现的次数（因为每次出现都对应一个有效的子数组）
    if (prefixSumCount.has(targetPrefixSum)) {
      count += prefixSumCount.get(targetPrefixSum)!;
    }

    // 将当前前缀和加入哈希表
    // 如果该前缀和已存在，则次数+1；否则设为1
    prefixSumCount.set(
      currentPrefixSum,
      (prefixSumCount.get(currentPrefixSum) || 0) + 1
    );
  }

  return count;
}

/**
 * ═══════════════════════════════════════════════════════════════
 * 【复杂度分析】
 * ═══════════════════════════════════════════════════════════════
 *
 * 时间复杂度：O(n)
 * - 只需要遍历数组一次
 * - 哈希表的查找和插入都是 O(1)
 *
 * 空间复杂度：O(n)
 * - 最坏情况下，所有前缀和都不相同，哈希表存储n个键值对
 *
 * ═══════════════════════════════════════════════════════════════
 * 【总结】
 * ═══════════════════════════════════════════════════════════════
 *
 * 核心公式：
 *   如果 prefixSum[j] - prefixSum[i] = k
 *   那么 prefixSum[i] = prefixSum[j] - k
 *
 * 算法思路：
 *   1. 边遍历边计算前缀和
 *   2. 对于每个位置，查找之前是否存在前缀和为 (当前前缀和 - k)
 *   3. 用哈希表记录每个前缀和出现的次数，实现 O(1) 查找
 */
// @lc code=end
