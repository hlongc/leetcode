# Git 钩子中实现终端交互的挑战与解决方案

## 问题背景

在开发 Git pre-commit 钩子脚本时，我们尝试使用 Inquirer 等交互式库来实现用户选择功能，但在实际运行中遇到了一系列挑战。这些挑战主要源于 Git 钩子的特殊执行环境与普通终端环境的差异。

## 为什么 Git 钩子中无法直接使用 Inquirer？

### 1. 标准输入重定向问题

Git 钩子运行时，标准输入（stdin）被重定向，不再直接连接到终端设备：

- `process.stdin.isTTY` 在钩子中为 `false`（而在正常终端中为 `true`）
- Inquirer 等交互式库依赖于 TTY 功能来显示提示和捕获用户输入
- 当检测到非 TTY 环境时，Inquirer 会抛出 `ExitPromptError: User force closed the prompt`

### 2. Git 钩子的特殊执行环境

Git 钩子在特殊的环境中执行：

- 它们不是在完整的交互式 shell 会话中运行的
- 它们通常在后台执行，没有直接的用户界面
- Git 可能会以不同的方式处理标准输入/输出流

### 3. 信号处理差异

Git 钩子中的信号处理与普通终端环境不同：

- `signal-exit` 包（Inquirer 的依赖）可能无法正确处理信号
- 这导致了我们看到的 `ExitPromptError` 错误

## 尝试过的解决方案

我们尝试了多种方法来解决这个问题：

| 解决方案               | 效果     | 问题                   |
| ---------------------- | -------- | ---------------------- |
| 直接使用 Inquirer      | 失败     | 抛出 ExitPromptError   |
| 使用 bash 命令读取输入 | 失败     | 命令执行卡住           |
| 连接到 /dev/tty        | 部分成功 | 需要正确管理文件描述符 |
| 非交互式方法           | 成功     | 失去了交互体验         |

## 最终解决方案

我们最终实现了一个混合解决方案，结合了以下技术：

### 1. 直接连接到 /dev/tty

```javascript
// 尝试打开 /dev/tty 作为输入
ttyFd = fs.openSync("/dev/tty", "r+");
if (ttyFd) {
  // 创建专用的输入输出流
  inputStream = fs.createReadStream("", { fd: ttyFd });
  outputStream = fs.createWriteStream("", { fd: ttyFd });
}
```

这种方法绕过了 Git 对标准输入的重定向，直接连接到控制终端。

### 2. 使用 Node.js 内置的 readline 模块

我们放弃了 Inquirer，转而使用更底层的 readline 模块：

```javascript
const rl = readline.createInterface({
  input: inputStream,
  output: outputStream,
  terminal: true,
});

rl.question("输入选项 (0-3): ", (answer) => {
  // 处理用户输入
});
```

### 3. 资源管理和错误处理

为了避免资源泄漏和程序挂起：

```javascript
// 设置超时
const timeout = setTimeout(() => {
  rl.close();
  resolve("none");
}, 30000);

// 确保资源清理
function cleanupResources() {
  if (ttyFd !== null) {
    fs.closeSync(ttyFd);
    ttyFd = null;
  }
}

// 在所有可能的退出点调用
process.on("exit", cleanupResources);
```

### 4. 优雅降级机制

当交互式方法失败时，提供备选方案：

```javascript
try {
  upgradeType = await getInteractiveChoiceWithReadline();
} catch (err) {
  // 如果交互方式失败，使用环境变量或默认值
  upgradeType = process.env.VERSION_UPGRADE || "none";
}
```

## 最佳实践总结

在 Git 钩子中实现用户交互的最佳实践：

1. **优先使用非交互式方法**：

   - 使用命令行参数（如 `--upgrade=major`）
   - 使用环境变量（如 `VERSION_UPGRADE=major`）
   - 使用配置文件保存默认选项

2. **如果必须使用交互式方法**：

   - 直接连接到 `/dev/tty` 而不是使用标准输入
   - 使用底层的 Node.js readline 模块而不是高级库
   - 确保正确管理文件描述符（打开和关闭）
   - 添加超时机制，防止程序挂起

3. **提供优雅降级**：
   - 当交互失败时，回退到非交互式方法
   - 提供清晰的错误消息和使用说明

## 技术细节

### 关键代码：连接到终端

```javascript
ttyFd = fs.openSync("/dev/tty", "r+");
inputStream = fs.createReadStream("", { fd: ttyFd });
outputStream = fs.createWriteStream("", { fd: ttyFd });
```

### 关键代码：资源清理

```javascript
function cleanupResources() {
  if (ttyFd !== null) {
    fs.closeSync(ttyFd);
    ttyFd = null;
  }
}
```

## 结论

Git 钩子中实现交互式提示是可能的，但需要绕过标准输入/输出流的限制，直接连接到终端设备。即使这样，也需要小心管理资源和处理各种边缘情况。

我们的解决方案成功地在 Git 钩子环境中实现了交互式选择功能，同时保持了代码的健壮性和可靠性。这种方法可以应用于其他需要在非标准终端环境中进行用户交互的场景。
