# JavaScript 原型链详解

## 一、核心概念

### 1. 原型（Prototype）
每个 JavaScript 对象都有一个原型。原型本身也是一个对象，可以有自己的原型，形成**原型链**。

```javascript
// 所有对象都有 __proto__ 属性指向它的原型
const obj = {};
console.log(obj.__proto__); // Object.prototype
```

### 2. 原型链的三个关键属性

#### `__proto__`（隐式原型）
- 每个对象都有 `__proto__` 属性
- 指向该对象的构造函数的 `prototype`
- 用于查找属性时沿着原型链向上查找

#### `prototype`（显式原型）
- 只有函数才有 `prototype` 属性
- 当函数作为构造函数时，新创建的对象的 `__proto__` 会指向这个 `prototype`

#### `constructor`（构造函数）
- `prototype` 对象有 `constructor` 属性指回构造函数

```javascript
function Person(name) {
  this.name = name;
}

const p = new Person('张三');

console.log(p.__proto__ === Person.prototype);        // true
console.log(Person.prototype.constructor === Person); // true
console.log(p.constructor === Person);                // true
```

### 3. 原型链查找规则

当访问对象的属性时，JavaScript 会按照以下顺序查找：
1. 对象自身的属性
2. 对象的 `__proto__`（即构造函数的 `prototype`）
3. `prototype` 的 `__proto__`
4. 一直向上查找，直到 `Object.prototype`
5. 如果 `Object.prototype` 也没有，返回 `undefined`

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(this.name + ' is eating');
};

const dog = new Animal('Dog');
dog.eat(); // 先找 dog 自身，没有；再找 dog.__proto__，有！执行

console.log(dog.hasOwnProperty('eat'));           // false（eat 在原型上）
console.log(dog.hasOwnProperty('name'));          // true（name 在自身）
```

---

## 二、原型继承

### 原型链继承

```javascript
function Animal(name) {
  this.name = name;
}

Animal.prototype.eat = function() {
  console.log(this.name + ' is eating');
};

function Dog(name, breed) {
  // 继承属性
  Animal.call(this, name);
  this.breed = breed;
}

// 继承方法：将 Dog.prototype 的 __proto__ 指向 Animal.prototype
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function() {
  console.log(this.name + ' is barking');
};

const dog = new Dog('旺财', '拉布拉多');
dog.eat();  // 旺财 is eating
dog.bark(); // 旺财 is barking
```

### 关键点总结

```javascript
// 原型链的形成
dog --__proto__--> Dog.prototype --__proto__--> Animal.prototype --__proto__--> Object.prototype --__proto__--> null

// 检查原型链关系
console.log(dog instanceof Dog);     // true
console.log(dog instanceof Animal);  // true
console.log(dog instanceof Object);  // true
```

---

## 三、经典问题详解

### 问题 1：属性查找顺序

```javascript
const obj = { a: 1 };
obj.__proto__.b = 2;
Object.prototype.c = 3;

console.log(obj.a); // 1 (自身属性)
console.log(obj.b); // 2 (原型属性)
console.log(obj.c); // 3 (Object.prototype)
console.log(obj.d); // undefined (不存在)
```

### 问题 2：this 的指向

在原型链中，`this` 永远指向**调用方法的对象本身**，而不是方法所在的原型。

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  console.log('Hello, I am ' + this.name);
};

const p1 = new Person('Alice');
const p2 = new Person('Bob');

p1.greet(); // Hello, I am Alice (this 指向 p1)
p2.greet(); // Hello, I am Bob   (this 指向 p2)

// this 指向的是调用对象，不是方法定义的位置
const greet = p1.greet;
greet();    // Hello, I am undefined (this 指向全局，严格模式下报错)
```

### 问题 3：污染原型链

```javascript
// ❌ 不要这样做
Object.prototype.customMethod = function() {};

// 这会影响所有对象
const obj = {};
for (let key in obj) {
  console.log(key); // customMethod 也会被遍历
}

// ✅ 应该这样检查
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key); // 只遍历自身属性
  }
}
```

### 问题 4：修改原型的影响

```javascript
function Circle(radius) {
  this.radius = radius;
}

const c1 = new Circle(5);
Circle.prototype.getArea = function() {
  return Math.PI * this.radius ** 2;
};

const c2 = new Circle(10);

// c1 和 c2 都可以访问 getArea，因为都是从 Circle.prototype 查找
console.log(c1.getArea()); // 78.53981633974483
console.log(c2.getArea()); // 314.1592653589793

// 修改原型会影响所有实例
Circle.prototype.getArea = function() {
  return this.radius * this.radius;
};

console.log(c1.getArea()); // 25 (原型被修改了)
```

---

## 四、练习题

### 题目 1：理解 `__proto__` 和 `prototype`

```javascript
function Foo() {}
const f = new Foo();

// 判断以下表述的真假
console.log(f.__proto__ === Foo.prototype);           // ?
console.log(f.__proto__ === Foo.__proto__);           // ?
console.log(Foo.__proto__ === Function.prototype);    // ?
console.log(Foo.prototype.__proto__ === Object.prototype); // ?
```

**答案：**
```javascript
console.log(f.__proto__ === Foo.prototype);           // true
console.log(f.__proto__ === Foo.__proto__);           // false (f是实例，Foo是函数)
console.log(Foo.__proto__ === Function.prototype);    // true (Foo是Function的实例)
console.log(Foo.prototype.__proto__ === Object.prototype); // true
```

---

### 题目 2：手写 instanceof

```javascript
// instanceof 检查对象是否在另一个对象的原型链上

function myInstanceof(obj, constructor) {
  // 思路：沿着 obj 的原型链向上查找，看是否能找到 constructor.prototype
  let proto = Object.getPrototypeOf(obj);
  
  while (proto !== null) {
    if (proto === constructor.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  
  return false;
}

function Animal() {}
function Dog() {}
Dog.prototype = Object.create(Animal.prototype);

const dog = new Dog();
console.log(myInstanceof(dog, Dog));    // true
console.log(myInstanceof(dog, Animal)); // true
console.log(myInstanceof(dog, Object)); // true
console.log(myInstanceof(dog, Array));  // false
```

---

### 题目 3：原型链继承的坑

```javascript
function Parent() {
  this.arr = [1, 2, 3];
}

function Child() {}
Child.prototype = new Parent(); // ❌ 问题：所有实例共享 arr

const c1 = new Child();
const c2 = new Child();

c1.arr.push(4);
console.log(c1.arr); // [1, 2, 3, 4]
console.log(c2.arr); // [1, 2, 3, 4] ❌ 被污染了！

// ✅ 正确做法：使用 Object.create()
function Parent2() {
  this.arr = [1, 2, 3];
}

function Child2() {
  Parent2.call(this); // 继承属性
}
Child2.prototype = Object.create(Parent2.prototype);
Child2.prototype.constructor = Child2;

const c3 = new Child2();
const c4 = new Child2();

c3.arr.push(4);
console.log(c3.arr); // [1, 2, 3, 4]
console.log(c4.arr); // [1, 2, 3] ✅ 不被污染
```

---

### 题目 4：对象属性查找

```javascript
const Parent = {
  name: 'parent',
  greet() {
    return `Hello, I am ${this.name}`;
  }
};

const Child = Object.create(Parent);
Child.name = 'child';

console.log(Child.name);    // ?
console.log(Child.greet()); // ?
console.log(Object.keys(Child)); // ?
console.log(Object.keys(Parent)); // ?
```

**答案：**
```javascript
console.log(Child.name);    // 'child' (自身属性)
console.log(Child.greet()); // 'Hello, I am child' (this 指向 Child)
console.log(Object.keys(Child)); // ['name'] (只有自身可枚举属性)
console.log(Object.keys(Parent)); // ['name', 'greet']
```

---

### 题目 5：原型污染防护

```javascript
// 场景：你有一个对象，需要遍历它，但要避免遍历原型链上的属性

const obj = { a: 1, b: 2 };
Object.prototype.polluted = '污染';

// ❌ 错误做法
for (let key in obj) {
  console.log(key); // a, b, polluted
}

// ✅ 正确做法 1：使用 hasOwnProperty
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log(key); // a, b
  }
}

// ✅ 正确做法 2：使用 Object.keys()
Object.keys(obj).forEach(key => {
  console.log(key); // a, b
});

// ✅ 正确做法 3：使用 Object.getOwnPropertyNames()
Object.getOwnPropertyNames(obj).forEach(key => {
  console.log(key); // a, b
});
```

---

### 题目 6：综合题 - 实现一个简单的类继承

```javascript
// 需求：实现 Shape（形状）和 Circle（圆形）的继承关系

function Shape(color) {
  this.color = color;
}

Shape.prototype.getColor = function() {
  return this.color;
};

function Circle(color, radius) {
  // 1. 调用父构造函数
  Shape.call(this, color);
  this.radius = radius;
}

// 2. 设置原型链
Circle.prototype = Object.create(Shape.prototype);
Circle.prototype.constructor = Circle;

// 3. 添加子类方法
Circle.prototype.getArea = function() {
  return Math.PI * this.radius ** 2;
};

// 测试
const circle = new Circle('red', 5);
console.log(circle.getColor());         // 'red'
console.log(circle.getArea());          // 78.53981...
console.log(circle instanceof Circle);  // true
console.log(circle instanceof Shape);   // true
console.log(circle instanceof Object);  // true
```

**验证原型链：**
```javascript
circle
  ↓ __proto__
Circle.prototype
  ↓ __proto__
Shape.prototype
  ↓ __proto__
Object.prototype
  ↓ __proto__
null
```

---

## 五、常用方法速查表

| 方法 | 作用 | 返回值 |
|------|------|--------|
| `Object.create(proto)` | 创建新对象，指定其原型 | 新对象 |
| `Object.getPrototypeOf(obj)` | 获取对象的原型 | 原型对象 |
| `Object.setPrototypeOf(obj, proto)` | 设置对象的原型 | 该对象 |
| `obj.hasOwnProperty(prop)` | 检查是否是自身属性 | boolean |
| `prop in obj` | 检查属性是否存在（包括原型链） | boolean |
| `Object.keys(obj)` | 获取自身的可枚举属性 | 数组 |
| `Object.getOwnPropertyNames(obj)` | 获取自身的所有属性 | 数组 |

---

## 六、总结

1. **原型链是 JavaScript 实现继承的基础**
2. **每个对象都有 `__proto__`，每个函数都有 `prototype`**
3. **属性查找遵循从自身到原型链顶端的规则**
4. **`this` 始终指向调用方法的对象**
5. **使用 `Object.create()` 实现安全的原型继承**
6. **避免直接修改 `Object.prototype`，防止原型污染**