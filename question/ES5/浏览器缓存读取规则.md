# 浏览器缓存读取规则详解

浏览器缓存是前端性能优化的重要手段，能够减少网络请求，提高页面加载速度，改善用户体验。浏览器缓存机制主要由四个部分组成，按照查找优先级排列为：Service Worker、Memory Cache、Disk Cache 和 Push Cache。

## 一、浏览器缓存层级

### 1. Service Worker

Service Worker 是运行在浏览器背后的独立线程，可以用来实现缓存功能。它充当 web 应用程序与浏览器之间的代理服务器，也可以在离线环境下工作。

- **特点**：
  - 可编程控制缓存
  - 支持离线缓存
  - 网络请求拦截与处理
  - 生命周期独立于网页
- **适用场景**：
  - PWA (Progressive Web App) 应用
  - 需要精细化控制缓存策略的场景
  - 需要离线访问能力的应用

### 2. Memory Cache (内存缓存)

Memory Cache 是内存中的缓存，速度最快，但容量有限且持续时间短，通常在会话期间有效。

- **特点**：

  - 读取速度极快
  - 容量小，受系统内存限制
  - 随浏览器关闭而清空
  - 缓存内容不会写入硬盘

- **常见缓存内容**：

  - 页面中已经访问过的图片资源
  - 体积较小的 JS、CSS 文件
  - Base64 编码的图片
  - 最近使用过的资源
  - **预加载资源**：通过预加载指令获取的资源通常优先存入内存缓存

- **预加载机制与内存缓存**：
  - 预加载指令（如`<link rel="prefetch">`、`<link rel="preload">`）下载的资源是内存缓存的重要组成部分
  - 这些指令允许开发者提示浏览器提前获取可能需要的资源，以提高性能
  - 不同预加载指令的特点：
    - `preload`：高优先级加载，用于当前页面必需的资源，几乎总是存储在内存缓存中
    - `prefetch`：低优先级加载，用于未来可能需要的资源，通常也首先存入内存缓存
    - `preconnect`：提前建立连接，不涉及资源下载
    - `dns-prefetch`：提前进行 DNS 解析，不涉及资源下载
  - 预加载资源存入内存缓存的原因：
    - 访问速度最快，符合预加载提升性能的目的
    - 这些资源预期会在当前会话中很快被使用
    - 特别是`preload`的资源，被视为高优先级，需要立即可用

### 3. Disk Cache (硬盘缓存)

Disk Cache 是存储在硬盘上的缓存，容量大且持久化存储，但读取速度较慢。

- **特点**：

  - 容量大，受硬盘空间限制
  - 存储持久，关闭浏览器后仍然存在
  - 读取速度相对较慢
  - 跨会话有效

- **常见缓存内容**：
  - 大文件资源（大型 JS、CSS 文件）
  - 使用频率较低的资源
  - 需要长时间保存的资源
  - 非 Base64 格式的图片文件

### 4. Push Cache (推送缓存)

Push Cache 是 HTTP/2 中的新概念，是上述三种缓存都未命中时的最后一道防线。

- **特点**：
  - 只在会话（Session）中存在
  - 一旦会话结束就被释放
  - 缓存时间很短
  - 只能被使用一次

## 二、内存缓存与磁盘缓存的存储策略

### 从内存缓存 (from memory cache) 的决定因素

1. **资源大小**：
   - 体积较小的资源（通常<1MB）更可能被存储在内存中
2. **资源类型**：
   - 图片资源（尤其是当前页面上即将使用的图片）
   - 小型 CSS、JS 文件
   - 字体文件（使用中的）
3. **使用频率**：
   - 当前页面频繁使用的资源
   - 最近刚刚使用过的资源
4. **系统内存状态**：
   - 当系统内存充足时，更多资源会被缓存在内存中
   - 当内存紧张时，浏览器会清除部分内存缓存

### 从磁盘缓存 (from disk cache) 的决定因素

1. **资源大小**：
   - 较大的文件（通常>1MB）
2. **资源类型**：
   - 大型 JS、CSS 文件
   - 视频、音频文件
   - 不需要立即使用的图片
3. **使用频率**：
   - 使用频率较低但仍需缓存的资源
   - 需要跨会话保存的资源
4. **缓存标识**：
   - 带有明确磁盘缓存策略的资源(Cache-Control: public)

### 浏览器的内部决策逻辑

浏览器在决定将资源存入内存还是磁盘缓存时，会考虑以下因素：

1. **资源的重要性和紧急性**：
   - 当前视口内的资源通常优先放入内存缓存
2. **系统资源状态**：
   - 内存不足时会优先使用磁盘缓存
3. **用户行为预测**：
   - 预计用户即将需要的资源可能优先放入内存
4. **会话持续预期**：

   - 可能需要长期保存的资源放入磁盘缓存

5. **缓存命中率优化**：
   - 浏览器会基于历史访问模式做出优化决策

## 三、强缓存与协商缓存

### 强缓存 (Strong Cache)

强缓存是指在缓存期间，不需要向服务器发送请求确认，直接使用缓存的机制。

- **控制方式**：
  - `Expires`：HTTP/1.0 的产物，使用绝对时间，受限于客户端时间设置
  - `Cache-Control`：HTTP/1.1 引入，更灵活，优先级高于 Expires
- **常用 Cache-Control 值**：
  - `max-age=<seconds>`：缓存有效期（秒）
  - `public`：可以被任何对象缓存（客户端、代理服务器等）
  - `private`：只能被单个用户的浏览器缓存
  - `no-cache`：使用缓存前必须先与服务器确认
  - `no-store`：不缓存任何内容
- **状态码**：
  - 强缓存命中时，浏览器直接从缓存读取资源，不发送请求，网络面板显示状态码为 `200 (from disk cache)` 或 `200 (from memory cache)`

### 协商缓存 (Negotiation Cache)

协商缓存是指浏览器需要向服务器发送请求确认是否使用缓存的机制。

- **控制方式**：
  - `Last-Modified / If-Modified-Since`：基于资源修改时间
  - `ETag / If-None-Match`：基于资源内容的指纹标识
- **Last-Modified 机制**：
  1. 服务器返回资源时，在响应头中添加 Last-Modified，标识资源最后修改时间
  2. 浏览器再次请求时，在请求头中添加 If-Modified-Since，值为上次收到的 Last-Modified 值
  3. 服务器比较时间，若资源未修改，返回 304 状态码，浏览器使用缓存；若已修改，返回 200 和新资源
- **ETag 机制**：
  1. 服务器返回资源时，在响应头中添加 ETag，是资源内容的哈希值或唯一标识
  2. 浏览器再次请求时，在请求头中添加 If-None-Match，值为上次收到的 ETag 值
  3. 服务器比较 ETag，若匹配则返回 304 状态码，浏览器使用缓存；若不匹配，返回 200 和新资源
- **状态码**：

  - 协商缓存命中时，返回 `304 Not Modified`，响应体为空，浏览器直接使用缓存

- **ETag vs Last-Modified**：
  - ETag 更准确（考虑内容变化）
  - Last-Modified 精度只到秒级
  - ETag 计算消耗服务器资源较多
  - 优先使用 ETag，两者同时使用时 ETag 优先级更高

## 四、缓存实践与优化策略

### 最佳实践

1. **静态资源策略**：
   - 不经常变化的静态资源：强缓存，Cache-Control: max-age=31536000（一年）
   - 经常变化的静态资源：使用内容哈希命名（webpack 的[contenthash]）+ 长期缓存
2. **HTML 策略**：
   - HTML 通常使用协商缓存或短期缓存，如 Cache-Control: no-cache 或 max-age 较小的值
3. **API 响应策略**：
   - API 响应通常使用 Cache-Control: no-cache, no-store 或私有缓存

### 常见问题与解决方案

1. **资源更新问题**：
   - 使用版本号或哈希值命名文件
   - 使用内容哈希（如 webpack 的 contenthash）
2. **缓存清除**：

   - 使用 Cache-Control: max-age=0, must-revalidate
   - 更改资源 URL（查询参数、路径等）

3. **用户行为相关**：
   - F5 刷新：协商缓存有效，强缓存失效
   - Ctrl+F5 强制刷新：所有缓存失效，发送请求头包含 Cache-Control: no-cache

## 总结

浏览器缓存机制是一个多层次的系统，从 Service Worker 到内存缓存、磁盘缓存再到 Push Cache，形成了完善的缓存体系。内存缓存与磁盘缓存的使用取决于资源特性、系统状态和浏览器优化策略。强缓存与协商缓存则通过不同的 HTTP 头控制缓存的验证方式。理解并合理利用这些缓存机制，可以显著提升网站性能和用户体验。
