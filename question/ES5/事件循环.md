# 事件循环（Event Loop）

## 一、浏览器的事件循环

### 1.1 基本概念

浏览器中的 JavaScript 是**单线程**的，但可以通过**事件循环（Event Loop）**机制实现异步操作。事件循环是一个持续运行的进程，负责协调执行栈、任务队列之间的关系。

### 1.2 核心组成部分

1. **调用栈（Call Stack）**

   - 同步代码的执行环境
   - 遵循后进先出（LIFO）原则
   - 当栈为空时，事件循环会检查任务队列

2. **任务队列（Task Queue）**

   - **宏任务队列（Macro Task Queue）**

     - `setTimeout`
     - `setInterval`
     - `setImmediate`（IE 专有）
     - `I/O`
     - `UI rendering`
     - `requestAnimationFrame`

   - **微任务队列（Micro Task Queue）**
     - `Promise.then/catch/finally`
     - `MutationObserver`
     - `queueMicrotask`
     - `process.nextTick`（Node.js，但在浏览器中不存在）

3. **Web APIs**
   - 浏览器提供的异步 API
   - 如 `setTimeout`、`fetch`、DOM 事件等

### 1.3 执行流程

```
1. 执行同步代码，压入调用栈
2. 遇到异步任务，交给 Web APIs 处理
3. 异步任务完成后，回调进入对应的任务队列
4. 调用栈清空后：
   a. 先执行所有微任务队列中的任务
   b. 执行一个宏任务
   c. 再次检查并执行所有微任务
   d. 进行 UI 渲染（如果需要）
   e. 重复步骤 b-d
```

### 1.4 代码示例

```javascript
console.log("1"); // 同步代码

setTimeout(() => {
  console.log("2"); // 宏任务
}, 0);

Promise.resolve()
  .then(() => {
    console.log("3"); // 微任务
  })
  .then(() => {
    console.log("4"); // 微任务
  });

console.log("5"); // 同步代码

// 输出顺序：1 -> 5 -> 3 -> 4 -> 2
```

**执行分析：**

1. 同步代码：`console.log('1')` → 输出 `1`
2. `setTimeout` 回调进入宏任务队列
3. `Promise.then` 回调进入微任务队列
4. 同步代码：`console.log('5')` → 输出 `5`
5. 调用栈清空，执行所有微任务：输出 `3`、`4`
6. 执行宏任务：输出 `2`

### 1.5 复杂示例

```javascript
console.log("start");

setTimeout(() => {
  console.log("timeout1");
  Promise.resolve().then(() => {
    console.log("promise in timeout1");
  });
}, 0);

Promise.resolve()
  .then(() => {
    console.log("promise1");
    setTimeout(() => {
      console.log("timeout in promise1");
    }, 0);
  })
  .then(() => {
    console.log("promise2");
  });

console.log("end");

// 输出顺序：
// start
// end
// promise1
// promise2
// timeout1
// promise in timeout1
// timeout in promise1
```

---

## 二、Node.js 的事件循环

### 2.1 基本概念

Node.js 的事件循环基于 **libuv** 库实现，与浏览器有显著区别。它被划分为多个阶段，每个阶段都有自己的任务队列。

### 2.2 事件循环的六个阶段

```
   ┌───────────────────────────┐
┌─>│           timers          │  执行 setTimeout/setInterval 回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │  执行延迟到下一轮的 I/O 回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │  仅内部使用
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │           poll            │  检索新的 I/O 事件，执行 I/O 回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │           check           │  执行 setImmediate 回调
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │  执行关闭回调，如 socket.on('close')
   └───────────────────────────┘
```

**各阶段详解：**

1. **timers**：执行 `setTimeout` 和 `setInterval` 的回调
2. **pending callbacks**：执行某些系统操作的回调（如 TCP 错误）
3. **idle, prepare**：仅供内部使用
4. **poll（轮询）**：
   - 检索新的 I/O 事件
   - 执行 I/O 相关的回调
   - 如果没有 timers 和 setImmediate，会在此阶段阻塞等待
5. **check**：执行 `setImmediate` 回调
6. **close callbacks**：执行关闭事件的回调，如 `socket.on('close')`

### 2.3 微任务队列

在 Node.js 中，每个阶段执行完毕后，都会执行微任务队列：

1. **`process.nextTick` 队列**（优先级最高）
2. **`Promise` 微任务队列**

**执行顺序：** `process.nextTick` > `Promise.then` > 下一阶段

### 2.4 代码示例

#### 示例 1：基础示例

```javascript
console.log("start");

setTimeout(() => {
  console.log("timeout");
}, 0);

setImmediate(() => {
  console.log("immediate");
});

process.nextTick(() => {
  console.log("nextTick");
});

Promise.resolve().then(() => {
  console.log("promise");
});

console.log("end");

// 输出顺序：
// start
// end
// nextTick
// promise
// timeout
// immediate
```

**执行分析：**

1. 同步代码：`start` → `end`
2. 微任务队列：
   - `process.nextTick`（优先级最高）→ `nextTick`
   - `Promise.then` → `promise`
3. timers 阶段：`timeout`
4. check 阶段：`immediate`

#### 示例 2：setTimeout vs setImmediate

```javascript
// 在主模块中执行，顺序不确定
setTimeout(() => {
  console.log("timeout");
}, 0);

setImmediate(() => {
  console.log("immediate");
});

// 可能输出：timeout -> immediate
// 也可能：immediate -> timeout
```

```javascript
// 在 I/O 回调中执行，setImmediate 总是先执行
const fs = require("fs");

fs.readFile(__filename, () => {
  setTimeout(() => {
    console.log("timeout");
  }, 0);

  setImmediate(() => {
    console.log("immediate");
  });
});

// 输出顺序：
// immediate
// timeout
```

**原因：** 在 I/O 回调中，当前处于 poll 阶段，紧接着会进入 check 阶段（执行 `setImmediate`），然后才是下一轮的 timers 阶段。

#### 示例 3：process.nextTick 的递归陷阱

```javascript
// ⚠️ 警告：这会导致事件循环卡住！
process.nextTick(function foo() {
  process.nextTick(foo);
});

// 事件循环永远无法进入下一阶段
// 因为 nextTick 队列一直有任务
```

### 2.5 Node.js 11+ 的变化

从 Node.js 11 开始，事件循环的行为更接近浏览器：

- **旧版本**：每个阶段执行完**所有任务**后，才执行微任务
- **新版本**：每个阶段执行**一个任务**后，就检查并执行微任务

```javascript
setTimeout(() => {
  console.log("timer1");
  Promise.resolve().then(() => {
    console.log("promise1");
  });
}, 0);

setTimeout(() => {
  console.log("timer2");
  Promise.resolve().then(() => {
    console.log("promise2");
  });
}, 0);

// Node.js 10 及以下：
// timer1 -> timer2 -> promise1 -> promise2

// Node.js 11+（与浏览器行为一致）：
// timer1 -> promise1 -> timer2 -> promise2
```

---

## 三、浏览器 vs Node.js 对比

| 特性                           | 浏览器                                  | Node.js                                          |
| ------------------------------ | --------------------------------------- | ------------------------------------------------ |
| **实现基础**                   | 各浏览器自己的实现（如 V8）             | libuv                                            |
| **事件循环阶段**               | 宏任务/微任务两层队列                   | 六个阶段 + 微任务                                |
| **宏任务**                     | setTimeout、setInterval、UI rendering   | setTimeout、setInterval、I/O、setImmediate       |
| **微任务**                     | Promise、MutationObserver               | Promise、process.nextTick                        |
| **执行粒度**                   | 每次执行一个宏任务                      | 每个阶段执行该阶段的所有任务（Node.js 11+ 改变） |
| **特有 API**                   | requestAnimationFrame、MutationObserver | process.nextTick、setImmediate                   |
| **setTimeout vs setImmediate** | 无 setImmediate                         | setImmediate 在 I/O 回调中更快                   |

---

## 四、常见面试题

### 4.1 题目 1

```javascript
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}

async function async2() {
  console.log("async2");
}

console.log("script start");

setTimeout(() => {
  console.log("setTimeout");
}, 0);

async1();

new Promise((resolve) => {
  console.log("promise1");
  resolve();
}).then(() => {
  console.log("promise2");
});

console.log("script end");

// 输出顺序：
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

**分析：**

- `await async2()` 等价于 `Promise.resolve(async2()).then(...)`
- 所以 `console.log('async1 end')` 会进入微任务队列
- 与 `promise2` 同为微任务，按顺序执行

### 4.2 题目 2（Node.js）

```javascript
setImmediate(() => {
  console.log("immediate1");
  process.nextTick(() => {
    console.log("nextTick in immediate1");
  });
});

process.nextTick(() => {
  console.log("nextTick1");
  setImmediate(() => {
    console.log("immediate in nextTick1");
  });
});

// 输出顺序：
// nextTick1
// immediate1
// nextTick in immediate1
// immediate in nextTick1
```

---

## 五、最佳实践建议

1. **避免过度使用 `process.nextTick`**

   - 可能会阻塞事件循环
   - 优先考虑 `setImmediate` 或 `Promise`

2. **理解 `setTimeout(..., 0)` 的实际延迟**

   - 浏览器最小延迟约 4ms
   - Node.js 取决于事件循环当前阶段

3. **合理使用微任务**

   - 微任务过多会延迟宏任务的执行
   - 可能影响 UI 渲染和用户体验

4. **注意平台差异**

   - 浏览器和 Node.js 的事件循环有本质区别
   - 编写跨平台代码时需要测试

5. **使用 `setImmediate`（Node.js）**
   - 在 I/O 密集型应用中比 `setTimeout` 更高效
   - 不受系统时间影响

---

## 六、参考资料

- [MDN - Event Loop](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop)
- [Node.js 官方文档 - Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)
- [Jake Archibald: In The Loop - JSConf.Asia](https://www.youtube.com/watch?v=cCOL7MC4Pl0)
- [深入理解 Node.js 事件循环](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/)
