# Script 标签的加载与执行属性详解

## 一、基本概念

脚本加载与执行是影响网页性能的关键因素。默认情况下，HTML 解析器遇到`<script>`标签时会暂停解析，下载并执行脚本，这会阻塞页面渲染。为解决这个问题，HTML5 引入了`async`和`defer`属性，此外还有动态创建的脚本和`type="module"`等特性，它们各自对页面的加载和渲染流程有不同影响。

## 二、Script 标签的属性选项

### 1. 普通脚本（无特殊属性）

**语法**：

```html
<script src="script.js"></script>
```

**加载与执行特点**：

- 阻塞 HTML 解析
- 按照在 HTML 中出现的顺序同步下载和执行
- 脚本必须等待前面的 CSS 加载和解析完成才会执行

**渲染流程影响**：

- 会完全阻塞 DOM 构建
- 延迟页面的首次渲染时间(First Paint)
- 延迟 DOM 内容完成时间(DOMContentLoaded)
- 延迟页面完全加载时间(Load)

### 2. async 属性

**语法**：

```html
<script src="script.js" async></script>
```

**加载与执行特点**：

- 异步下载，不阻塞 HTML 解析
- 下载完成后立即执行，会中断 HTML 解析
- 执行顺序不确定，谁先下载完成谁先执行
- 不保证脚本之间的依赖关系和执行顺序

**渲染流程影响**：

- 不阻塞 DOM 构建，除非正好在执行脚本时
- 可能在 DOMContentLoaded 事件前或后执行
- 通常在 Load 事件前执行完成
- 执行时会暂停页面渲染

### 3. defer 属性

**语法**：

```html
<script src="script.js" defer></script>
```

**加载与执行特点**：

- 异步下载，不阻塞 HTML 解析
- 延迟到 HTML 解析完成后，按照在文档中的顺序执行
- 所有 defer 脚本保证在 DOMContentLoaded 事件前执行完毕
- 保证脚本之间的依赖关系和执行顺序

**渲染流程影响**：

- 不阻塞 DOM 构建过程
- 不阻塞页面首次渲染
- 延迟 DOMContentLoaded 事件的触发
- 通常不会影响 Load 事件（除非脚本执行非常耗时）

### 4. type="module"

**语法**：

```html
<script type="module" src="module.js"></script>
```

**加载与执行特点**：

- 作为 ES6 模块加载
- 默认具有 defer 行为（即使是内联脚本）
- 可以额外添加 async 属性以改变行为
- 支持 import/export 语法
- 自动应用严格模式（'use strict'）
- 模块作用域隔离，不会污染全局命名空间

**渲染流程影响**：

- 与 defer 类似，不阻塞 DOM 构建
- 处理依赖关系可能带来额外网络请求和解析成本
- 对老旧浏览器通常需要提供 nomodule 回退方案

### 5. 动态创建的脚本

**语法**：

```javascript
const script = document.createElement("script");
script.src = "script.js";
document.head.appendChild(script);
```

**加载与执行特点**：

- 默认采用 async 行为
- 可以通过设置`script.async = false`使其按插入顺序执行
- 可以精确控制脚本加载时机
- 可以根据条件动态加载脚本

**渲染流程影响**：

- 不阻塞初始 HTML 解析
- 根据添加时机影响渲染
- 默认不保证执行顺序（除非显式设置 async=false）

## 三、行为对比与加载时序图

以下是不同脚本加载方式的行为对比：

| 特性           | 普通脚本       | async                           | defer                                | module                     | 动态创建                               |
| -------------- | -------------- | ------------------------------- | ------------------------------------ | -------------------------- | -------------------------------------- |
| 阻塞 HTML 解析 | 是             | 下载不阻塞，执行阻塞            | 下载不阻塞，执行不阻塞               | 下载不阻塞，执行不阻塞     | 下载不阻塞，执行通常阻塞               |
| 执行时机       | 立即           | 下载完成后立即执行              | DOM 解析完成后，DOMContentLoaded 前  | 同 defer                   | 插入后开始下载，默认下载完成后立即执行 |
| 执行顺序保证   | 是             | 否                              | 是                                   | 是，包含依赖               | 默认否，可通过设置保证                 |
| 适用场景       | 关键依赖且较小 | 独立功能，不依赖 DOM 和其他脚本 | 非关键脚本，需要完整 DOM，有依赖关系 | 使用 ES 模块系统的现代代码 | 条件加载，按需加载                     |

**加载时序示意图**：

```
普通脚本：
解析HTML ──────────────┐
                      下载脚本
                        │
                      执行脚本
                        │
                        └──────► 继续解析HTML ──► DOMContentLoaded

async:
解析HTML ────────────────────────────┐
         │                          │
         │  下载脚本                 │
         │    │                     │
         │    └─────► 执行脚本       │
         │             │            │
         └─────────────┘            │
                                    └──► DOMContentLoaded

defer:
解析HTML ──────────────────────────────────────► DOMContentLoaded
         │                                     │
         │  下载脚本                            │
         │    │                                │
         │    └──────────► 执行所有defer脚本    │
         │                      │              │
         └──────────────────────┘              │
                                               └──► Load事件

module:
解析HTML ──────────────────────────────────────► │
         │                                     │
         │  下载主模块                           │
         │    │  加载依赖                       │
         │    │    │                           │
         │    └────┘────────► 执行所有模块      │
         │                      │              │
         └──────────────────────┘              │
                                               └──► DOMContentLoaded
```

## 四、对关键渲染指标的影响

### 1. FP (First Paint) 首次绘制

- **普通脚本**：显著延迟 FP，因为阻塞解析
- **async**：通常不直接影响 FP，除非正好在首次渲染前执行
- **defer**：不影响 FP
- **module**：不影响 FP
- **动态创建**：通常不影响 FP（除非在关键渲染路径前插入并执行）

### 2. FCP (First Contentful Paint) 首次内容绘制

- **普通脚本**：显著延迟 FCP
- **async**：如执行时修改了 DOM 内容，可能导致 FCP 延迟或重复
- **defer**：通常在 FCP 后执行，不直接影响
- **module**：通常在 FCP 后执行，不直接影响
- **动态创建**：取决于创建和执行时机

### 3. LCP (Largest Contentful Paint) 最大内容绘制

- **普通脚本**：显著延迟 LCP
- **async**：视执行时机可能影响 LCP
- **defer**：如果脚本负责加载主要内容，可能延迟 LCP
- **module**：如模块系统复杂，可能间接延迟 LCP
- **动态创建**：如在正确时机使用，可以优化 LCP

### 4. TTI (Time to Interactive) 可交互时间

- **普通脚本**：通常延迟 TTI
- **async**：可能导致 TTI 不稳定，尤其是多个 async 脚本时
- **defer**：通常使 TTI 更可预测
- **module**：可能因模块解析增加 TTI 时间
- **动态创建**：可以实现更细粒度的 TTI 控制

## 五、最佳实践与使用建议

### 1. 何时使用 async

- **适用场景**：

  - 独立的功能脚本（如分析统计、广告）
  - 不依赖 DOM 和其他脚本的代码
  - 脚本加载与执行的确切顺序不重要时

- **注意事项**：
  - async 脚本可能在任何时刻执行，甚至在页面尚未完全加载时
  - 多个 async 脚本的执行顺序不能保证
  - 不应该操作尚未加载的 DOM 元素

### 2. 何时使用 defer

- **适用场景**：

  - 依赖完整 DOM 结构的非关键脚本
  - 需要按顺序执行的多个脚本
  - 页面的主要交互功能，但不是首屏渲染所必需的

- **注意事项**：
  - defer 是当今最常推荐的脚本加载方式
  - 所有 defer 脚本都会等待 HTML 解析完成
  - 大型应用中过多 defer 脚本仍可能导致性能问题

### 3. 何时使用 type="module"

- **适用场景**：

  - 使用 ES 模块系统的现代应用
  - 需要进行代码拆分的复杂前端项目
  - 使用第三方 ES 模块的情况

- **注意事项**：
  - 提供 nomodule 回退以支持旧版浏览器
  - 注意模块加载可能引入额外网络请求
  - 考虑构建工具（如 Webpack、Rollup）以优化生产环境模块

### 4. 何时使用动态脚本创建

- **适用场景**：

  - 按需加载的非关键功能
  - 基于用户交互加载的功能
  - 实现懒加载或条件加载

- **注意事项**：
  - 设置`script.async = false`以保证执行顺序
  - 考虑使用 Promise 封装脚本加载过程
  - 避免在关键渲染路径上动态加载脚本

### 5. 内联脚本与外部脚本的选择

- **内联脚本**：

  - 避免额外的网络请求
  - 适合小型关键脚本
  - 但不能利用浏览器缓存

- **外部脚本**：
  - 可利用浏览器缓存
  - 适合大型脚本和共享代码
  - 可以利用 async/defer 属性优化加载

## 六、常见问题与解决方案

### 1. 脚本依赖问题

- **问题**：使用 async 时，脚本执行顺序不确定，可能导致依赖错误
- **解决方案**：
  - 对有依赖关系的脚本使用 defer 而非 async
  - 使用模块系统处理依赖
  - 使用打包工具合并有依赖关系的脚本

### 2. DOM 操作时机问题

- **问题**：脚本尝试操作尚未加载的 DOM 元素
- **解决方案**：
  - 使用 defer 属性确保 DOM 已完全构建
  - 在 DOMContentLoaded 或更晚的事件中进行 DOM 操作
  - 将 DOM 操作代码移到 HTML 结构之后

### 3. 渲染阻塞问题

- **问题**：过多脚本导致页面渲染延迟
- **解决方案**：
  - 延迟非关键脚本的加载（defer/async）
  - 使用代码拆分，只加载当前视图所需脚本
  - 内联关键 CSS，避免脚本等待 CSS 加载

### 4. 旧浏览器兼容性

- **问题**：旧浏览器不支持 async/defer/module
- **解决方案**：
  - 提供适当的回退方案（如 nomodule 属性）
  - 使用加载器库处理不同浏览器特性
  - 考虑使用构建工具生成兼容性代码

## 七、实际案例分析

### 1. 关键渲染路径优化

**问题**：页面加载速度慢，FCP 延迟

**解决方案**：

```html
<!-- 内联关键CSS -->
<style>
  /* 关键CSS */
</style>

<!-- 延迟加载非关键JS -->
<script defer src="non-critical.js"></script>

<!-- 异步加载分析脚本 -->
<script async src="analytics.js"></script>

<!-- 在页面底部放置主要应用逻辑 -->
<script type="module" src="app.js"></script>
```

### 2. 依赖脚本的正确加载顺序

**问题**：多个相互依赖的脚本需要按特定顺序执行

**解决方案**：

```html
<!-- 使用defer保证执行顺序 -->
<script defer src="vendor.js"></script>
<script defer src="library.js"></script>
<script defer src="app.js"></script>

<!-- 或使用模块系统管理依赖 -->
<script type="module" src="main.js"></script>
```

### 3. 条件加载脚本

**问题**：只有特定用户或特定操作才需要的大型功能

**解决方案**：

```javascript
// 根据用户操作动态加载脚本
document.getElementById("feature-button").addEventListener("click", () => {
  const script = document.createElement("script");
  script.src = "heavy-feature.js";
  document.head.appendChild(script);
});
```

## 八、结论与总结对比

| 属性/方法 | 加载行为 | 执行时机            | 阻塞渲染   | 顺序保证       | 使用场景             | 浏览器兼容性                |
| --------- | -------- | ------------------- | ---------- | -------------- | -------------------- | --------------------------- |
| 普通脚本  | 同步下载 | 立即                | 完全阻塞   | 是             | 关键且小型脚本       | 全部支持                    |
| async     | 异步下载 | 下载完成后立即      | 执行时阻塞 | 否             | 独立功能、统计分析   | IE10+, 所有现代浏览器       |
| defer     | 异步下载 | HTML 解析后，按顺序 | 不阻塞     | 是             | 非关键功能、依赖 DOM | IE10+完全支持, IE9 部分支持 |
| module    | 异步下载 | 同 defer            | 不阻塞     | 是，含依赖     | 现代 ES 模块化应用   | 除 IE 外的现代浏览器        |
| 动态创建  | 异步下载 | 默认立即，可控制    | 可控制     | 默认否，可控制 | 按需加载、条件加载   | 全部支持                    |

正确使用 script 加载策略可以显著提升页面性能和用户体验。对于现代网站开发，推荐的最佳实践是：

- 使用`defer`加载大多数脚本
- 使用`async`加载独立的第三方脚本
- 考虑使用 ES 模块系统管理复杂应用
- 对关键脚本进行适当优化（内联、位置调整等）
- 利用构建工具优化生产环境脚本加载
