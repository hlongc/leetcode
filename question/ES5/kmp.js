/**
 * KMP算法（Knuth-Morris-Pratt算法）
 * 这是一个高效的字符串匹配算法，时间复杂度为O(n+m)，其中n是主串长度，m是模式串长度
 *
 * KMP算法的核心思想：
 * 1. 当匹配失败时，不需要回溯主串指针
 * 2. 利用已经匹配的信息，尽可能地跳过一些不必要的比较
 * 3. 通过预处理模式串得到部分匹配表(next数组)，指导模式串的移动
 */

// 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。
function kmp(s, t) {
  // 处理边界情况
  if (!t || t.length === 0) return 0; // 如果模式串为空，直接返回0（找到，在位置0）
  if (!s || s.length === 0) return -1; // 如果主串为空，返回-1（未找到）

  /**
   * 构建部分匹配表（next数组）
   * next[i]表示：对于模式串t的前i+1个字符构成的子串，其最长的相同前缀和后缀的长度
   *
   * 例如：对于模式串"ABABC"
   * next[0] = 0：对于子串"A"，没有真前缀和真后缀，所以最长相同前后缀长度为0
   * next[1] = 0：对于子串"AB"，前缀为"A"，后缀为"B"，没有相同的，所以为0
   * next[2] = 1：对于子串"ABA"，前缀有"A","AB"，后缀有"A","BA"，相同的是"A"，长度为1
   * next[3] = 2：对于子串"ABAB"，前缀有"A","AB","ABA"，后缀有"B","AB","BAB"，相同的是"AB"，长度为2
   * next[4] = 0：对于子串"ABABC"，没有相同的前缀和后缀，所以为0
   *
   * 这个表用于在匹配失败时，确定模式串指针应该回退到哪个位置继续匹配
   */
  function buildNext(pattern) {
    const next = Array(pattern.length).fill(0); // 初始化next数组，全部填充为0
    let j = 0; // j表示当前已匹配的前缀长度

    // 从模式串的第2个字符开始计算（索引1开始）
    for (let i = 1; i < pattern.length; i++) {
      // 如果当前字符与前缀的下一个字符不匹配，需要回退
      // j > 0 确保有前缀可回退
      while (j > 0 && pattern[i] !== pattern[j]) {
        j = next[j - 1]; // 回退到上一个可能的匹配位置
        // 这一步是KMP的关键，利用已经计算出的next值进行跳转
      }

      // 如果当前字符与前缀的下一个字符匹配，前缀长度加1
      if (pattern[i] === pattern[j]) {
        j++;
      }

      // 记录当前位置i的最长相同前后缀长度
      next[i] = j;
    }

    return next; // 返回构建好的next数组
  }

  // 获取模式串t的部分匹配表
  const next = buildNext(t);
  let j = 0; // j是模式串t的当前匹配位置

  // 开始在主串s中查找模式串t
  for (let i = 0; i < s.length; i++) {
    // 当前字符不匹配，且已有部分匹配时，利用next数组回退模式串指针
    while (j > 0 && s[i] !== t[j]) {
      j = next[j - 1]; // 回退到next[j-1]指定的位置
      // 这里与buildNext中的回退逻辑相同，是KMP算法避免回溯主串的关键
    }

    // 当前字符匹配成功，模式串指针前进
    if (s[i] === t[j]) {
      j++;
    }

    // 如果j等于模式串长度，说明完全匹配成功
    if (j === t.length) {
      return i - j + 1; // 返回匹配起始位置：当前位置 - 模式串长度 + 1
    }
  }

  return -1; // 匹配失败，返回-1
}
