# ç½‘ç«™æ•°æ®ä¼ è¾“åŠ å¯†æ”¹é€ æ–¹æ¡ˆ

## ğŸ“‹ éœ€æ±‚åˆ†æ

### ç›®æ ‡
- åœ¨ HTTPS ä¹‹ä¸Šå†å¢åŠ ä¸€å±‚åº”ç”¨å±‚åŠ å¯†
- æ‹¦æˆªæ‰€æœ‰ç½‘ç»œè¯·æ±‚ï¼ˆåŒ…æ‹¬ç¬¬ä¸‰æ–¹åº“å‘å‡ºçš„ï¼‰å¹¶åŠ å¯†
- æ‹¦æˆªæ‰€æœ‰å“åº”å¹¶è§£å¯†
- **ä¸èƒ½ä¿®æ”¹ç¬¬ä¸‰æ–¹åº“ä»£ç **
- **å°½å¯èƒ½å‡å°‘å¯¹ä¸šåŠ¡ä»£ç çš„ä¾µå…¥**

### æŒ‘æˆ˜
1. ç¬¬ä¸‰æ–¹åº“ï¼ˆå¦‚ axiosã€jQueryï¼‰ç›´æ¥è°ƒç”¨ fetch/XMLHttpRequest
2. éœ€è¦åœ¨å®ƒä»¬æ‰§è¡Œå‰æ‹¦æˆª
3. ä¸èƒ½ä¿®æ”¹ç¬¬ä¸‰æ–¹åº“æºç 
4. åŠ è§£å¯†è¦å¯¹ä¸šåŠ¡é€æ˜

---

## ğŸ¯ è§£å†³æ–¹æ¡ˆï¼šå¤šå±‚æ‹¦æˆªç­–ç•¥

### æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | ä¾µå…¥æ€§ | è¦†ç›–ç‡ | å¤æ‚åº¦ | æ¨èåº¦ |
|------|-------|--------|--------|--------|
| **æ–¹æ¡ˆ1ï¼šMonkey Patch** | ä½ | é«˜ | ä½ | â­â­â­â­â­ |
| **æ–¹æ¡ˆ2ï¼šService Worker** | ä½ | æœ€é«˜ | ä¸­ | â­â­â­â­ |
| **æ–¹æ¡ˆ3ï¼šä»£ç†å¯¹è±¡** | ä¸­ | ä¸­ | ä½ | â­â­â­ |
| **æ–¹æ¡ˆ4ï¼šHTTP æ‹¦æˆªå™¨** | é«˜ | ä½ | ä½ | â­â­ |

---

## ğŸ¥‡ æ¨èæ–¹æ¡ˆ1ï¼šMonkey Patchï¼ˆçŒ´å­è¡¥ä¸ï¼‰

### åŸç†

åœ¨æ‰€æœ‰ä»£ç æ‰§è¡Œå‰ï¼Œä¿®æ”¹å…¨å±€çš„ `fetch` å’Œ `XMLHttpRequest` å¯¹è±¡ï¼Œæ³¨å…¥åŠ å¯†/è§£å¯†é€»è¾‘ã€‚

### å®Œæ•´å®ç°

```javascript
/**
 * ============================================
 * åŠ å¯†ä¼ è¾“æ‹¦æˆªå™¨
 * 
 * åœ¨é¡¹ç›®å…¥å£æœ€é¡¶éƒ¨å¼•å…¥ï¼Œæ—©äºæ‰€æœ‰ç¬¬ä¸‰æ–¹åº“
 * ============================================
 */

// ============================================
// 1. åŠ å¯†/è§£å¯†å·¥å…·ç±»
// ============================================
class CryptoUtil {
  static secretKey = 'your-secret-key-2024'; // å®é™…é¡¹ç›®ä¸­ä»æœåŠ¡å™¨è·å–
  
  /**
   * åŠ å¯†æ•°æ®ï¼ˆä½¿ç”¨ AESï¼‰
   */
  static async encrypt(data) {
    try {
      // æ–¹æ¡ˆ1: ä½¿ç”¨ Web Crypto APIï¼ˆæ¨èï¼Œæµè§ˆå™¨åŸç”Ÿï¼‰
      const encoder = new TextEncoder();
      const dataBuffer = encoder.encode(typeof data === 'string' ? data : JSON.stringify(data));
      
      const key = await this.getKey();
      const iv = crypto.getRandomValues(new Uint8Array(12));
      
      const encryptedBuffer = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        key,
        dataBuffer
      );
      
      // å°† IV å’ŒåŠ å¯†æ•°æ®ç»„åˆ
      const result = new Uint8Array(iv.length + encryptedBuffer.byteLength);
      result.set(iv, 0);
      result.set(new Uint8Array(encryptedBuffer), iv.length);
      
      // è½¬ä¸º Base64
      return this.arrayBufferToBase64(result.buffer);
    } catch (error) {
      console.error('åŠ å¯†å¤±è´¥:', error);
      return data; // é™çº§ï¼šè¿”å›åŸæ•°æ®
    }
  }
  
  /**
   * è§£å¯†æ•°æ®
   */
  static async decrypt(encryptedData) {
    try {
      if (!encryptedData) return encryptedData;
      
      // Base64 è§£ç 
      const buffer = this.base64ToArrayBuffer(encryptedData);
      const dataView = new Uint8Array(buffer);
      
      // æå– IV å’ŒåŠ å¯†æ•°æ®
      const iv = dataView.slice(0, 12);
      const data = dataView.slice(12);
      
      const key = await this.getKey();
      
      const decryptedBuffer = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv },
        key,
        data
      );
      
      // è½¬ä¸ºå­—ç¬¦ä¸²
      const decoder = new TextDecoder();
      const decryptedStr = decoder.decode(decryptedBuffer);
      
      // å°è¯•è§£æ JSON
      try {
        return JSON.parse(decryptedStr);
      } catch {
        return decryptedStr;
      }
    } catch (error) {
      console.error('è§£å¯†å¤±è´¥:', error);
      return encryptedData; // é™çº§ï¼šè¿”å›åŸæ•°æ®
    }
  }
  
  /**
   * è·å–åŠ å¯†å¯†é’¥ï¼ˆä»å›ºå®šå¯†é’¥æ´¾ç”Ÿï¼‰
   */
  static async getKey() {
    if (this._cachedKey) return this._cachedKey;
    
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      encoder.encode(this.secretKey),
      { name: 'PBKDF2' },
      false,
      ['deriveKey']
    );
    
    this._cachedKey = await crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: encoder.encode('salt'),
        iterations: 100000,
        hash: 'SHA-256'
      },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
    
    return this._cachedKey;
  }
  
  // Base64 è¾…åŠ©æ–¹æ³•
  static arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  
  static base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }
}

// ============================================
// 2. Fetch API æ‹¦æˆª
// ============================================
(function interceptFetch() {
  const originalFetch = window.fetch;
  
  window.fetch = async function(...args) {
    let [url, options = {}] = args;
    
    console.log('[æ‹¦æˆª] Fetch è¯·æ±‚:', url);
    
    // åŠ å¯†è¯·æ±‚ä½“
    if (options.body) {
      console.log('[åŠ å¯†] è¯·æ±‚ä½“:', options.body);
      
      // åˆ¤æ–­æ˜¯å¦éœ€è¦åŠ å¯†ï¼ˆå¯ä»¥æ ¹æ® URL é…ç½®ï¼‰
      if (shouldEncrypt(url)) {
        const encrypted = await CryptoUtil.encrypt(options.body);
        
        options = {
          ...options,
          body: JSON.stringify({ encrypted }),
          headers: {
            ...options.headers,
            'Content-Type': 'application/json',
            'X-Encrypted': 'true' // æ ‡è®°ä¸ºåŠ å¯†è¯·æ±‚
          }
        };
      }
    }
    
    // è°ƒç”¨åŸå§‹ fetch
    const response = await originalFetch(url, options);
    
    // å…‹éš†å“åº”ï¼ˆå› ä¸º body åªèƒ½è¯»ä¸€æ¬¡ï¼‰
    const clonedResponse = response.clone();
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦è§£å¯†
    if (response.headers.get('X-Encrypted') === 'true') {
      try {
        const encryptedData = await clonedResponse.text();
        const decryptedData = await CryptoUtil.decrypt(encryptedData);
        
        console.log('[è§£å¯†] å“åº”æ•°æ®');
        
        // åˆ›å»ºæ–°çš„ Response å¯¹è±¡
        return new Response(
          typeof decryptedData === 'string' 
            ? decryptedData 
            : JSON.stringify(decryptedData),
          {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers
          }
        );
      } catch (error) {
        console.error('[è§£å¯†] å¤±è´¥:', error);
        return response;
      }
    }
    
    return response;
  };
  
  console.log('âœ… Fetch API æ‹¦æˆªå·²å®‰è£…');
})();

// ============================================
// 3. XMLHttpRequest æ‹¦æˆª
// ============================================
(function interceptXHR() {
  const OriginalXHR = window.XMLHttpRequest;
  
  window.XMLHttpRequest = function() {
    const xhr = new OriginalXHR();
    
    // ä¿å­˜åŸå§‹æ–¹æ³•
    const originalOpen = xhr.open;
    const originalSend = xhr.send;
    const originalSetRequestHeader = xhr.setRequestHeader;
    
    let requestURL = '';
    let requestMethod = '';
    let requestHeaders = {};
    
    // æ‹¦æˆª open
    xhr.open = function(method, url, ...args) {
      requestURL = url;
      requestMethod = method;
      console.log('[æ‹¦æˆª] XHR è¯·æ±‚:', method, url);
      return originalOpen.apply(this, [method, url, ...args]);
    };
    
    // æ‹¦æˆª setRequestHeader
    xhr.setRequestHeader = function(header, value) {
      requestHeaders[header] = value;
      return originalSetRequestHeader.apply(this, arguments);
    };
    
    // æ‹¦æˆª send
    xhr.send = async function(body) {
      // åŠ å¯†è¯·æ±‚ä½“
      if (body && shouldEncrypt(requestURL)) {
        console.log('[åŠ å¯†] XHR è¯·æ±‚ä½“');
        
        const encrypted = await CryptoUtil.encrypt(body);
        
        // è®¾ç½®åŠ å¯†æ ‡è®°
        originalSetRequestHeader.call(this, 'Content-Type', 'application/json');
        originalSetRequestHeader.call(this, 'X-Encrypted', 'true');
        
        // å‘é€åŠ å¯†æ•°æ®
        return originalSend.call(this, JSON.stringify({ encrypted }));
      }
      
      return originalSend.apply(this, arguments);
    };
    
    // æ‹¦æˆªå“åº”
    Object.defineProperty(xhr, 'response', {
      get: function() {
        const originalResponse = Object.getOwnPropertyDescriptor(
          OriginalXHR.prototype, 
          'response'
        ).get.call(this);
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦è§£å¯†
        const isEncrypted = this.getResponseHeader('X-Encrypted') === 'true';
        if (isEncrypted && originalResponse) {
          // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦å¼‚æ­¥è§£å¯†ï¼Œå®é™…å®ç°å¯èƒ½éœ€è¦è°ƒæ•´
          // å¯ä»¥è€ƒè™‘ä½¿ç”¨åŒæ­¥çš„åŠ å¯†åº“
          return originalResponse; // ç®€åŒ–å¤„ç†
        }
        
        return originalResponse;
      }
    });
    
    return xhr;
  };
  
  // å¤åˆ¶é™æ€å±æ€§
  Object.setPrototypeOf(window.XMLHttpRequest, OriginalXHR);
  window.XMLHttpRequest.prototype = OriginalXHR.prototype;
  
  console.log('âœ… XMLHttpRequest æ‹¦æˆªå·²å®‰è£…');
})();

// ============================================
// 4. é…ç½®ï¼šå“ªäº›è¯·æ±‚éœ€è¦åŠ å¯†
// ============================================
function shouldEncrypt(url) {
  // é…ç½®éœ€è¦åŠ å¯†çš„ URL è§„åˆ™
  const encryptRules = [
    /\/api\//,           // æ‰€æœ‰ /api/ å¼€å¤´çš„è¯·æ±‚
    /\/user\//,          // ç”¨æˆ·ç›¸å…³æ¥å£
    /\/payment\//,       // æ”¯ä»˜æ¥å£
  ];
  
  // æ’é™¤è§„åˆ™ï¼ˆä¸éœ€è¦åŠ å¯†çš„ï¼‰
  const excludeRules = [
    /\/api\/public\//,   // å…¬å¼€æ¥å£
    /\.(jpg|png|gif)$/,  // å›¾ç‰‡
    /\/cdn\//,           // CDN èµ„æº
  ];
  
  // æ£€æŸ¥æ’é™¤è§„åˆ™
  if (excludeRules.some(rule => rule.test(url))) {
    return false;
  }
  
  // æ£€æŸ¥åŠ å¯†è§„åˆ™
  return encryptRules.some(rule => rule.test(url));
}
```

### ä½¿ç”¨æ–¹å¼

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>åŠ å¯†ä¼ è¾“æ”¹é€ ç¤ºä¾‹</title>
  
  <!-- 
    âš ï¸ å…³é”®ï¼šåœ¨æ‰€æœ‰å…¶ä»–è„šæœ¬ä¹‹å‰å¼•å…¥æ‹¦æˆªå™¨
    è¿™æ ·å¯ä»¥ç¡®ä¿ç¬¬ä¸‰æ–¹åº“ä½¿ç”¨çš„æ˜¯è¢«æ‹¦æˆªåçš„ API
  -->
  <script src="/crypto-interceptor.js"></script>
  
  <!-- ç¬¬ä¸‰æ–¹åº“ -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  
  <!-- ä¸šåŠ¡ä»£ç  -->
  <script src="/app.js"></script>
</head>
<body>
  <!-- é¡µé¢å†…å®¹ -->
</body>
</html>
```

```javascript
// app.js - ä¸šåŠ¡ä»£ç æ— éœ€ä¿®æ”¹ï¼

// ä½¿ç”¨ fetchï¼ˆè‡ªåŠ¨åŠ å¯†ï¼‰
fetch('/api/user', {
  method: 'POST',
  body: JSON.stringify({ name: 'John' })
})
.then(res => res.json())
.then(data => {
  // data å·²ç»è‡ªåŠ¨è§£å¯†
  console.log(data);
});

// ä½¿ç”¨ axiosï¼ˆè‡ªåŠ¨åŠ å¯†ï¼‰
axios.post('/api/login', { 
  username: 'john',
  password: 'secret'
})
.then(response => {
  // response.data å·²ç»è‡ªåŠ¨è§£å¯†
  console.log(response.data);
});

// ä½¿ç”¨ jQueryï¼ˆè‡ªåŠ¨åŠ å¯†ï¼‰
$.ajax({
  url: '/api/data',
  method: 'POST',
  data: JSON.stringify({ query: 'test' }),
  contentType: 'application/json',
  success: function(data) {
    // data å·²ç»è‡ªåŠ¨è§£å¯†
    console.log(data);
  }
});
```

---

## ğŸ¥ˆ æ–¹æ¡ˆ2ï¼šService Worker æ‹¦æˆªï¼ˆæ›´å¼ºå¤§ï¼‰

### åŸç†

Service Worker å¯ä»¥æ‹¦æˆªæ‰€æœ‰ç½‘ç»œè¯·æ±‚ï¼ŒåŒ…æ‹¬ç¬¬ä¸‰æ–¹åº“ã€å›¾ç‰‡ã€CSS ç­‰ã€‚

### å®Œæ•´å®ç°

```javascript
// ============================================
// main.js - æ³¨å†Œ Service Worker
// ============================================
if ('serviceWorker' in navigator) {
  navigator.serviceWorker
    .register('/crypto-service-worker.js')
    .then(registration => {
      console.log('âœ… Service Worker æ³¨å†ŒæˆåŠŸ');
    })
    .catch(error => {
      console.error('âŒ Service Worker æ³¨å†Œå¤±è´¥:', error);
    });
}

// ============================================
// crypto-service-worker.js - Service Worker
// ============================================

// åŠ å¯†å¯†é’¥ï¼ˆå®é™…é¡¹ç›®ä¸­åº”è¯¥æ›´å®‰å…¨åœ°ç®¡ç†ï¼‰
const SECRET_KEY = 'your-secret-key-2024';

// éœ€è¦åŠ å¯†çš„ URL è§„åˆ™
const ENCRYPT_RULES = [
  /\/api\//,
  /\/user\//,
  /\/payment\//
];

// æ’é™¤è§„åˆ™
const EXCLUDE_RULES = [
  /\/api\/public\//,
  /\.(jpg|png|gif|css|js)$/,
  /\/cdn\//
];

/**
 * åˆ¤æ–­æ˜¯å¦éœ€è¦åŠ å¯†
 */
function shouldEncrypt(url) {
  if (EXCLUDE_RULES.some(rule => rule.test(url))) {
    return false;
  }
  return ENCRYPT_RULES.some(rule => rule.test(url));
}

/**
 * ç®€åŒ–ç‰ˆåŠ å¯†ï¼ˆå®é™…åº”ä½¿ç”¨æ›´å®‰å…¨çš„ç®—æ³•ï¼‰
 */
function encrypt(data) {
  // è¿™é‡Œä½¿ç”¨ç®€åŒ–ç‰ˆï¼Œå®é™…é¡¹ç›®ä½¿ç”¨ Web Crypto API
  const str = typeof data === 'string' ? data : JSON.stringify(data);
  return btoa(encodeURIComponent(str));
}

function decrypt(encryptedData) {
  try {
    return JSON.parse(decodeURIComponent(atob(encryptedData)));
  } catch {
    return decodeURIComponent(atob(encryptedData));
  }
}

/**
 * æ‹¦æˆªæ‰€æœ‰ fetch è¯·æ±‚
 */
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = request.url;
  
  // ä¸éœ€è¦åŠ å¯†çš„è¯·æ±‚ï¼Œç›´æ¥æ”¾è¡Œ
  if (!shouldEncrypt(url)) {
    return event.respondWith(fetch(request));
  }
  
  console.log('[Service Worker] æ‹¦æˆªå¹¶åŠ å¯†:', url);
  
  event.respondWith(
    (async () => {
      try {
        // è¯»å–è¯·æ±‚ä½“
        let body = null;
        if (request.method !== 'GET' && request.method !== 'HEAD') {
          const originalBody = await request.text();
          if (originalBody) {
            // åŠ å¯†è¯·æ±‚ä½“
            body = JSON.stringify({
              encrypted: encrypt(originalBody)
            });
          }
        }
        
        // åˆ›å»ºæ–°çš„è¯·æ±‚
        const newRequest = new Request(request.url, {
          method: request.method,
          headers: {
            ...Object.fromEntries(request.headers.entries()),
            'Content-Type': 'application/json',
            'X-Encrypted': 'true' // æ ‡è®°åŠ å¯†è¯·æ±‚
          },
          body: body,
          mode: request.mode,
          credentials: request.credentials,
          cache: request.cache,
          redirect: request.redirect,
          referrer: request.referrer
        });
        
        // å‘é€è¯·æ±‚
        const response = await fetch(newRequest);
        
        // æ£€æŸ¥å“åº”æ˜¯å¦éœ€è¦è§£å¯†
        if (response.headers.get('X-Encrypted') === 'true') {
          const encryptedData = await response.text();
          const decryptedData = decrypt(encryptedData);
          
          console.log('[Service Worker] è§£å¯†å“åº”');
          
          // è¿”å›è§£å¯†åçš„å“åº”
          return new Response(
            typeof decryptedData === 'string'
              ? decryptedData
              : JSON.stringify(decryptedData),
            {
              status: response.status,
              statusText: response.statusText,
              headers: response.headers
            }
          );
        }
        
        return response;
      } catch (error) {
        console.error('[Service Worker] å¤„ç†å¤±è´¥:', error);
        // é™çº§ï¼šç›´æ¥è¯·æ±‚
        return fetch(request);
      }
    })()
  );
});

self.addEventListener('install', (event) => {
  console.log('[Service Worker] å®‰è£…ä¸­...');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('[Service Worker] æ¿€æ´»ä¸­...');
  event.waitUntil(self.clients.claim());
});
```

---

## ğŸ¥‰ æ–¹æ¡ˆ3ï¼šç»„åˆæ–¹æ¡ˆï¼ˆMonkey Patch + Service Workerï¼‰

### åŒé‡ä¿éšœ

```javascript
/**
 * ç»„åˆæ–¹æ¡ˆä¼˜åŠ¿ï¼š
 * 
 * 1. Monkey Patch æ‹¦æˆªåŒæ­¥è¯·æ±‚å’Œé¡µé¢å†…è¯·æ±‚
 * 2. Service Worker æ‹¦æˆªæ‰€æœ‰è¯·æ±‚ï¼ˆåŒ…æ‹¬è·¨åŸŸã€å›¾ç‰‡ç­‰ï¼‰
 * 3. åŒé‡ä¿éšœï¼Œè¦†ç›–æ‰€æœ‰åœºæ™¯
 */

// åœ¨å…¥å£æ–‡ä»¶æœ€é¡¶éƒ¨
import './crypto-interceptor.js';  // Monkey Patch

// æ³¨å†Œ Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/crypto-service-worker.js');
}
```

---

## ğŸ”§ æœåŠ¡å™¨ç«¯é…åˆ

### æœåŠ¡å™¨ç«¯ä¹Ÿéœ€è¦ç›¸åº”æ”¹é€ 

```javascript
// ============================================
// Node.js / Express æœåŠ¡å™¨ç«¯
// ============================================
const express = require('express');
const app = express();

// åŠ å¯†å·¥å…·ï¼ˆä¸å‰ç«¯ä¿æŒä¸€è‡´ï¼‰
class ServerCryptoUtil {
  static secretKey = 'your-secret-key-2024';
  
  static encrypt(data) {
    // ä½¿ç”¨ Node.js crypto æ¨¡å—
    const crypto = require('crypto');
    const algorithm = 'aes-256-gcm';
    const key = crypto.scryptSync(this.secretKey, 'salt', 32);
    const iv = crypto.randomBytes(12);
    
    const cipher = crypto.createCipheriv(algorithm, key, iv);
    let encrypted = cipher.update(
      typeof data === 'string' ? data : JSON.stringify(data),
      'utf8',
      'base64'
    );
    encrypted += cipher.final('base64');
    
    const authTag = cipher.getAuthTag();
    
    // ç»„åˆ IV + AuthTag + åŠ å¯†æ•°æ®
    return Buffer.concat([iv, authTag, Buffer.from(encrypted, 'base64')])
      .toString('base64');
  }
  
  static decrypt(encryptedData) {
    const crypto = require('crypto');
    const algorithm = 'aes-256-gcm';
    const key = crypto.scryptSync(this.secretKey, 'salt', 32);
    
    const buffer = Buffer.from(encryptedData, 'base64');
    const iv = buffer.slice(0, 12);
    const authTag = buffer.slice(12, 28);
    const encrypted = buffer.slice(28);
    
    const decipher = crypto.createDecipheriv(algorithm, key, iv);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, null, 'utf8');
    decrypted += decipher.final('utf8');
    
    try {
      return JSON.parse(decrypted);
    } catch {
      return decrypted;
    }
  }
}

// è§£å¯†ä¸­é—´ä»¶
app.use((req, res, next) => {
  // æ£€æŸ¥æ˜¯å¦æ˜¯åŠ å¯†è¯·æ±‚
  if (req.headers['x-encrypted'] === 'true') {
    let body = '';
    
    req.on('data', chunk => {
      body += chunk.toString();
    });
    
    req.on('end', () => {
      try {
        const parsed = JSON.parse(body);
        
        if (parsed.encrypted) {
          console.log('[æœåŠ¡å™¨] è§£å¯†è¯·æ±‚');
          const decrypted = ServerCryptoUtil.decrypt(parsed.encrypted);
          
          // æ›¿æ¢ req.body
          req.body = decrypted;
        }
      } catch (error) {
        console.error('[æœåŠ¡å™¨] è§£å¯†å¤±è´¥:', error);
      }
      
      next();
    });
  } else {
    next();
  }
});

// åŠ å¯†å“åº”ä¸­é—´ä»¶
function encryptResponse(req, res, next) {
  // ä¿å­˜åŸå§‹ json æ–¹æ³•
  const originalJson = res.json;
  
  res.json = function(data) {
    // æ£€æŸ¥è¯·æ±‚æ˜¯å¦è¦æ±‚åŠ å¯†
    if (req.headers['x-encrypted'] === 'true') {
      console.log('[æœåŠ¡å™¨] åŠ å¯†å“åº”');
      
      const encrypted = ServerCryptoUtil.encrypt(data);
      
      res.setHeader('X-Encrypted', 'true');
      res.setHeader('Content-Type', 'application/json');
      
      return res.send(encrypted);
    }
    
    // æ­£å¸¸å“åº”
    return originalJson.call(this, data);
  };
  
  next();
}

app.use(encryptResponse);

// ä¸šåŠ¡è·¯ç”±
app.post('/api/user', (req, res) => {
  // req.body å·²ç»è‡ªåŠ¨è§£å¯†
  console.log('æ”¶åˆ°ç”¨æˆ·æ•°æ®:', req.body);
  
  // è¿”å›æ•°æ®ä¼šè‡ªåŠ¨åŠ å¯†
  res.json({
    success: true,
    user: { id: 1, name: 'John' }
  });
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

---

## ğŸ¨ å®Œæ•´é¡¹ç›®ç»“æ„

```
project/
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ crypto-interceptor.js        # å‰ç«¯æ‹¦æˆªå™¨ï¼ˆMonkey Patchï¼‰
â”‚   â”œâ”€â”€ crypto-service-worker.js     # Service Worker æ‹¦æˆªå™¨
â”‚   â””â”€â”€ app.js                        # ä¸šåŠ¡ä»£ç ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ index.js                      # æœåŠ¡å™¨å…¥å£
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â””â”€â”€ crypto.js                 # åŠ è§£å¯†ä¸­é—´ä»¶
â”‚   â””â”€â”€ routes/
â”‚       â””â”€â”€ api.js                    # API è·¯ç”±
â””â”€â”€ shared/
    â””â”€â”€ crypto-config.js              # åŠ å¯†é…ç½®ï¼ˆå‰åç«¯å…±äº«ï¼‰
```

---

## ğŸ” åŠ å¯†æ–¹æ¡ˆé€‰æ‹©

### æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | å®‰å…¨æ€§ | æ€§èƒ½ | å…¼å®¹æ€§ | æ¨èåº¦ |
|------|-------|------|--------|--------|
| **Web Crypto API** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­â­ | âœ… æ¨è |
| **CryptoJS** | â­â­â­â­ | â­â­â­ | â­â­â­â­â­ | âœ… å¤‡é€‰ |
| **ç®€å• Base64** | â­ | â­â­â­â­â­ | â­â­â­â­â­ | âŒ ä¸æ¨è |

### ä½¿ç”¨ CryptoJSï¼ˆæ›´ç®€å•ï¼ŒåŒæ­¥ï¼‰

```javascript
// å¼•å…¥ CryptoJS
<script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.js"></script>

// åŠ å¯†å·¥å…·
class CryptoUtil {
  static secretKey = 'your-secret-key-2024';
  
  static encrypt(data) {
    const str = typeof data === 'string' ? data : JSON.stringify(data);
    return CryptoJS.AES.encrypt(str, this.secretKey).toString();
  }
  
  static decrypt(encryptedData) {
    const bytes = CryptoJS.AES.decrypt(encryptedData, this.secretKey);
    const decrypted = bytes.toString(CryptoJS.enc.Utf8);
    
    try {
      return JSON.parse(decrypted);
    } catch {
      return decrypted;
    }
  }
}

// ä¼˜ç‚¹ï¼šåŒæ­¥ APIï¼Œæ›´å®¹æ˜“ä¸ XMLHttpRequest é›†æˆ
// ç¼ºç‚¹ï¼šéœ€è¦é¢å¤–å¼•å…¥åº“ï¼ˆçº¦ 80KBï¼‰
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. é€‰æ‹©æ€§åŠ å¯†

```javascript
/**
 * åªåŠ å¯†æ•æ„Ÿæ•°æ®
 */
const encryptConfig = {
  // éœ€è¦åŠ å¯†çš„å­—æ®µ
  sensitiveFields: ['password', 'creditCard', 'ssn', 'token'],
  
  // éœ€è¦åŠ å¯†çš„ URL
  sensitiveUrls: ['/api/payment', '/api/user/profile'],
};

function shouldEncryptRequest(url, body) {
  // æ£€æŸ¥ URL
  if (encryptConfig.sensitiveUrls.some(u => url.includes(u))) {
    return true;
  }
  
  // æ£€æŸ¥å­—æ®µ
  if (body && typeof body === 'object') {
    return encryptConfig.sensitiveFields.some(field => field in body);
  }
  
  return false;
}

// åªåŠ å¯†æ•æ„Ÿå­—æ®µ
function encryptSensitiveFields(data) {
  if (typeof data !== 'object') return data;
  
  const result = { ...data };
  
  for (const field of encryptConfig.sensitiveFields) {
    if (field in result) {
      result[field] = CryptoUtil.encrypt(result[field]);
      result[`${field}_encrypted`] = true; // æ ‡è®°
    }
  }
  
  return result;
}
```

### 2. ç¼“å­˜åŠ å¯†å¯†é’¥

```javascript
class CryptoUtil {
  static _cachedKey = null;
  
  static async getKey() {
    // ç¼“å­˜å¯†é’¥ï¼Œé¿å…é‡å¤ç”Ÿæˆ
    if (this._cachedKey) {
      return this._cachedKey;
    }
    
    this._cachedKey = await this.deriveKey(this.secretKey);
    return this._cachedKey;
  }
}
```

### 3. ä½¿ç”¨ Web Worker åŠ å¯†

```javascript
/**
 * å°†åŠ å¯†æ“ä½œæ”¾åˆ° Web Worker ä¸­ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
 */

// crypto-worker.js
self.addEventListener('message', async (e) => {
  const { action, data, id } = e.data;
  
  if (action === 'encrypt') {
    const encrypted = await encrypt(data);
    self.postMessage({ id, result: encrypted });
  } else if (action === 'decrypt') {
    const decrypted = await decrypt(data);
    self.postMessage({ id, result: decrypted });
  }
});

// ä¸»çº¿ç¨‹ä½¿ç”¨
const cryptoWorker = new Worker('/crypto-worker.js');
const pendingTasks = new Map();
let taskId = 0;

function encryptAsync(data) {
  return new Promise((resolve) => {
    const id = taskId++;
    pendingTasks.set(id, resolve);
    cryptoWorker.postMessage({ action: 'encrypt', data, id });
  });
}

cryptoWorker.addEventListener('message', (e) => {
  const { id, result } = e.data;
  const resolve = pendingTasks.get(id);
  if (resolve) {
    resolve(result);
    pendingTasks.delete(id);
  }
});
```

---

## ğŸ¯ æœ€å°ä¾µå…¥å®ç°ï¼ˆæ¨èæ–¹æ¡ˆï¼‰

### ä¸€è¡Œä»£ç é›†æˆ

```html
<!DOCTYPE html>
<html>
<head>
  <!-- åªéœ€æ·»åŠ è¿™ä¸€è¡Œï¼Œæ”¾åœ¨æ‰€æœ‰è„šæœ¬ä¹‹å‰ -->
  <script src="/crypto-shield.min.js" data-key="your-secret-key"></script>
  
  <!-- ç¬¬ä¸‰æ–¹åº“ -->
  <script src="https://cdn.com/axios.min.js"></script>
  <script src="https://cdn.com/jquery.min.js"></script>
  
  <!-- ä¸šåŠ¡ä»£ç  -->
  <script src="/app.js"></script>
</head>
<body>
  <!-- ä¸šåŠ¡ä»£ç å®Œå…¨æ— éœ€ä¿®æ”¹ï¼ -->
</body>
</html>
```

### crypto-shield.js å°è£…

```javascript
/**
 * ============================================
 * Crypto Shield - é›¶ä¾µå…¥åŠ å¯†ä¼ è¾“æ–¹æ¡ˆ
 * ============================================
 * 
 * ä½¿ç”¨æ–¹å¼ï¼š
 * <script src="crypto-shield.js" data-key="your-key"></script>
 */

(function(global) {
  'use strict';
  
  // ä» script æ ‡ç­¾è¯»å–é…ç½®
  const currentScript = document.currentScript;
  const SECRET_KEY = currentScript?.getAttribute('data-key') || 'default-key';
  const ENCRYPT_URLS = (currentScript?.getAttribute('data-urls') || '/api/').split(',');
  
  // åŠ å¯†å·¥å…·
  const Crypto = {
    encrypt: (data) => {
      // å®ç°åŠ å¯†é€»è¾‘
      const str = typeof data === 'string' ? data : JSON.stringify(data);
      return btoa(encodeURIComponent(str)); // ç®€åŒ–ç‰ˆï¼Œå®é™…ä½¿ç”¨ AES
    },
    
    decrypt: (data) => {
      try {
        const decoded = decodeURIComponent(atob(data));
        return JSON.parse(decoded);
      } catch {
        return decodeURIComponent(atob(data));
      }
    }
  };
  
  // åˆ¤æ–­æ˜¯å¦éœ€è¦åŠ å¯†
  const shouldEncrypt = (url) => {
    return ENCRYPT_URLS.some(pattern => url.includes(pattern));
  };
  
  // ==================== Fetch æ‹¦æˆª ====================
  const originalFetch = global.fetch;
  global.fetch = async function(url, options = {}) {
    if (shouldEncrypt(url) && options.body) {
      options = {
        ...options,
        body: JSON.stringify({ encrypted: Crypto.encrypt(options.body) }),
        headers: { ...options.headers, 'X-Encrypted': 'true' }
      };
    }
    
    const response = await originalFetch(url, options);
    
    if (response.headers.get('X-Encrypted') === 'true') {
      const encrypted = await response.text();
      const decrypted = Crypto.decrypt(encrypted);
      
      return new Response(
        typeof decrypted === 'string' ? decrypted : JSON.stringify(decrypted),
        {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        }
      );
    }
    
    return response;
  };
  
  // ==================== XHR æ‹¦æˆª ====================
  const OriginalXHR = global.XMLHttpRequest;
  
  global.XMLHttpRequest = function() {
    const xhr = new OriginalXHR();
    const originalSend = xhr.send;
    const originalOpen = xhr.open;
    
    let url = '';
    
    xhr.open = function(method, _url, ...args) {
      url = _url;
      return originalOpen.apply(this, [method, _url, ...args]);
    };
    
    xhr.send = function(body) {
      if (shouldEncrypt(url) && body) {
        const encrypted = Crypto.encrypt(body);
        this.setRequestHeader('X-Encrypted', 'true');
        this.setRequestHeader('Content-Type', 'application/json');
        return originalSend.call(this, JSON.stringify({ encrypted }));
      }
      return originalSend.apply(this, arguments);
    };
    
    return xhr;
  };
  
  global.XMLHttpRequest.prototype = OriginalXHR.prototype;
  
  console.log('ğŸ›¡ï¸ Crypto Shield å·²æ¿€æ´»');
  
})(window);
```

---

## ğŸ“Š æ–¹æ¡ˆå¯¹æ¯”æ€»ç»“

### ä¾µå…¥æ€§å¯¹æ¯”

```javascript
// âŒ é«˜ä¾µå…¥æ€§ï¼ˆéœ€è¦ä¿®æ”¹æ¯ä¸ªè¯·æ±‚ï¼‰
fetch('/api/data', {
  body: encrypt(JSON.stringify(data))  // æ‰‹åŠ¨åŠ å¯†
})
.then(res => res.text())
.then(encrypted => decrypt(encrypted)); // æ‰‹åŠ¨è§£å¯†

// âœ… é›¶ä¾µå…¥æ€§ï¼ˆè‡ªåŠ¨åŠ å¯†è§£å¯†ï¼‰
fetch('/api/data', {
  body: JSON.stringify(data)  // æ­£å¸¸ä½¿ç”¨
})
.then(res => res.json())
.then(data => console.log(data)); // è‡ªåŠ¨è§£å¯†
```

### æŠ€æœ¯é€‰å‹å»ºè®®

| åœºæ™¯ | æ¨èæ–¹æ¡ˆ | ç†ç”± |
|------|---------|------|
| **çº¯æµè§ˆå™¨åº”ç”¨** | Monkey Patch | ç®€å•ï¼Œä¸éœ€è¦ SW |
| **PWA / ç¦»çº¿åº”ç”¨** | Service Worker | å·²æœ‰ SWï¼Œé¡ºä¾¿åŠ å¯† |
| **å¤æ‚åº”ç”¨** | ç»„åˆæ–¹æ¡ˆ | åŒé‡ä¿éšœ |
| **å¿«é€Ÿæ”¹é€ ** | Crypto Shield | ä¸€è¡Œä»£ç é›†æˆ |

---

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. å¯†é’¥ç®¡ç†

```javascript
// âŒ ä¸è¦ç¡¬ç¼–ç å¯†é’¥
const SECRET_KEY = 'hardcoded-key-123';

// âœ… ä»æœåŠ¡å™¨åŠ¨æ€è·å–
async function initCrypto() {
  const response = await fetch('/api/get-encryption-key', {
    credentials: 'include' // æºå¸¦è®¤è¯ä¿¡æ¯
  });
  const { key, timestamp } = await response.json();
  
  CryptoUtil.secretKey = key;
  CryptoUtil.keyTimestamp = timestamp;
}

// âœ… å®šæœŸæ›´æ–°å¯†é’¥
setInterval(async () => {
  await initCrypto();
}, 3600000); // æ¯å°æ—¶æ›´æ–°
```

### 2. æ€§èƒ½è€ƒè™‘

```javascript
/**
 * å¤§æ–‡ä»¶ä¸è¦å…¨é‡åŠ å¯†
 */
function smartEncrypt(data) {
  // å¦‚æœæ•°æ®å¤ªå¤§ï¼ŒåªåŠ å¯†æ•æ„Ÿéƒ¨åˆ†
  if (JSON.stringify(data).length > 100000) { // 100KB
    return {
      ...data,
      sensitiveField: encrypt(data.sensitiveField)
    };
  }
  
  return encrypt(data);
}
```

### 3. é™çº§ç­–ç•¥

```javascript
/**
 * å¦‚æœåŠ å¯†å¤±è´¥ï¼Œæœ‰é™çº§æ–¹æ¡ˆ
 */
window.CRYPTO_ENABLED = true;

window.addEventListener('error', (e) => {
  if (e.message.includes('crypto')) {
    console.warn('âš ï¸ åŠ å¯†æ¨¡å—å¼‚å¸¸ï¼Œé™çº§ä¸ºéåŠ å¯†æ¨¡å¼');
    window.CRYPTO_ENABLED = false;
  }
});

function encrypt(data) {
  if (!window.CRYPTO_ENABLED) {
    return data; // é™çº§
  }
  return CryptoUtil.encrypt(data);
}
```

---

## ğŸ“ æ€»ç»“

### æœ€ä½³å®è·µæ–¹æ¡ˆ

**æ¨èï¼šMonkey Patch + é…ç½®åŒ–**

```
1ï¸âƒ£ åœ¨å…¥å£ HTML æœ€é¡¶éƒ¨å¼•å…¥æ‹¦æˆªå™¨
   <script src="/crypto-interceptor.js"></script>

2ï¸âƒ£ æ‹¦æˆªå™¨è‡ªåŠ¨å¤„ç†æ‰€æœ‰ fetch/XHR è¯·æ±‚

3ï¸âƒ£ ä¸šåŠ¡ä»£ç å’Œç¬¬ä¸‰æ–¹åº“æ— éœ€ä»»ä½•ä¿®æ”¹

4ï¸âƒ£ é€šè¿‡é…ç½®æ§åˆ¶å“ªäº› URL éœ€è¦åŠ å¯†
```

### å®æ–½æ­¥éª¤

```
1. âœ… åˆ›å»º crypto-interceptor.js
2. âœ… åœ¨ index.html æœ€é¡¶éƒ¨å¼•å…¥
3. âœ… é…ç½®éœ€è¦åŠ å¯†çš„ URL è§„åˆ™
4. âœ… æœåŠ¡å™¨ç«¯æ·»åŠ è§£å¯†ä¸­é—´ä»¶
5. âœ… æµ‹è¯•å„ä¸ªåŠŸèƒ½ï¼ˆfetchã€axiosã€jQuery ç­‰ï¼‰
6. âœ… éƒ¨ç½²ä¸Šçº¿
```

### æ ¸å¿ƒä¼˜åŠ¿

- âœ… **é›¶ä¾µå…¥**ï¼šä¸šåŠ¡ä»£ç æ— éœ€ä¿®æ”¹
- âœ… **å…¨è¦†ç›–**ï¼šæ‹¦æˆªæ‰€æœ‰ç½‘ç»œè¯·æ±‚
- âœ… **ç¬¬ä¸‰æ–¹å…¼å®¹**ï¼šè‡ªåŠ¨å¤„ç†ç¬¬ä¸‰æ–¹åº“è¯·æ±‚
- âœ… **å¯é…ç½®**ï¼šçµæ´»æ§åˆ¶åŠ å¯†è§„åˆ™
- âœ… **å¯é™çº§**ï¼šåŠ å¯†å¤±è´¥æ—¶è‡ªåŠ¨é™çº§

è¿™ä¸ªæ–¹æ¡ˆå¯ä»¥åœ¨ä¸ä¿®æ”¹ä»»ä½•ç°æœ‰ä»£ç çš„æƒ…å†µä¸‹ï¼Œä¸ºæ•´ä¸ªç½‘ç«™æ·»åŠ ç«¯åˆ°ç«¯åŠ å¯†ï¼ğŸ”

