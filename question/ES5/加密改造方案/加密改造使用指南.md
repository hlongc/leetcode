# 网站加密改造 - 快速使用指南

## 🎯 改造目标

在不修改业务代码和第三方库的前提下，为所有网络请求添加端到端加密。

---

## 🚀 快速开始（3 步完成）

### 步骤 1：引入拦截器（前端）

在 `index.html` 的 `<head>` **最顶部**添加：

```html
<!DOCTYPE html>
<html>
  <head>
    <!-- ⚠️ 必须放在所有其他脚本之前！ -->
    <script
      src="/crypto-interceptor.js"
      data-key="your-secret-key-2024"
      data-urls="/api/,/user/,/payment/"
      data-debug="true"
    ></script>

    <!-- 第三方库（无需修改） -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>

    <!-- 业务代码（无需修改） -->
    <script src="/app.js"></script>
  </head>
  <body>
    <!-- 页面内容 -->
  </body>
</html>
```

### 步骤 2：服务器端中间件（Node.js）

```javascript
const express = require("express");
const {
  decryptRequestMiddleware,
  encryptResponseMiddleware,
} = require("./crypto-server");

const app = express();

// 应用中间件（在所有路由之前）
app.use(decryptRequestMiddleware);
app.use(encryptResponseMiddleware);

// 业务路由（无需修改！）
app.post("/api/login", (req, res) => {
  // req.body 已自动解密
  console.log("收到登录请求:", req.body);

  // 响应会自动加密
  res.json({ success: true, token: "abc123" });
});

app.listen(3000);
```

### 步骤 3：测试

```javascript
// 业务代码完全无需修改！

// 使用 fetch
fetch("/api/user", {
  method: "POST",
  body: JSON.stringify({ name: "John" }),
})
  .then((res) => res.json())
  .then((data) => console.log(data)); // 自动解密

// 使用 axios
axios.post("/api/user", { name: "John" }).then((res) => console.log(res.data)); // 自动解密

// 使用 jQuery
$.post("/api/user", { name: "John" }, (data) => {
  console.log(data); // 自动解密
});
```

---

## 📊 工作原理

### 原理图

```
业务代码/第三方库
      ↓
   fetch() / XHR
      ↓
  【拦截器】← 在这里拦截
      ↓
   加密请求体
      ↓
   发送到服务器
      ↓
   【服务器中间件】
      ↓
   解密请求体
      ↓
   业务处理
      ↓
   加密响应体
      ↓
   返回给客户端
      ↓
  【拦截器】
      ↓
   解密响应体
      ↓
业务代码/第三方库
   （完全透明）
```

### 核心技术：Monkey Patching

```javascript
// 在全局对象加载前，替换原生 API
const originalFetch = window.fetch;

window.fetch = async function (...args) {
  // 加密逻辑
  const [url, options] = args;
  if (options.body) {
    options.body = encrypt(options.body);
  }

  // 调用原始 fetch
  const response = await originalFetch(...args);

  // 解密逻辑
  const decrypted = await decrypt(response);

  return decrypted;
};

// 之后所有代码（包括第三方库）调用的都是新的 fetch
```

---

## 🔧 配置选项

### data-key（密钥）

```html
<script src="crypto-interceptor.js" data-key="my-secret-key-2024"></script>
```

**建议**：

- ✅ 从服务器动态获取密钥
- ✅ 定期更新密钥
- ❌ 不要硬编码在代码中

### data-urls（需要加密的 URL）

```html
<!-- 单个 URL -->
<script data-urls="/api/"></script>

<!-- 多个 URL（逗号分隔） -->
<script data-urls="/api/,/user/,/payment/"></script>
```

### data-debug（调试模式）

```html
<script data-debug="true"></script>
```

开启后会在控制台输出详细日志。

---

## 📁 文件说明

### 提供的文件

```
crypto-interceptor.js           # 简化版（适合快速测试）
crypto-interceptor-secure.js    # 安全版（使用 Web Crypto API）
crypto-server.js                # 服务器端中间件
crypto-demo.html                # 完整测试示例
网络加密改造方案.md              # 详细设计文档
```

### 选择哪个版本？

| 文件                           | 加密算法    | 性能       | 安全性     | 推荐场景 |
| ------------------------------ | ----------- | ---------- | ---------- | -------- |
| `crypto-interceptor.js`        | 简化版      | ⭐⭐⭐⭐⭐ | ⭐⭐       | 开发测试 |
| `crypto-interceptor-secure.js` | AES-256-GCM | ⭐⭐⭐⭐   | ⭐⭐⭐⭐⭐ | 生产环境 |

---

## ✅ 优势

### 1. 零侵入

```javascript
// ❌ 传统方式：需要修改所有请求代码
const data = encrypt({ name: "John" });
fetch("/api/user", { body: data });

// ✅ 使用拦截器：业务代码完全不变
fetch("/api/user", {
  body: JSON.stringify({ name: "John" }),
});
// 自动加密！
```

### 2. 第三方库兼容

```javascript
// Axios、jQuery、其他所有库都无需修改

// Axios
axios.post("/api/data", { foo: "bar" }); // ✅ 自动加密

// jQuery
$.post("/api/data", { foo: "bar" }); // ✅ 自动加密

// Fetch
fetch("/api/data", {
  body: JSON.stringify({ foo: "bar" }),
}); // ✅ 自动加密
```

### 3. 可配置

```javascript
// 运行时修改配置
CryptoInterceptor.config.encryptUrls.push("/new-api/");

// 手动加密/解密
const encrypted = await CryptoInterceptor.encrypt("data");
const decrypted = await CryptoInterceptor.decrypt(encrypted);
```

---

## ⚠️ 注意事项

### 1. 脚本加载顺序

```html
<!-- ✅ 正确顺序 -->
<script src="crypto-interceptor.js"></script>
<!-- 第1个 -->
<script src="axios.min.js"></script>
<!-- 之后 -->
<script src="app.js"></script>
<!-- 最后 -->

<!-- ❌ 错误顺序 -->
<script src="axios.min.js"></script>
<!-- axios 先加载 -->
<script src="crypto-interceptor.js"></script>
<!-- 拦截器后加载 -->
<!-- 结果：axios 使用的是原始 fetch，不会被加密 -->
```

### 2. 同步 XHR 的限制

```javascript
// ⚠️ 同步 XHR 无法使用 Web Crypto API（异步的）
const xhr = new XMLHttpRequest();
xhr.open("GET", "/api/data", false); // false = 同步
xhr.send();

// 解决方案：
// 1. 使用异步请求（推荐）
// 2. 对同步请求使用同步加密算法
```

### 3. 跨域请求

```javascript
// 需要服务器支持 CORS 并暴露自定义头
res.header("Access-Control-Allow-Origin", "*");
res.header("Access-Control-Allow-Headers", "X-Encrypted");
res.header("Access-Control-Expose-Headers", "X-Encrypted");
```

### 4. 密钥管理

```javascript
// ❌ 不要硬编码
<script data-key="hardcoded-key-123"></script>

// ✅ 从服务器获取
<script>
  // 先获取密钥
  fetch('/api/get-encryption-key')
    .then(res => res.json())
    .then(({ key }) => {
      // 动态设置密钥
      CryptoInterceptor.config.secretKey = key;

      // 然后加载应用
      loadApp();
    });
</script>
```

---

## 🧪 测试清单

### 测试项目

- [ ] ✅ Fetch API 请求是否加密
- [ ] ✅ XMLHttpRequest 请求是否加密
- [ ] ✅ Axios 请求是否加密（第三方库）
- [ ] ✅ jQuery $.ajax 是否加密（第三方库）
- [ ] ✅ 响应是否正确解密
- [ ] ✅ 非加密 URL 是否正常访问
- [ ] ✅ 并发请求是否正常
- [ ] ✅ 错误处理是否正确
- [ ] ✅ 服务器端是否能正确解密
- [ ] ✅ 性能是否满足要求

### 测试代码

```javascript
// 在浏览器控制台运行

// 测试1：检查拦截器是否安装
console.log("拦截器:", window.CryptoInterceptor ? "✅ 已安装" : "❌ 未安装");

// 测试2：测试 Fetch
fetch("/api/test", {
  method: "POST",
  body: JSON.stringify({ test: "data" }),
})
  .then((res) => res.json())
  .then((data) => console.log("Fetch 结果:", data));

// 测试3：测试 Axios
axios
  .post("/api/test", { test: "data" })
  .then((res) => console.log("Axios 结果:", res.data));

// 测试4：查看网络请求
// 打开 DevTools → Network → 查看请求体
// 应该看到加密的数据，而不是明文
```

---

## 📈 性能影响

### 加密开销

```javascript
/**
 * 典型性能数据（1KB 数据）
 *
 * 简化版加密：    ~1-2ms
 * AES-GCM 加密：  ~5-10ms
 * 网络传输：      ~50-200ms
 *
 * 结论：加密开销占比很小（<5%）
 */

// 性能测试
async function performanceTest() {
  const data = { test: "x".repeat(1000) }; // 1KB

  console.time("加密");
  const encrypted = await CryptoInterceptor.encrypt(data);
  console.timeEnd("加密"); // ~5-10ms

  console.time("解密");
  const decrypted = await CryptoInterceptor.decrypt(encrypted);
  console.timeEnd("解密"); // ~5-10ms

  console.time("完整请求");
  await fetch("/api/test", {
    method: "POST",
    body: JSON.stringify(data),
  });
  console.timeEnd("完整请求"); // ~50-200ms
}
```

---

## 🔒 安全建议

### 1. 使用安全版本（生产环境）

```html
<!-- 开发环境：简化版 -->
<script src="crypto-interceptor.js"></script>

<!-- 生产环境：安全版 -->
<script src="crypto-interceptor-secure.js"></script>
```

### 2. 密钥轮换

```javascript
// 定期更新密钥
setInterval(async () => {
  const { key } = await fetch("/api/get-new-key").then((r) => r.json());
  CryptoInterceptor.config.secretKey = key;
}, 3600000); // 每小时
```

### 3. 降级策略

```javascript
// 如果加密失败，降级为非加密模式
window.addEventListener("error", (e) => {
  if (e.message.includes("encrypt")) {
    console.warn("⚠️ 加密失败，降级为非加密模式");
    CryptoInterceptor.config.encryptUrls = []; // 禁用加密
  }
});
```

---

## 📋 完整改造检查清单

### 前端改造

- [ ] ✅ 在 HTML 顶部引入 `crypto-interceptor.js`
- [ ] ✅ 配置密钥和需要加密的 URL
- [ ] ✅ 确保拦截器在所有脚本之前加载
- [ ] ✅ 测试 fetch、XHR、axios、jQuery 等

### 服务器端改造

- [ ] ✅ 引入解密中间件
- [ ] ✅ 引入加密中间件
- [ ] ✅ 配置相同的密钥
- [ ] ✅ 在路由之前应用中间件
- [ ] ✅ 测试请求解密和响应加密

### 测试验证

- [ ] ✅ 使用 Chrome DevTools 查看网络请求
- [ ] ✅ 确认请求体是加密的（看不到明文）
- [ ] ✅ 确认响应体是加密的
- [ ] ✅ 确认业务逻辑正常工作
- [ ] ✅ 测试第三方库是否正常工作

---

## 🎨 高级用法

### 选择性加密字段

```javascript
// 只加密敏感字段
function smartEncrypt(data) {
  const sensitiveFields = ["password", "creditCard", "ssn"];

  const encrypted = {};
  for (const [key, value] of Object.entries(data)) {
    if (sensitiveFields.includes(key)) {
      encrypted[key] = CryptoInterceptor.encrypt(value);
      encrypted[`${key}_encrypted`] = true;
    } else {
      encrypted[key] = value; // 不加密
    }
  }

  return encrypted;
}
```

### 动态配置

```javascript
// 运行时添加需要加密的 URL
CryptoInterceptor.addEncryptUrl("/sensitive-api/");

// 运行时移除
CryptoInterceptor.removeEncryptUrl("/api/public/");

// 临时禁用加密
const originalUrls = [...CryptoInterceptor.config.encryptUrls];
CryptoInterceptor.config.encryptUrls = [];

// 发送请求...

// 恢复
CryptoInterceptor.config.encryptUrls = originalUrls;
```

### 与现有拦截器配合

```javascript
// 如果项目已有 axios 拦截器
axios.interceptors.request.use((config) => {
  // 你的业务逻辑
  config.headers["X-Custom"] = "value";

  // 加密逻辑已经在底层 fetch/XHR 处理
  return config;
});

// 完全兼容！
```

---

## 🐛 故障排查

### 问题 1：请求没有被加密

**检查**：

```javascript
// 1. 拦截器是否加载？
console.log(window.CryptoInterceptor); // 应该有值

// 2. URL 是否匹配规则？
const url = "/api/test";
console.log(CryptoInterceptor.shouldEncrypt(url)); // 应该返回 true

// 3. 脚本加载顺序是否正确？
// 拦截器必须最先加载
```

### 问题 2：响应解密失败

**检查**：

```javascript
// 1. 服务器是否返回了 X-Encrypted 头？
// 查看 Network 标签，检查响应头

// 2. 密钥是否一致？
// 前端和服务器端必须使用相同密钥

// 3. 加密算法是否一致？
// 前端和服务器端必须使用相同算法
```

### 问题 3：第三方库请求没有加密

**原因**：第三方库在拦截器之前加载

**解决**：

```html
<!-- ✅ 正确 -->
<script src="crypto-interceptor.js"></script>
<script src="third-party-lib.js"></script>

<!-- ❌ 错误 -->
<script src="third-party-lib.js"></script>
<script src="crypto-interceptor.js"></script>
```

---

## 💡 最佳实践

### 1. 使用环境变量

```javascript
// 开发环境
const isDev = process.env.NODE_ENV === "development";

if (isDev) {
  // 开发环境使用固定密钥
  CONFIG.secretKey = "dev-key-2024";
} else {
  // 生产环境从服务器获取
  fetch("/api/get-encryption-key")
    .then((res) => res.json())
    .then(({ key }) => {
      CONFIG.secretKey = key;
    });
}
```

### 2. 错误监控

```javascript
// 监控加密失败
window.addEventListener("error", (e) => {
  if (e.message.includes("encrypt") || e.message.includes("decrypt")) {
    // 上报到错误监控系统
    reportError({
      type: "crypto-error",
      message: e.message,
      url: window.location.href,
    });
  }
});
```

### 3. 性能监控

```javascript
// 监控加密耗时
let encryptionTime = 0;
let requestCount = 0;

// 在拦截器中添加
console.time("encrypt");
const encrypted = await encrypt(data);
console.timeEnd("encrypt");

// 定期上报
setInterval(() => {
  if (requestCount > 0) {
    console.log(`平均加密耗时: ${encryptionTime / requestCount}ms`);
  }
}, 60000);
```

---

## 📚 总结

### 核心优势

✅ **零侵入**：业务代码无需修改  
✅ **全覆盖**：拦截所有网络请求  
✅ **第三方兼容**：自动处理第三方库  
✅ **透明加密**：对开发者完全透明  
✅ **易于部署**：只需添加一行脚本

### 实施步骤

```
1. 前端：引入 crypto-interceptor.js（1分钟）
2. 服务器：添加中间件（5分钟）
3. 配置：设置密钥和 URL 规则（2分钟）
4. 测试：验证加密是否生效（10分钟）
5. 部署：上线（1分钟）

总计：约 20 分钟完成改造！
```

### 完美！🎉

这个方案可以在**不修改一行业务代码**的情况下，为整个网站添加端到端加密！
