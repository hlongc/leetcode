# 127.0.0.1 vs 0.0.0.0 详解

## 🎯 核心区别

| 地址 | 含义 | 监听范围 | 访问方式 |
|------|------|---------|---------|
| **127.0.0.1** | 本地回环地址 | 仅本机 | 只能 localhost 或 127.0.0.1 |
| **0.0.0.0** | 所有网络接口 | 本机所有网卡 | localhost、本机IP、外网IP |

---

## 📖 详细解释

### 127.0.0.1（本地回环）

```javascript
/**
 * 监听 127.0.0.1
 */

// Node.js 示例
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello World');
});

// 监听 127.0.0.1
app.listen(3000, '127.0.0.1', () => {
  console.log('服务器运行在 http://127.0.0.1:3000');
});

/**
 * 可访问的方式：
 * ✅ http://127.0.0.1:3000        （可以）
 * ✅ http://localhost:3000        （可以，localhost → 127.0.0.1）
 * 
 * ❌ http://192.168.1.100:3000    （不可以！）
 * ❌ 手机/其他设备访问              （不可以！）
 * 
 * 特点：
 * - 只监听本地回环接口（loopback）
 * - 数据包不会离开本机
 * - 更安全（其他设备无法访问）
 * - 用于纯本地开发
 */
```

### 0.0.0.0（所有接口）

```javascript
/**
 * 监听 0.0.0.0
 */

// Node.js 示例
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Hello World');
});

// 监听 0.0.0.0（所有网络接口）
app.listen(3000, '0.0.0.0', () => {
  console.log('服务器运行在 http://0.0.0.0:3000');
});

/**
 * 可访问的方式：
 * ✅ http://127.0.0.1:3000        （本地回环）
 * ✅ http://localhost:3000        （本地回环）
 * ✅ http://192.168.1.100:3000    （本机局域网 IP）
 * ✅ http://10.0.0.5:3000         （另一个网卡 IP）
 * ✅ http://公网IP:3000            （如果有公网 IP）
 * ✅ 手机通过局域网访问             （可以！）
 * 
 * 特点：
 * - 监听所有网络接口
 * - 其他设备可以访问
 * - 用于需要局域网访问的场景
 * - 安全性较低（需要配置防火墙）
 */
```

---

## 🖧 网络接口详解

### 什么是网络接口？

```javascript
/**
 * 一台电脑可能有多个网络接口
 */
const networkInterfaces = {
  // 本地回环接口
  loopback: {
    name: 'lo0 (Mac/Linux) 或 Loopback (Windows)',
    ip: '127.0.0.1',
    purpose: '本机内部通信',
    physical: '❌ 非物理网卡，虚拟接口',
    range: '127.0.0.0/8 (127.0.0.1 - 127.255.255.255)'
  },
  
  // 以太网接口（有线网卡）
  ethernet: {
    name: 'en0 (Mac) 或 eth0 (Linux)',
    ip: '192.168.1.100 (局域网 IP)',
    purpose: '连接路由器/交换机',
    physical: '✅ 物理网卡'
  },
  
  // WiFi 接口（无线网卡）
  wifi: {
    name: 'en1 (Mac) 或 wlan0 (Linux)',
    ip: '192.168.1.101',
    purpose: '无线网络',
    physical: '✅ 物理网卡'
  },
  
  // 虚拟接口（Docker/VM）
  virtual: {
    name: 'docker0, veth0',
    ip: '172.17.0.1',
    purpose: '容器/虚拟机通信',
    physical: '❌ 虚拟网卡'
  }
};

// 查看本机网络接口
// Mac/Linux:
// ifconfig

// Windows:
// ipconfig

/**
 * 典型输出（Mac）:
 * 
 * lo0: 127.0.0.1              ← 回环接口
 * en0: 192.168.1.100          ← 有线网卡
 * en1: 192.168.1.101          ← WiFi 网卡
 */
```

### 监听地址的含义

```javascript
const listenAddresses = {
  // 127.0.0.1 - 只监听回环接口
  localhost: {
    bind: '127.0.0.1',
    interfaces: ['lo0 (回环)'],
    accessible: [
      '✅ 127.0.0.1',
      '✅ localhost',
      '❌ 192.168.1.100',
      '❌ 其他设备'
    ]
  },
  
  // 具体 IP - 只监听指定网卡
  specificIP: {
    bind: '192.168.1.100',
    interfaces: ['en0 (指定网卡)'],
    accessible: [
      '❌ 127.0.0.1',
      '❌ localhost',
      '✅ 192.168.1.100',
      '✅ 同局域网的其他设备'
    ]
  },
  
  // 0.0.0.0 - 监听所有接口
  allInterfaces: {
    bind: '0.0.0.0',
    interfaces: ['lo0', 'en0', 'en1', '所有网卡'],
    accessible: [
      '✅ 127.0.0.1',
      '✅ localhost',
      '✅ 192.168.1.100',
      '✅ 192.168.1.101',
      '✅ 公网 IP（如果有）',
      '✅ 同局域网的所有设备'
    ]
  }
};
```

---

## 💻 实际代码示例

### Node.js / Express

```javascript
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send(`
    <h1>服务器信息</h1>
    <p>请求来自: ${req.ip}</p>
    <p>Host: ${req.headers.host}</p>
  `);
});

// ============================================
// 场景1：只允许本机访问（开发环境）
// ============================================
app.listen(3000, '127.0.0.1', () => {
  console.log('只能本机访问:');
  console.log('  ✅ http://127.0.0.1:3000');
  console.log('  ✅ http://localhost:3000');
  console.log('  ❌ http://192.168.1.100:3000 (不可访问)');
});

// ============================================
// 场景2：允许局域网访问（团队协作）
// ============================================
app.listen(3000, '0.0.0.0', () => {
  console.log('可以多种方式访问:');
  console.log('  ✅ http://localhost:3000');
  console.log('  ✅ http://127.0.0.1:3000');
  console.log('  ✅ http://192.168.1.100:3000');
  console.log('  ✅ 手机访问: http://192.168.1.100:3000');
});

// ============================================
// 场景3：不指定地址（默认行为）
// ============================================
app.listen(3000, () => {
  // 大多数框架默认是 0.0.0.0 或 ::（IPv6 的所有接口）
  console.log('服务器运行在端口 3000');
  console.log('默认行为取决于框架实现');
});

// ============================================
// 场景4：只监听特定网卡
// ============================================
app.listen(3000, '192.168.1.100', () => {
  console.log('只通过指定网卡访问:');
  console.log('  ❌ http://localhost:3000 (不可访问)');
  console.log('  ✅ http://192.168.1.100:3000');
});
```

### Python / Flask

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return 'Hello World'

# 场景1：只允许本机（默认）
app.run(host='127.0.0.1', port=5000)
# 只能通过 localhost 访问

# 场景2：允许局域网
app.run(host='0.0.0.0', port=5000)
# 可以通过本机 IP 访问
```

### Nginx

```nginx
server {
    # 只监听本地
    listen 127.0.0.1:80;
    
    # 只能通过 http://127.0.0.1 访问
    # 其他设备无法访问
}

server {
    # 监听所有接口
    listen 0.0.0.0:80;
    # 或简写为
    listen 80;
    
    # 可以通过任何 IP 访问
}
```

---

## 🔍 实际测试

### 测试1：查看本机 IP

```bash
# Mac/Linux
ifconfig | grep "inet "

# 输出示例：
# inet 127.0.0.1 netmask 0xff000000      ← 回环地址
# inet 192.168.1.100 netmask 0xffffff00  ← 局域网 IP

# Windows
ipconfig

# 输出示例：
# IPv4 地址 . . . . . . . . . . . . : 192.168.1.100
```

### 测试2：验证监听地址

```bash
# 启动服务器后，查看监听状态

# Mac/Linux
netstat -an | grep LISTEN | grep 3000

# 输出示例：
tcp4  0  0  127.0.0.1.3000    *.*    LISTEN
# ↑ 只监听 127.0.0.1

tcp4  0  0  *.3000            *.*    LISTEN
# ↑ 监听所有接口（0.0.0.0）

# Windows
netstat -an | findstr :3000

# 查看具体进程
lsof -i :3000
```

### 测试3：实际访问测试

```javascript
/**
 * 创建测试服务器
 */

// test-server.js
const http = require('http');

// 测试 127.0.0.1
const server1 = http.createServer((req, res) => {
  res.end('Server on 127.0.0.1');
});

server1.listen(3000, '127.0.0.1', () => {
  console.log('服务器1 监听 127.0.0.1:3000');
  console.log('\n测试访问:');
  console.log('  在本机浏览器访问:');
  console.log('    ✅ http://127.0.0.1:3000');
  console.log('    ✅ http://localhost:3000');
  console.log('  在本机浏览器访问:');
  console.log('    ❌ http://192.168.1.100:3000 (拒绝连接)');
  console.log('  在手机浏览器访问:');
  console.log('    ❌ http://192.168.1.100:3000 (无法访问)');
});

// 测试 0.0.0.0
const server2 = http.createServer((req, res) => {
  res.end('Server on 0.0.0.0');
});

server2.listen(4000, '0.0.0.0', () => {
  console.log('\n服务器2 监听 0.0.0.0:4000');
  console.log('\n测试访问:');
  console.log('  在本机浏览器访问:');
  console.log('    ✅ http://127.0.0.1:4000');
  console.log('    ✅ http://localhost:4000');
  console.log('    ✅ http://192.168.1.100:4000');
  console.log('  在手机浏览器访问:');
  console.log('    ✅ http://192.168.1.100:4000 (可以！)');
});
```

---

## 🌐 网络包的流向

### 访问 127.0.0.1（本地回环）

```
浏览器
   ↓
操作系统网络栈
   ↓
127.0.0.1 (回环接口)
   ↓
【不经过物理网卡】
   ↓
本地进程（服务器）

特点：
- 数据包不离开本机
- 不经过网卡、路由器
- 速度极快（无物理传输）
- 其他设备看不到这个流量
```

### 访问 192.168.1.100（本机 IP，服务器监听 0.0.0.0）

```
浏览器
   ↓
操作系统网络栈
   ↓
【经过物理网卡】
   ↓
网卡驱动
   ↓
（如果是外部设备，还会经过网络）
   ↓
本地进程（服务器）

特点：
- 虽然是访问本机，但经过了网卡
- 可以被抓包工具捕获
- 速度稍慢（有物理传输）
```

---

## 🎯 应用场景

### 场景1：纯本地开发（127.0.0.1）

```javascript
/**
 * 使用场景：个人开发，不需要其他设备访问
 */

// 优点
const benefits = {
  security: '✅ 更安全（其他设备无法访问）',
  isolation: '✅ 完全隔离',
  simple: '✅ 简单直接'
};

// 缺点
const drawbacks = {
  testing: '❌ 无法用手机测试',
  teamwork: '❌ 团队成员无法访问',
  debugging: '❌ 无法远程调试'
};

// 示例
const devServer = {
  vite: 'vite --host 127.0.0.1',
  webpack: 'webpack serve --host 127.0.0.1',
  node: 'app.listen(3000, "127.0.0.1")'
};
```

### 场景2：局域网共享（0.0.0.0）

```javascript
/**
 * 使用场景：需要团队协作、移动端测试
 */

// 优点
const benefits = {
  mobile: '✅ 可以用手机测试',
  teamwork: '✅ 团队成员可以访问',
  debugging: '✅ 可以远程调试',
  demo: '✅ 可以给别人演示'
};

// 缺点
const drawbacks = {
  security: '❌ 安全性较低（需要防火墙）',
  exposure: '❌ 暴露在局域网中'
};

// 示例
const devServer = {
  vite: 'vite --host 0.0.0.0',
  webpack: 'webpack serve --host 0.0.0.0',
  node: 'app.listen(3000, "0.0.0.0")'
};
```

### 场景3：生产环境

```javascript
/**
 * 生产环境建议
 */

// 前端有 Nginx/Apache 反向代理
const withProxy = {
  nodeApp: 'app.listen(3000, "127.0.0.1")', // Node 只监听本地
  nginx: `
    server {
      listen 0.0.0.0:80;  # Nginx 监听所有接口
      
      location / {
        proxy_pass http://127.0.0.1:3000;  # 转发给 Node
      }
    }
  `,
  benefit: '更安全（Node 不直接暴露）'
};

// 没有反向代理，直接对外服务
const withoutProxy = {
  nodeApp: 'app.listen(3000, "0.0.0.0")',
  security: '需要配置防火墙、限流等',
  caution: '⚠️ 注意安全！'
};
```

---

## 🔐 安全性对比

### 安全风险

```javascript
/**
 * 监听 0.0.0.0 的安全风险
 */
const securityRisks = {
  // 风险1：暴露在局域网
  localNetwork: {
    risk: '局域网内的任何设备都可以访问',
    attack: '内网渗透、中间人攻击',
    example: '公司 WiFi 下，其他员工可以访问你的开发服务器'
  },
  
  // 风险2：端口扫描
  portScanning: {
    risk: '攻击者可以扫描开放端口',
    attack: '发现开发服务器，尝试攻击',
    tool: 'nmap, masscan'
  },
  
  // 风险3：未授权访问
  unauthorized: {
    risk: '没有身份验证的开发服务器',
    attack: '直接访问管理接口',
    example: 'http://192.168.1.100:3000/admin'
  }
};

/**
 * 安全建议
 */
const securityRecommendations = {
  // 开发环境
  development: {
    local: '使用 127.0.0.1（只给自己用）',
    team: '使用 0.0.0.0 + 防火墙规则',
    mobile: '使用 0.0.0.0，但限制 IP 白名单'
  },
  
  // 生产环境
  production: {
    withProxy: '应用监听 127.0.0.1，Nginx 监听 0.0.0.0',
    withoutProxy: '监听 0.0.0.0 + 防火墙 + HTTPS + 认证',
    never: '❌ 永远不要直接监听 0.0.0.0 而不加保护'
  }
};
```

### 安全加固示例

```javascript
/**
 * 监听 0.0.0.0 时的安全措施
 */

// 1. IP 白名单
const ipWhitelist = ['192.168.1.0/24']; // 只允许局域网

app.use((req, res, next) => {
  const clientIP = req.ip;
  
  if (!isInWhitelist(clientIP, ipWhitelist)) {
    return res.status(403).send('Forbidden');
  }
  
  next();
});

// 2. 基本认证
app.use((req, res, next) => {
  const auth = req.headers.authorization;
  
  if (!auth || !verifyAuth(auth)) {
    res.setHeader('WWW-Authenticate', 'Basic');
    return res.status(401).send('Unauthorized');
  }
  
  next();
});

// 3. 限流
const rateLimit = require('express-rate-limit');

app.use(rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100 // 最多100个请求
}));

// 4. HTTPS（生产环境）
const https = require('https');
const fs = require('fs');

const options = {
  key: fs.readFileSync('server-key.pem'),
  cert: fs.readFileSync('server-cert.pem')
};

https.createServer(options, app).listen(443, '0.0.0.0', () => {
  console.log('HTTPS 服务器运行在 0.0.0.0:443');
});
```

---

## 📱 移动端调试场景

### 使用 0.0.0.0 进行移动端测试

```javascript
/**
 * 移动端调试必须使用 0.0.0.0
 */

// 开发服务器
const app = express();

app.listen(3000, '0.0.0.0', () => {
  const os = require('os');
  const interfaces = os.networkInterfaces();
  
  console.log('📱 移动端访问地址:');
  
  // 获取本机 IP
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      // 跳过内部和非 IPv4 地址
      if (iface.family === 'IPv4' && !iface.internal) {
        console.log(`  📱 http://${iface.address}:3000`);
      }
    }
  }
  
  console.log('\n💻 本机访问:');
  console.log('  http://localhost:3000');
});

/**
 * 典型输出：
 * 
 * 📱 移动端访问地址:
 *   📱 http://192.168.1.100:3000  ← 手机在同一 WiFi 下访问
 * 
 * 💻 本机访问:
 *   http://localhost:3000
 */
```

### 获取本机 IP 的工具函数

```javascript
/**
 * 获取本机局域网 IP
 */
function getLocalIP() {
  const os = require('os');
  const interfaces = os.networkInterfaces();
  
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      // 找到第一个非内部的 IPv4 地址
      if (iface.family === 'IPv4' && !iface.internal) {
        return iface.address;
      }
    }
  }
  
  return 'localhost';
}

// 使用
const localIP = getLocalIP();
console.log('本机 IP:', localIP);

app.listen(3000, '0.0.0.0', () => {
  console.log(`手机访问: http://${localIP}:3000`);
});
```

---

## 🐳 Docker 容器场景

### Docker 中的特殊性

```javascript
/**
 * Docker 容器内必须使用 0.0.0.0
 */

// Dockerfile
const dockerExample = {
  // ❌ 错误：容器内监听 127.0.0.1
  wrong: `
    # Dockerfile
    EXPOSE 3000
    CMD ["node", "server.js"]
    
    // server.js
    app.listen(3000, '127.0.0.1');  ❌
    
    // 结果：外部无法访问容器
    // docker run -p 3000:3000 myapp
    // curl http://localhost:3000  ← 失败！
  `,
  
  // ✅ 正确：容器内监听 0.0.0.0
  correct: `
    # Dockerfile
    EXPOSE 3000
    CMD ["node", "server.js"]
    
    // server.js
    app.listen(3000, '0.0.0.0');  ✅
    
    // 结果：可以访问
    // docker run -p 3000:3000 myapp
    // curl http://localhost:3000  ← 成功！
  `,
  
  reason: `
    Docker 容器有自己的网络命名空间
    127.0.0.1 指的是容器内部的回环
    0.0.0.0 才能让容器接受外部连接
  `
};
```

### docker-compose 示例

```yaml
# docker-compose.yml
version: '3'

services:
  web:
    build: .
    ports:
      - "3000:3000"  # 宿主机端口:容器端口
    environment:
      - HOST=0.0.0.0  # ✅ 必须监听 0.0.0.0
      - PORT=3000
```

```javascript
// server.js（容器内）
const host = process.env.HOST || '0.0.0.0'; // 默认 0.0.0.0
const port = process.env.PORT || 3000;

app.listen(port, host, () => {
  console.log(`服务器运行在 ${host}:${port}`);
});
```

---

## 🔧 常见框架的默认行为

### 各框架对比

```javascript
const frameworkDefaults = {
  // Express (Node.js)
  express: {
    default: '未指定时通常是 "::" (IPv6 的所有接口)',
    recommendation: '明确指定 host',
    example: 'app.listen(3000, "0.0.0.0")'
  },
  
  // Vite
  vite: {
    default: '127.0.0.1（只本机）',
    expose: '--host 0.0.0.0 或 --host',
    config: `
      // vite.config.js
      export default {
        server: {
          host: '0.0.0.0',  // 允许局域网访问
          port: 3000
        }
      }
    `
  },
  
  // Webpack Dev Server
  webpackDevServer: {
    default: 'localhost（127.0.0.1）',
    expose: '--host 0.0.0.0',
    config: `
      // webpack.config.js
      devServer: {
        host: '0.0.0.0',
        port: 8080
      }
    `
  },
  
  // Create React App
  cra: {
    default: '127.0.0.1',
    expose: 'HOST=0.0.0.0 npm start',
    note: '通过环境变量控制'
  },
  
  // Vue CLI
  vueCli: {
    default: '127.0.0.1',
    expose: 'vue-cli-service serve --host 0.0.0.0'
  },
  
  // Next.js
  nextjs: {
    default: '0.0.0.0',
    command: 'next dev -H 0.0.0.0'
  },
  
  // Django
  django: {
    default: '127.0.0.1',
    expose: 'python manage.py runserver 0.0.0.0:8000'
  }
};
```

---

## 💡 实用技巧

### 技巧1：动态选择监听地址

```javascript
/**
 * 根据环境自动选择
 */
const host = process.env.NODE_ENV === 'production'
  ? '127.0.0.1'  // 生产环境：只本机（配合 Nginx）
  : '0.0.0.0';   // 开发环境：允许局域网（方便测试）

app.listen(3000, host, () => {
  console.log(`Server listening on ${host}:3000`);
});
```

### 技巧2：同时监听多个地址

```javascript
/**
 * 同时监听本地和局域网（不同端口）
 */

// 本地服务（无认证，端口 3000）
app.listen(3000, '127.0.0.1', () => {
  console.log('本地访问: http://localhost:3000');
});

// 局域网服务（需要认证，端口 3001）
const secureApp = express();
secureApp.use(authMiddleware); // 添加认证

secureApp.use(app); // 复用路由

secureApp.listen(3001, '0.0.0.0', () => {
  console.log('局域网访问: http://192.168.1.100:3001（需要认证）');
});
```

### 技巧3：自动获取并显示访问地址

```javascript
/**
 * 启动服务器时显示所有可访问地址
 */
const os = require('os');

function getAccessURLs(port) {
  const urls = [];
  const interfaces = os.networkInterfaces();
  
  // 遍历所有网络接口
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === 'IPv4') {
        urls.push(`http://${iface.address}:${port}`);
      }
    }
  }
  
  return urls;
}

app.listen(3000, '0.0.0.0', () => {
  console.log('🚀 服务器启动成功！\n');
  console.log('📍 可通过以下地址访问:\n');
  
  const urls = getAccessURLs(3000);
  urls.forEach(url => {
    if (url.includes('127.0.0.1')) {
      console.log(`  💻 本机: ${url}`);
    } else {
      console.log(`  📱 局域网: ${url}`);
    }
  });
});

/**
 * 输出示例：
 * 
 * 🚀 服务器启动成功！
 * 
 * 📍 可通过以下地址访问:
 * 
 *   💻 本机: http://127.0.0.1:3000
 *   📱 局域网: http://192.168.1.100:3000  ← 手机用这个
 *   📱 局域网: http://172.16.0.5:3000     ← 另一个网卡
 */
```

---

## 🧪 实战测试

### 测试脚本

创建 `test-network.js`：

```javascript
const http = require('http');
const os = require('os');

// 测试1：127.0.0.1
console.log('=== 测试1: 监听 127.0.0.1 ===\n');

const server1 = http.createServer((req, res) => {
  res.end('127.0.0.1 Server');
});

server1.listen(3000, '127.0.0.1', () => {
  console.log('✅ 服务器1启动');
  console.log('   本机访问: http://127.0.0.1:3000');
  console.log('   本机访问: http://localhost:3000');
  console.log('\n请在浏览器测试以上地址\n');
});

// 测试2：0.0.0.0
console.log('=== 测试2: 监听 0.0.0.0 ===\n');

const server2 = http.createServer((req, res) => {
  res.end('0.0.0.0 Server');
});

server2.listen(4000, '0.0.0.0', () => {
  console.log('✅ 服务器2启动');
  console.log('   本机访问: http://localhost:4000');
  
  // 获取所有 IP
  const interfaces = os.networkInterfaces();
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === 'IPv4' && !iface.internal) {
        console.log(`   局域网访问: http://${iface.address}:4000`);
      }
    }
  }
  
  console.log('\n📱 手机在同一 WiFi 下可以访问上述局域网地址\n');
});
```

运行：

```bash
node test-network.js

# 然后分别测试
# 1. 本机浏览器访问
# 2. 手机浏览器访问（连接同一 WiFi）
```

---

## 📋 快速参考

### 选择指南

```
需要场景                      →  监听地址
────────────────────────────────────────
只给自己用（纯本地开发）      →  127.0.0.1
团队协作、移动端测试          →  0.0.0.0
生产环境（有反向代理）        →  127.0.0.1
生产环境（无反向代理）        →  0.0.0.0 + 安全措施
Docker 容器                   →  0.0.0.0（必须）
```

### 常用命令

```bash
# Vite
vite --host 0.0.0.0

# Webpack Dev Server
webpack serve --host 0.0.0.0

# Create React App
HOST=0.0.0.0 npm start

# Next.js
next dev -H 0.0.0.0

# Vue CLI
vue-cli-service serve --host 0.0.0.0

# Node.js
node server.js  # 在代码中指定
```

---

## 📚 总结

### 核心区别

| 方面 | 127.0.0.1 | 0.0.0.0 |
|------|-----------|---------|
| **监听接口** | 只监听回环接口 | 监听所有网络接口 |
| **本机访问** | ✅ localhost / 127.0.0.1 | ✅ localhost / 127.0.0.1 / 本机IP |
| **局域网访问** | ❌ 不可以 | ✅ 可以 |
| **外网访问** | ❌ 不可以 | ✅ 可以（如果有公网IP） |
| **安全性** | ✅ 更安全 | ⚠️ 需要额外防护 |
| **移动端测试** | ❌ 不支持 | ✅ 支持 |
| **Docker** | ❌ 不推荐 | ✅ 必须 |

### 使用建议

1. **开发环境**
   - 只自己用 → `127.0.0.1`
   - 需要团队/移动端测试 → `0.0.0.0` + 局域网访问

2. **生产环境**
   - 有 Nginx 等反向代理 → 应用监听 `127.0.0.1`
   - 直接对外服务 → `0.0.0.0` + 防火墙 + HTTPS + 认证

3. **容器环境**
   - Docker/K8s → 必须 `0.0.0.0`

**记住**：`0.0.0.0` 不是一个可以访问的地址，它是一个**占位符**，表示"监听所有网络接口"！🎯

