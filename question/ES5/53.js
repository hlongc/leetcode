// 创建一个对象并赋值给变量a
var a = { n: 1 };

// 将a的引用赋值给b，现在a和b指向同一个对象 { n: 1 }
var b = a;

/**
 * 关键代码：a.x = a = { n: 2 };
 *
 * 执行过程分解：
 * 1. 赋值表达式从右到左计算
 * 2. 但在赋值之前，左侧的属性访问表达式 a.x 会被先解析，确定要赋值的位置
 * 3. 此时a.x指向的是原始对象{n:1}的x属性
 * 4. 接着，a被重新赋值为新对象{n:2}，此时a的引用改变了，不再指向最初的{n:1}
 * 5. 最后，将新对象{n:2}赋值给之前确定的a.x(即原始对象{n:1}的x属性)
 *
 * 关键点：
 * - 在JavaScript中，点运算符(.)的优先级高于赋值运算符(=)
 * - 赋值运算符从右向左结合
 * - 即使a的引用在过程中改变，a.x访问的仍是初始解析时确定的内存位置
 */
a.x = a = { n: 2 };

// 现在a指向新对象{n:2}，该对象没有x属性，所以a.x为undefined
console.log(a.x); // 输出: undefined

// b仍然指向原始对象{n:1}，而且这个对象的x属性被设置为{n:2}，所以b.x为{n:2}
console.log(b.x); // 输出: { n: 2 }

/**
 * 内存图解说明:
 *
 * 初始状态:
 * a ─────┐
 *         ▼
 * 对象1: {n:1}
 * b ─────┘
 *
 * 执行 a.x = a = {n:2} 后:
 * a ───────────────┐
 *                   ▼
 * 对象2: {n:2}     对象1: {n:1, x:对象2}
 *                   ▲
 * b ───────────────┘
 */
