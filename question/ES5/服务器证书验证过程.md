# 服务器证书验证过程

## 一、TLS 握手简介

在 HTTPS 连接建立过程中，TLS（Transport Layer Security）握手是确保通信安全的关键步骤。服务器需要向浏览器证明自己的身份，这就是通过**数字证书**来实现的。

### 1.1 TLS 握手流程（简化版）

```
客户端（浏览器）                          服务器
    |                                      |
    |-------- ① ClientHello -------------->|
    |                                      |
    |<------- ② ServerHello ---------------|
    |<------- ③ Certificate ----------------|  发送证书链
    |<------- ④ ServerHelloDone ----------|
    |                                      |
    |-------- ⑤ ClientKeyExchange -------->|
    |-------- ⑥ ChangeCipherSpec --------->|
    |-------- ⑦ Finished ----------------->|
    |                                      |
    |<------- ⑧ ChangeCipherSpec ----------|
    |<------- ⑨ Finished ------------------|
    |                                      |
    |======== 加密通信开始 =================|
```

在步骤 ③ 中，服务器会将自己的**证书链（Certificate Chain）**发送给浏览器。

---

## 二、证书链的结构

### 2.1 什么是证书链？

证书链是一个层级结构，由多个证书组成，形成从**服务器证书**到**根证书**的信任链。

```
根证书（Root CA）
    ↓ 签名
中间证书（Intermediate CA）
    ↓ 签名
服务器证书（Server Certificate / End-Entity Certificate）
```

### 2.2 证书链示例

假设访问 `https://www.example.com`，服务器会发送以下证书链：

```
证书 1: www.example.com（服务器证书/叶子证书）
  - Subject: CN=www.example.com
  - Issuer: CN=DigiCert SHA2 Secure Server CA
  - 由中间 CA 签名

证书 2: DigiCert SHA2 Secure Server CA（中间证书）
  - Subject: CN=DigiCert SHA2 Secure Server CA
  - Issuer: CN=DigiCert Global Root CA
  - 由根 CA 签名

证书 3: DigiCert Global Root CA（根证书，通常不发送）
  - Subject: CN=DigiCert Global Root CA
  - Issuer: CN=DigiCert Global Root CA（自签名）
  - 预装在浏览器中
```

**注意：** 服务器通常只发送证书 1 和证书 2，根证书已经预装在浏览器的信任根存储中。

---

## 三、浏览器验证证书的详细过程

### 3.1 核心问题：从上往下还是从下往上？

**答案：从下往上验证（从叶子证书到根证书）**

虽然证书链的结构是"自上而下"的（根 CA → 中间 CA → 服务器），但浏览器的**验证顺序是自下而上**的：

```
验证顺序：服务器证书 → 中间证书 → 根证书
```

### 3.2 为什么是从下往上？

因为验证的逻辑是：**"这个证书是由谁签发的？签发者是否可信？"**

- 从服务器证书开始
- 找到签发者（Issuer）
- 验证签发者的签名是否有效
- 继续验证签发者的证书
- 直到找到受信任的根证书

### 3.3 详细验证步骤

#### 步骤 1：验证服务器证书（叶子证书）

浏览器首先检查服务器证书本身：

1. **域名匹配**

   - 检查证书的 `Subject` 或 `Subject Alternative Name (SAN)` 是否与当前访问的域名匹配
   - 例如：访问 `www.example.com`，证书 CN 必须是 `www.example.com` 或 `*.example.com`

2. **有效期检查**

   - 检查证书的 `Not Before` 和 `Not After` 字段
   - 确保当前时间在有效期内

3. **证书用途**

   - 检查 `Key Usage` 和 `Extended Key Usage` 扩展
   - 确保证书可以用于服务器身份验证（`Server Authentication`）

4. **吊销状态**
   - 通过 CRL（Certificate Revocation List）或 OCSP（Online Certificate Status Protocol）检查证书是否被吊销

#### 步骤 2：查找签发者并验证签名

```
服务器证书的 Issuer = "CN=DigiCert SHA2 Secure Server CA"
```

浏览器需要：

- 在证书链中找到签发者的证书（中间证书）
- 使用中间证书的**公钥**验证服务器证书的**数字签名**

**签名验证过程：**

```
1. 从服务器证书中提取签名值（S）
2. 从服务器证书中提取被签名的内容（C）
3. 使用中间证书的公钥解密签名 S，得到哈希值 H1
4. 对内容 C 计算哈希，得到哈希值 H2
5. 如果 H1 == H2，签名有效
```

#### 步骤 3：验证中间证书

对中间证书重复类似的检查：

1. **有效期检查**
2. **证书用途检查**（是否可以作为 CA）
3. **基本约束检查**

   - `Basic Constraints: CA=TRUE`
   - 确保证书可以签发其他证书

4. **查找签发者**

   - 中间证书的 Issuer = "CN=DigiCert Global Root CA"

5. **验证签名**
   - 使用根证书的公钥验证中间证书的签名

#### 步骤 4：验证根证书

1. **在信任根存储中查找**

   - 浏览器/操作系统维护一个受信任的根证书列表
   - 检查根证书是否在这个列表中

2. **自签名验证**

   - 根证书是自签名的（Issuer == Subject）
   - 使用自己的公钥验证自己的签名

3. **验证成功**
   - 如果根证书在信任列表中，整个证书链验证通过

---

## 四、图解验证过程

### 4.1 证书链的验证方向

```
┌─────────────────────────────────────────┐
│   DigiCert Global Root CA (根证书)      │ ← 步骤 4：在信任根中？
│   - 预装在浏览器中                       │
│   - 自签名                               │
└────────────┬────────────────────────────┘
             │ 用公钥验证签名
             ↑ (步骤 3)
┌────────────┴────────────────────────────┐
│   DigiCert SHA2 Secure Server CA        │ ← 步骤 3：验证中间证书
│   - Issuer: DigiCert Global Root CA    │
└────────────┬────────────────────────────┘
             │ 用公钥验证签名
             ↑ (步骤 2)
┌────────────┴────────────────────────────┐
│   www.example.com (服务器证书)          │ ← 步骤 1：验证服务器证书
│   - Issuer: DigiCert SHA2...           │    - 域名匹配
│   - Subject: www.example.com           │    - 有效期
└─────────────────────────────────────────┘    - 吊销状态

验证方向：从下往上 ↑↑↑
```

### 4.2 为什么要这样设计？

1. **信任锚点**

   - 根证书是信任的起点（Trust Anchor）
   - 预装在操作系统/浏览器中
   - 由知名 CA 机构维护（如 DigiCert、Let's Encrypt、GlobalSign）

2. **层级授权**

   - 根 CA 不需要频繁签发证书
   - 中间 CA 负责日常签发工作
   - 减少根证书私钥的暴露风险

3. **灵活性**
   - 如果中间 CA 出现问题，只需替换中间证书
   - 根证书可以保持不变

---

## 五、常见验证错误

### 5.1 证书链不完整

**错误现象：**

```
NET::ERR_CERT_AUTHORITY_INVALID
```

**原因：** 服务器只发送了服务器证书，没有发送中间证书。

**解决方法：**

- 在服务器配置中包含完整的证书链
- Nginx 示例：
  ```nginx
  ssl_certificate /path/to/fullchain.pem;  # 包含服务器证书和中间证书
  ssl_certificate_key /path/to/privkey.pem;
  ```

### 5.2 域名不匹配

**错误现象：**

```
NET::ERR_CERT_COMMON_NAME_INVALID
```

**原因：** 访问的域名与证书中的 CN/SAN 不匹配。

**示例：**

- 证书 CN: `www.example.com`
- 访问地址: `example.com`（没有 www）

### 5.3 证书过期

**错误现象：**

```
NET::ERR_CERT_DATE_INVALID
```

**原因：** 当前时间不在证书的有效期内。

### 5.4 自签名证书

**错误现象：**

```
NET::ERR_CERT_AUTHORITY_INVALID
```

**原因：** 证书是自签名的，不在浏览器的信任根列表中。

**使用场景：**

- 开发环境
- 内网环境

**解决方法：**

- 手动将自签名证书添加到信任列表（不推荐用于生产环境）
- 使用受信任的 CA 签发的证书（如 Let's Encrypt 免费证书）

### 5.5 证书被吊销

**错误现象：**

```
NET::ERR_CERT_REVOKED
```

**原因：** 证书已被 CA 吊销（可能是私钥泄露）。

---

## 六、证书验证完整示例

### 6.1 使用 OpenSSL 查看证书链

```bash
# 查看服务器发送的证书链
openssl s_client -connect www.example.com:443 -showcerts

# 输出示例（简化）：
---
Certificate chain
 0 s:/CN=www.example.com
   i:/CN=DigiCert SHA2 Secure Server CA
 1 s:/CN=DigiCert SHA2 Secure Server CA
   i:/CN=DigiCert Global Root CA
---
```

**解释：**

- `s:` = Subject（证书主体）
- `i:` = Issuer（签发者）
- 证书 0 的 Issuer = 证书 1 的 Subject
- 证书 1 的 Issuer = 根证书（不在输出中，因为预装在系统中）

### 6.2 验证证书链的逻辑伪代码

```javascript
function verifyCertificateChain(serverCert, chain, trustedRoots) {
  let currentCert = serverCert;

  // 1. 验证服务器证书
  if (!verifyDomain(currentCert, targetDomain)) {
    throw new Error("域名不匹配");
  }
  if (!verifyValidity(currentCert)) {
    throw new Error("证书已过期");
  }
  if (isRevoked(currentCert)) {
    throw new Error("证书已被吊销");
  }

  // 2. 从下往上验证证书链
  while (true) {
    // 查找签发者证书
    const issuerCert = findIssuerCert(currentCert, chain);

    if (!issuerCert) {
      throw new Error("证书链不完整");
    }

    // 验证签名
    if (!verifySignature(currentCert, issuerCert.publicKey)) {
      throw new Error("签名验证失败");
    }

    // 检查是否到达根证书
    if (trustedRoots.includes(issuerCert)) {
      // 验证成功！
      return true;
    }

    // 继续验证上一级
    currentCert = issuerCert;
  }
}

// 辅助函数
function verifySignature(cert, publicKey) {
  const signature = cert.signature;
  const content = cert.tbsCertificate; // To Be Signed Certificate

  // 1. 用公钥解密签名
  const decryptedHash = decrypt(signature, publicKey);

  // 2. 计算内容的哈希
  const computedHash = hash(content);

  // 3. 对比
  return decryptedHash === computedHash;
}
```

---

## 七、进阶知识

### 7.1 证书透明度（Certificate Transparency）

现代浏览器还会检查证书是否在 **CT 日志**中：

- 所有公开信任的证书必须记录在公开的 CT 日志中
- 防止 CA 恶意或错误签发证书
- Chrome 要求所有证书必须符合 CT 策略

### 7.2 证书钉扎（Certificate Pinning）

某些应用会"固定"特定的证书或公钥：

```javascript
// 示例：只信任特定的公钥
const expectedPublicKeyHash = "sha256/AAAAAAAAAA...";
if (actualPublicKeyHash !== expectedPublicKeyHash) {
  throw new Error("证书钉扎验证失败");
}
```

**优点：** 防止中间人攻击（即使伪造证书被 CA 签名）
**缺点：** 证书更新时需要同步更新应用

### 7.3 HSTS（HTTP Strict Transport Security）

服务器可以通过 HSTS 头强制浏览器使用 HTTPS：

```
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

浏览器会：

- 自动将 HTTP 请求重定向到 HTTPS
- 拒绝不安全的证书（不显示"继续访问"选项）

---

## 八、总结

### 8.1 核心要点

1. **证书链的结构**：根 CA → 中间 CA → 服务器证书
2. **验证方向**：**从下往上**（服务器证书 → 中间证书 → 根证书）
3. **验证内容**：

   - 域名匹配
   - 有效期
   - 数字签名
   - 证书用途
   - 吊销状态
   - 信任根检查

4. **信任基础**：操作系统/浏览器预装的根证书列表

### 8.2 为什么是从下往上？

因为验证的逻辑是**验证签名**：

- 用签发者的公钥验证被签发者的签名
- 从叶子节点开始，逐级向上
- 直到找到受信任的根证书

### 8.3 验证流程图（完整版）

```
开始
  ↓
① 接收证书链（服务器发送）
  ↓
② 验证服务器证书
  - 域名匹配？
  - 有效期内？
  - 未被吊销？
  ↓
③ 找到签发者证书（中间证书）
  ↓
④ 用签发者公钥验证签名 ←─────┐
  ↓                          │
⑤ 签名有效？                 │
  │                          │
  ├─ No → 验证失败            │
  │                          │
  └─ Yes                     │
     ↓                       │
⑥ 签发者是根证书？            │
  │                          │
  ├─ No ─ 继续验证签发者 ─────┘
  │
  └─ Yes
     ↓
⑦ 根证书在信任列表中？
  │
  ├─ No → 验证失败
  │
  └─ Yes → ✅ 验证成功！
```

---

## 九、参考资料

- [RFC 5280 - Internet X.509 Public Key Infrastructure Certificate](https://datatracker.ietf.org/doc/html/rfc5280)
- [TLS 1.3 - RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)
- [Mozilla: Web Security - Certificate](https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency)
- [Chrome Certificate Transparency Policy](https://googlechrome.github.io/CertificateTransparency/ct_policy.html)
- [OWASP: Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)
