# 组件库版本管理策略

## 🎯 核心问题

### 问题描述

```
初始状态:
  组件库: v1.0.0
  业务A: 依赖 v1.0.0
  业务B: 依赖 v1.0.0

场景1:
  业务A 需要新功能 → 组件库发布 v1.0.1
  业务A: 升级到 v1.0.1 ✅
  业务B: 仍然使用 v1.0.0 ✅

场景2（问题来了）:
  业务B 也需要新功能 → 组件库发布 v1.0.2
  v1.0.2 基于 v1.0.1 开发
  
  问题：
  v1.0.2 包含了 v1.0.1 的修改
  → 业务B 升级到 v1.0.2
  → v1.0.1 的修改可能影响业务B（未经测试）
  → 可能引发 Bug！💥
```

---

## 📊 问题分析

### 依赖关系图

```
时间线：

t1: 组件库 1.0.0
    ├─ 业务A: 1.0.0
    └─ 业务B: 1.0.0

t2: 业务A 需要功能X
    组件库发布 1.0.1 (+功能X)
    ├─ 业务A: 升级到 1.0.1 ✅
    └─ 业务B: 仍然 1.0.0 ✅（不升级）

t3: 业务B 需要功能Y
    组件库基于 1.0.1 发布 1.0.2 (+功能Y)
    
    问题：
    1.0.2 = 1.0.1 + 功能Y
          = 功能X + 功能Y
    
    业务B: 升级到 1.0.2
    → 意外获得功能X（未测试）
    → 功能X 可能与业务B 冲突
    → Bug！💥
```

---

## 🔧 解决方案

### 方案1：强制升级（不推荐）

```javascript
/**
 * 所有业务必须升级到最新版本
 */
const forceUpgrade = {
  policy: '每次发布新版本，所有业务都必须升级',
  
  workflow: `
    1. 组件库发布 1.0.1
    2. 通知所有业务团队
    3. 业务A、B 都升级到 1.0.1
    4. 全部测试通过
    5. 发布
  `,
  
  pros: [
    '✅ 不会有版本分歧',
    '✅ 所有业务使用相同版本',
    '✅ 统一维护'
  ],
  
  cons: [
    '❌ 业务团队压力大（频繁升级）',
    '❌ 测试成本高',
    '❌ 可能阻塞业务发布',
    '❌ 不现实（业务可能不需要新功能）'
  ],
  
  recommendation: '❌ 不推荐（除非团队很小）'
};
```

### 方案2：语义化版本 + 向后兼容（推荐）

```javascript
/**
 * 使用语义化版本（Semantic Versioning）
 * 格式：MAJOR.MINOR.PATCH
 */

const semver = {
  format: 'X.Y.Z',
  
  // MAJOR（主版本号）：不兼容的 API 修改
  major: {
    when: '破坏性变更（Breaking Changes）',
    example: '1.0.0 → 2.0.0',
    impact: '❌ 业务必须修改代码才能升级',
    rule: '业务可以选择不升级（继续使用 1.x）'
  },
  
  // MINOR（次版本号）：向后兼容的功能新增
  minor: {
    when: '新增功能，但不破坏现有功能',
    example: '1.0.0 → 1.1.0',
    impact: '✅ 业务可以直接升级（不需要改代码）',
    rule: '可选升级'
  },
  
  // PATCH（补丁版本号）：向后兼容的 Bug 修复
  patch: {
    when: 'Bug 修复，不改变 API',
    example: '1.0.0 → 1.0.1',
    impact: '✅ 业务应该升级（修复了 Bug）',
    rule: '建议升级'
  }
};

/**
 * 示例：
 * 
 * 业务A 需要新功能 → 发布 1.1.0（MINOR）
 * 业务B 可以选择：
 *   - 升级到 1.1.0（获得新功能）
 *   - 继续使用 1.0.0（不需要新功能）
 * 
 * 业务B 需要新功能 → 发布 1.2.0（MINOR，基于 1.1.0）
 * 业务B：
 *   - 升级到 1.2.0
 *   - 会包含 1.1.0 的功能（但应该是兼容的）
 *   - 如果不兼容 → 发布策略错误，应该是 2.0.0
 */
```

### 方案3：分支策略（推荐）

```bash
# Git 分支管理

# 主分支（稳定版本）
main/master
  - v1.0.0
  - v1.0.1 (Bug 修复)
  - v1.0.2 (Bug 修复)

# 功能分支（基于需求创建）
feature/business-a-feature-x    # 业务A 的功能
feature/business-b-feature-y    # 业务B 的功能

# 发布分支（维护多个版本）
release/1.0.x   # 维护 1.0 版本（只接受 Bug 修复）
release/1.1.x   # 维护 1.1 版本
release/2.0.x   # 维护 2.0 版本
```

**工作流程**：

```bash
# 业务A 需要功能X
git checkout -b feature/business-a-x main
# 开发功能X
git commit -m "feat: add feature X for business A"
# 发布 1.1.0
npm version minor  # 1.0.0 → 1.1.0
npm publish

# 业务B 需要功能Y（此时不想要功能X）
# 方案1：基于 1.0.0 创建分支（维护旧版本）
git checkout -b release/1.0.x v1.0.0
# 开发功能Y
git commit -m "feat: add feature Y for business B"
# 发布 1.0.3（不包含功能X）
npm version patch  # 1.0.0 → 1.0.3
npm publish --tag legacy-1.0

# 业务B 安装
npm install component-lib@1.0.3

# 方案2：基于 1.1.0 创建（包含功能X）
git checkout -b feature/business-b-y v1.1.0
# 开发功能Y
# 发布 1.2.0（包含功能X + Y）
npm version minor  # 1.1.0 → 1.2.0
npm publish
```

### 方案4：多版本并行维护（企业级）

```javascript
/**
 * 同时维护多个大版本
 */

const multiVersionStrategy = {
  // 版本分支
  branches: {
    'v1.x': {
      version: '1.0.0 - 1.x.x',
      status: 'LTS（长期支持）',
      maintenance: '只修复严重 Bug',
      eol: '2026-12-31'
    },
    
    'v2.x': {
      version: '2.0.0 - 2.x.x',
      status: 'Active（活跃开发）',
      maintenance: '新功能 + Bug 修复',
      recommended: '✅ 推荐新项目使用'
    },
    
    'v3.x': {
      version: '3.0.0-beta',
      status: 'Beta（测试版）',
      maintenance: '实验性功能',
      warning: '⚠️ 不稳定'
    }
  },
  
  // 业务选择
  businessChoice: {
    businessA: '使用 v2.x（需要新功能）',
    businessB: '使用 v1.x（稳定优先）',
    businessC: '使用 v3.x（尝鲜）'
  }
};

// package.json 配置
const packageConfig = {
  // 业务A
  businessA: {
    dependencies: {
      'component-lib': '^2.0.0'  // 2.x 的最新版本
    }
  },
  
  // 业务B
  businessB: {
    dependencies: {
      'component-lib': '^1.0.0'  // 1.x 的最新版本
    }
  }
};
```

---

## 🎯 实际解决方案

### 推荐方案：版本范围 + 锁文件

```json
// package.json（业务项目）
{
  "dependencies": {
    "component-lib": "^1.0.0"
  }
}

/**
 * 版本范围说明：
 * 
 * ^1.0.0  - 兼容 1.x.x（≥1.0.0 且 <2.0.0）
 *   允许：1.0.1, 1.0.2, 1.1.0, 1.9.9
 *   不允许：2.0.0
 * 
 * ~1.0.0  - 兼容 1.0.x（≥1.0.0 且 <1.1.0）
 *   允许：1.0.1, 1.0.2, 1.0.99
 *   不允许：1.1.0, 2.0.0
 * 
 * 1.0.0   - 精确版本
 *   只允许：1.0.0
 */
```

```json
// package-lock.json（锁定具体版本）
{
  "dependencies": {
    "component-lib": {
      "version": "1.0.2",  // 实际安装的版本
      "resolved": "https://registry.npmjs.org/component-lib/-/component-lib-1.0.2.tgz"
    }
  }
}

/**
 * 工作流程：
 * 
 * 1. 业务B 首次安装
 *    npm install
 *    → 安装 1.0.0
 *    → package-lock.json 锁定 1.0.0
 * 
 * 2. 组件库发布 1.0.1（业务A 需要）
 *    业务B 不升级（package-lock.json 仍是 1.0.0）
 * 
 * 3. 组件库发布 1.0.2（业务B 需要）
 *    业务B 升级：
 *    npm install component-lib@1.0.2
 *    → package-lock.json 更新为 1.0.2
 *    → 包含 1.0.1 的修改
 *    → 需要测试！
 */
```

---

## 🔀 完整的版本管理策略

### 策略1：基于主版本的分支管理

```bash
# ============================================
# Git 分支策略（推荐）
# ============================================

# 主分支
main          # 最新开发版本（v2.x）
v1.x          # 维护 v1 版本
v2.x          # 当前稳定版本

# 功能开发
feature/add-feature-x      # 新功能（合并到 main）
fix/bug-123               # Bug 修复
hotfix/critical-bug       # 紧急修复（可能需要合并到多个分支）

# ============================================
# 实际操作
# ============================================

# 业务A 需要功能X（基于当前 main）
git checkout main
git checkout -b feature/add-feature-x
# 开发...
git commit -m "feat: add feature X"
git checkout main
git merge feature/add-feature-x
npm version minor  # 1.0.0 → 1.1.0
git tag v1.1.0
npm publish

# 业务B 不想要功能X，需要功能Y
# 选项1：基于 v1.0.0 创建功能Y
git checkout -b feature/add-feature-y v1.0.0
# 开发功能Y（不包含X）
git commit -m "feat: add feature Y"

# 创建 1.0.x 维护分支
git checkout -b v1.0.x v1.0.0
git merge feature/add-feature-y
npm version patch  # 1.0.0 → 1.0.1
git tag v1.0.1
npm publish --tag legacy-1.0

# 选项2：基于 v1.1.0 创建（包含功能X）
git checkout -b feature/add-feature-y v1.1.0
# 开发功能Y（包含X，需要测试X对业务B的影响）
git commit -m "feat: add feature Y"
git checkout main
git merge feature/add-feature-y
npm version minor  # 1.1.0 → 1.2.0
git tag v1.2.0
npm publish
```

### 策略2：使用 NPM Tags

```bash
# ============================================
# NPM 发布标签（Tag）
# ============================================

# 默认发布（latest tag）
npm publish
# 业务默认安装：npm install component-lib
# 会安装 latest 标签的版本

# 发布到特定标签
npm publish --tag next        # 下一个版本（测试版）
npm publish --tag legacy-1.0  # 旧版本维护
npm publish --tag beta        # Beta 版本

# 业务选择安装
npm install component-lib@latest      # 最新稳定版
npm install component-lib@next        # 下一个版本
npm install component-lib@legacy-1.0  # 旧版本
npm install component-lib@1.0.1       # 精确版本

# ============================================
# 实际应用
# ============================================

# 场景：维护旧版本
# 1. 在 v1.0.x 分支开发
git checkout v1.0.x
# 2. 发布到 legacy tag
npm version patch  # 1.0.2
npm publish --tag legacy-1.0

# 业务B 安装旧版本
npm install component-lib@legacy-1.0
# 或指定版本
npm install component-lib@1.0.2
```

---

## 🎨 具体解决方案

### 方案A：Cherry-pick（精选合并）

```bash
# ============================================
# 只合并需要的修改，不合并全部
# ============================================

# 状态：
# v1.0.0 (初始)
# v1.0.1 (业务A 的功能X) - commit abc123
# v1.0.2 待发布 (业务B 需要功能Y)

# 业务B 的开发流程：
git checkout -b release/1.0.2 v1.0.0  # 基于 1.0.0（不包含功能X）

# 开发功能Y
git commit -m "feat: add feature Y for business B"

# 如果需要 1.0.1 的某个 Bug 修复（但不要功能X）
git cherry-pick def456  # 只挑选 Bug 修复的 commit

# 发布 1.0.2
npm version patch  # 1.0.0 → 1.0.2（自定义版本号）
git tag v1.0.2
npm publish

# 结果：
# v1.0.2 = v1.0.0 + 功能Y（不包含功能X）
```

### 方案B：特性开关（Feature Flag）

```javascript
/**
 * 使用特性开关控制功能启用
 */

// 组件库代码
class ComponentLib {
  constructor(config = {}) {
    this.features = {
      featureX: config.enableFeatureX || false,  // 默认关闭
      featureY: config.enableFeatureY || false
    };
  }
  
  render() {
    // 根据特性开关决定行为
    if (this.features.featureX) {
      return this.renderWithFeatureX();
    } else {
      return this.renderDefault();
    }
  }
}

// 业务A（需要功能X）
import ComponentLib from 'component-lib@1.1.0';

const lib = new ComponentLib({
  enableFeatureX: true  // ✅ 启用功能X
});

// 业务B（不需要功能X）
import ComponentLib from 'component-lib@1.1.0';  // 同一版本

const lib = new ComponentLib({
  enableFeatureX: false  // ❌ 关闭功能X
});

/**
 * 优势：
 * - 同一版本，不同配置
 * - 灰度发布
 * - A/B 测试
 * 
 * 缺点：
 * - 代码复杂度增加
 * - 需要维护特性开关
 */
```

### 方案C：Monorepo + 独立版本

```bash
# ============================================
# 使用 Lerna/pnpm workspace 管理多包
# ============================================

# 项目结构
component-lib/
  packages/
    core/          # 核心包（v1.0.0）
    feature-x/     # 功能X 包（v1.0.0）
    feature-y/     # 功能Y 包（v1.0.0）

# package.json
{
  "name": "@company/component-lib-core",
  "version": "1.0.0"
}

{
  "name": "@company/component-lib-feature-x",
  "version": "1.0.0",
  "peerDependencies": {
    "@company/component-lib-core": "^1.0.0"
  }
}

# 业务A（需要功能X）
{
  "dependencies": {
    "@company/component-lib-core": "^1.0.0",
    "@company/component-lib-feature-x": "^1.0.0"
  }
}

# 业务B（不需要功能X，只需要功能Y）
{
  "dependencies": {
    "@company/component-lib-core": "^1.0.0",
    "@company/component-lib-feature-y": "^1.0.0"
  }
}

/**
 * 优势：
 * - 功能独立发布
 * - 业务按需引入
 * - 避免版本冲突
 */
```

---

## 🛡️ 最佳实践

### 1. 严格的版本规范

```javascript
/**
 * 版本发布检查清单
 */
const releaseChecklist = {
  // 发布前检查
  before: [
    '✅ 确定版本类型（MAJOR/MINOR/PATCH）',
    '✅ 检查是否有破坏性变更',
    '✅ 运行所有测试（单元测试、集成测试）',
    '✅ 更新 CHANGELOG.md',
    '✅ 更新文档',
    '✅ Code Review'
  ],
  
  // 版本号规则
  versioning: {
    breaking: 'MAJOR +1（如 1.x.x → 2.0.0）',
    feature: 'MINOR +1（如 1.0.x → 1.1.0）',
    bugfix: 'PATCH +1（如 1.0.0 → 1.0.1）'
  },
  
  // 发布后
  after: [
    '✅ 打 Git Tag',
    '✅ 发布 Release Notes',
    '✅ 通知业务团队',
    '✅ 更新升级指南'
  ]
};
```

### 2. 向后兼容原则

```javascript
/**
 * 如何保持向后兼容？
 */

// ❌ 破坏性变更（需要发布 MAJOR 版本）
// Before (v1.0.0)
function fetchUser(id) {
  return fetch(`/api/user/${id}`);
}

// After (v2.0.0)
function fetchUser(options) {  // ❌ 参数类型改变
  return fetch(`/api/user/${options.id}`);
}

// ✅ 向后兼容（可以发布 MINOR 版本）
// Before (v1.0.0)
function fetchUser(id) {
  return fetch(`/api/user/${id}`);
}

// After (v1.1.0)
function fetchUser(idOrOptions) {
  // 兼容旧的调用方式
  if (typeof idOrOptions === 'number' || typeof idOrOptions === 'string') {
    return fetch(`/api/user/${idOrOptions}`);
  }
  // 新的调用方式
  return fetch(`/api/user/${idOrOptions.id}`);
}

/**
 * 向后兼容的技巧：
 * 
 * 1. 参数重载（同时支持新旧参数）
 * 2. 默认值（新参数给默认值）
 * 3. 渐进式废弃（先标记 @deprecated，再在下个大版本删除）
 * 4. 适配器模式
 */
```

### 3. 变更日志（CHANGELOG）

```markdown
# CHANGELOG.md

## [1.2.0] - 2025-11-04

### Added（新增）
- 新增 `FeatureY` 组件（业务B 需求）
- 新增 `utils.formatDate` 工具函数

### Changed（修改）
- `Button` 组件优化点击响应速度

### Fixed（修复）
- 修复 `Table` 组件分页 Bug (#123)

### ⚠️ Breaking Changes（破坏性变更）
- 无

### 📦 Dependencies（依赖变更）
- 升级 `react` 从 17.x 到 18.x

---

## [1.1.0] - 2025-11-01

### Added
- 新增 `FeatureX` 组件（业务A 需求）

### ⚠️ Notes（注意事项）
- `FeatureX` 组件引入了新的 CSS 样式，可能影响全局布局
- 建议业务团队测试后再升级

---

## [1.0.0] - 2025-10-01
- 初始版本
```

---

## 📦 发布流程

### 完整的发布工作流

```bash
# ============================================
# 第1步：确定版本类型
# ============================================

# 功能新增（业务A 需求）
npm version minor  # 1.0.0 → 1.1.0

# Bug 修复
npm version patch  # 1.0.0 → 1.0.1

# 破坏性变更
npm version major  # 1.0.0 → 2.0.0

# ============================================
# 第2步：更新 CHANGELOG
# ============================================

# 编辑 CHANGELOG.md，记录所有变更

# ============================================
# 第3步：提交并打标签
# ============================================

git add .
git commit -m "chore: release v1.1.0"
git tag v1.1.0
git push origin main --tags

# ============================================
# 第4步：发布到 NPM
# ============================================

# 发布到 latest（默认）
npm publish

# 或发布到特定 tag
npm publish --tag next        # 测试版
npm publish --tag legacy-1.0  # 旧版本

# ============================================
# 第5步：通知业务团队
# ============================================

# 发送邮件/消息
Subject: 组件库 v1.1.0 发布

内容：
- 新增功能列表
- Bug 修复列表
- 破坏性变更（如果有）
- 升级指南
- 测试建议

# ============================================
# 第6步：发布 Release Notes
# ============================================

# GitHub Releases
Title: v1.1.0
Body: 
  ## What's New
  - Feature X
  
  ## Bug Fixes
  - Fix #123
  
  ## Breaking Changes
  - None
  
  ## Upgrade Guide
  - npm install component-lib@1.1.0
  - 测试 XYZ 功能
```

---

## 🎯 处理版本冲突的具体方案

### 场景：业务B 不想要 v1.0.1 的修改

```bash
# ============================================
# 方案1：维护独立的分支
# ============================================

# v1.0.1（业务A）
git checkout -b release/1.0.1 v1.0.0
# 添加功能X
git commit -m "feat: feature X"
git tag v1.0.1
npm publish

# v1.0.2（业务B，不包含功能X）
git checkout -b release/1.0.2 v1.0.0  # ← 基于 1.0.0
# 添加功能Y
git commit -m "feat: feature Y"
git tag v1.0.2
npm publish --tag legacy-1.0

# 结果：
# v1.0.1 (功能X)
# v1.0.2 (功能Y) ← 两者独立，不互相包含

# 问题：版本号混乱（1.0.2 不包含 1.0.1）
```

```bash
# ============================================
# 方案2：正确的版本号（推荐）
# ============================================

# v1.1.0（业务A）- 功能X
git checkout -b release/1.1.0 v1.0.0
git commit -m "feat: feature X"
git tag v1.1.0
npm publish

# v1.2.0（业务B）- 功能Y（基于 1.1.0）
git checkout -b release/1.2.0 v1.1.0
git commit -m "feat: feature Y"
git tag v1.2.0
npm publish

# 业务B：
# - 升级到 1.2.0
# - 包含功能X（需要测试）
# - 如果功能X 有问题 → 禁用或适配

# ============================================
# 方案3：维护 1.0.x 分支（业务B 不升级）
# ============================================

# 业务B 继续使用 1.0.x，不合并功能X
git checkout -b v1.0.x v1.0.0

# 只合并 Bug 修复
git cherry-pick <bug-fix-commit>

# 发布 1.0.3（只有 Bug 修复）
git tag v1.0.3
npm publish --tag legacy-1.0

# 业务B 使用
{
  "dependencies": {
    "component-lib": "~1.0.0"  // 只允许 1.0.x
  }
}
```

---

## 🛠️ 工具和自动化

### 使用 Changesets

```bash
# ============================================
# Changesets: 自动化版本管理
# ============================================

# 安装
npm install @changesets/cli -D
npx changeset init

# 添加变更
npx changeset
# 选择：
# - 包名
# - 版本类型（major/minor/patch）
# - 变更说明

# 生成的 .changeset 文件：
---
"component-lib": minor
---

Add feature X for business A

# 发布
npx changeset version  # 更新版本号和 CHANGELOG
npx changeset publish  # 发布到 NPM

# 优势：
# - 自动生成 CHANGELOG
# - 语义化版本管理
# - 支持 Monorepo
```

### 版本检查脚本

```javascript
// check-compatibility.js
/**
 * 检查组件库版本兼容性
 */

const semver = require('semver');

function checkCompatibility(currentVersion, newVersion) {
  // 检查是否有破坏性变更
  if (semver.major(newVersion) > semver.major(currentVersion)) {
    console.warn('⚠️ 主版本升级，可能有破坏性变更！');
    console.warn('   请查看升级指南');
    return 'breaking';
  }
  
  // 检查是否有新功能
  if (semver.minor(newVersion) > semver.minor(currentVersion)) {
    console.log('ℹ️ 次版本升级，新增功能');
    console.log('   应该向后兼容');
    return 'feature';
  }
  
  // Bug 修复
  if (semver.patch(newVersion) > semver.patch(currentVersion)) {
    console.log('✅ 补丁版本，Bug 修复');
    console.log('   建议升级');
    return 'patch';
  }
  
  return 'same';
}

// 使用
checkCompatibility('1.0.0', '1.1.0');
// 输出：ℹ️ 次版本升级，新增功能
//      应该向后兼容
```

---

## 📋 总结

### 核心答案

**问题：组件库发布后，所有业务都需要升级吗？**

**答案：❌ 不需要！**

业务可以选择：
- 继续使用旧版本（通过 package-lock.json 锁定）
- 升级到新版本（需要测试）

---

### 问题：如何避免业务B 被动包含业务A 的修改？

**解决方案：**

#### 方案1：语义化版本 + 向后兼容（推荐）

```
业务A 需求 → 发布 1.1.0（MINOR，向后兼容）
业务B 后续 → 升级 1.2.0
            → 包含 1.1.0（但应该兼容）
            → 测试后上线
```

#### 方案2：维护多个分支

```
v1.0.x 分支 → 业务B 使用（不包含业务A 的修改）
v1.1.x 分支 → 业务A 使用
main 分支   → 最新开发
```

#### 方案3：特性开关

```javascript
// 同一版本，不同配置
ComponentLib({ enableFeatureX: false }); // 业务B
ComponentLib({ enableFeatureX: true });  // 业务A
```

---

### 推荐策略（企业级）

```
1️⃣ 语义化版本（严格遵守）
   - MAJOR: 破坏性变更
   - MINOR: 新功能（向后兼容）
   - PATCH: Bug 修复

2️⃣ 维护多个 MAJOR 版本
   - v1.x（LTS）
   - v2.x（Current）
   - v3.x（Beta）

3️⃣ 使用 NPM Tags
   - latest（推荐版本）
   - legacy-1.0（旧版本）
   - next（测试版）

4️⃣ 完善的测试和文档
   - 自动化测试
   - 升级指南
   - Breaking Changes 说明

5️⃣ 业务侧锁定版本
   - 使用 package-lock.json
   - 定期升级（计划性）
   - 充分测试
```

文档位置：`组件库版本管理策略.md`

包含：版本管理策略、分支管理、NPM Tags、实战方案、最佳实践！🎉
