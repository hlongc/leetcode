/**
 * 有一个区域grid。row和col分别代表grid的行列，grid[i][j]值为 *  或者 .
 * *代表陆地，.代表海洋；我们可以在上放一个小人，小人可以在陆地上跳跃，
 * 但是不能跳到相邻格子上，只能跳到间隔一个格子的陆地上，并且只能在上下左右四个方向跳跃，跳到陆地上就占领当前陆地
 * 如果当前是海洋则不能跳跃，也不能跳到海洋上
 *  问：最少需要放多少个小人才能占领全部陆地
 * @param row
 * @param col
 * @param grid
 */
function count(row: number, col: number, grid: string[][]): number {
  /**
   * 解题思路：
   * 1. 小人只能跳到间隔一个格子的位置，即从(i,j)可以跳到(i±2,j)和(i,j±2)
   * 2. 使用DFS/BFS找出所有连通分量（可以通过跳跃路径相互到达的陆地集合）
   * 3. 每个连通分量至少需要1个小人，所以最少需要放置的个数等于连通分量的个数
   *
   * 为什么这样能保证最少数量？
   *
   * 证明：
   * 1. 连通分量的定义：如果两个陆地A和B在同一个连通分量中，
   *    意味着存在一条跳跃路径从A可以到达B（反之亦然）
   *
   * 2. 必要性：如果两个陆地不在同一个连通分量中，它们之间无法通过跳跃连通，
   *    因此必须分别放置小人。所以至少需要"连通分量个数"个小人。
   *
   * 3. 充分性：对于每个连通分量，我们只需要在任意一个陆地上放置1个小人，
   *    这个小人都可以通过跳跃路径到达该连通分量中的所有其他陆地。
   *    所以"连通分量个数"个小人就足够了。
   *
   * 4. 因此，最少数量 = 连通分量个数（这是最优解）
   *
   * 例子说明：
   * 网格：
   *   * * *
   *   . * .
   *   * * *
   *
   * 从(0,0)可以跳到(0,2), (2,0), (2,2)
   * 从(0,1)可以跳到(2,1)
   * 从(0,2)可以跳到(0,0), (2,2)
   * 从(1,1)无法跳到任何地方（上下左右跳2格都会越界）
   * 从(2,0)可以跳到(0,0), (2,2)
   * 从(2,1)可以跳到(0,1)
   * 从(2,2)可以跳到(0,0), (0,2), (2,0)
   *
   * 连通分量1: (0,0), (0,2), (2,0), (2,2) - 需要1个小人
   * 连通分量2: (0,1), (2,1) - 需要1个小人
   * 连通分量3: (1,1) - 需要1个小人
   *
   * 总共需要3个小人，这是最优解。
   *
   * 为什么不能通过"在某个位置不放，在另一个位置放"来减少？
   * 答：因为如果两个陆地不在同一个连通分量中，它们之间无法通过跳跃到达，
   *    所以无论你在哪个位置放置小人，都无法用一个小人同时占领两个不同连通分量的陆地。
   */

  // 如果网格为空，返回0
  if (row === 0 || col === 0) {
    return 0;
  }

  // 用于标记已访问的陆地
  const visited: boolean[][] = Array(row)
    .fill(0)
    .map(() => Array(col).fill(false));

  // 方向数组：上下左右，每次移动2格
  const directions: number[][] = [
    [-2, 0], // 上
    [2, 0], // 下
    [0, -2], // 左
    [0, 2], // 右
  ];

  /**
   * 使用DFS遍历从某个陆地开始的所有可达陆地
   * @param i 当前行
   * @param j 当前列
   */
  function dfs(i: number, j: number): void {
    // 标记当前位置为已访问
    visited[i][j] = true;

    // 尝试向四个方向跳跃（每次跳2格）
    for (const [dx, dy] of directions) {
      const newRow = i + dx;
      const newCol = j + dy;

      // 检查新位置是否在网格范围内
      if (newRow >= 0 && newRow < row && newCol >= 0 && newCol < col) {
        // 检查新位置是否是未访问的陆地
        if (grid[newRow][newCol] === "*" && !visited[newRow][newCol]) {
          // 递归访问新位置
          dfs(newRow, newCol);
        }
      }
    }
  }

  let result = 0; // 记录最少需要的小人数量（即连通分量个数）

  // 遍历整个网格
  for (let i = 0; i < row; i++) {
    for (let j = 0; j < col; j++) {
      // 如果当前位置是陆地且未被访问过
      if (grid[i][j] === "*" && !visited[i][j]) {
        // 从当前位置开始DFS，标记所有可达的陆地
        // 这代表一个连通分量，需要1个小人
        dfs(i, j);
        result++;
      }
    }
  }

  return result;
}

// 测试用例1：你提供的例子
console.log(
  "测试1:",
  count(3, 3, [
    ["*", "*", "*"],
    [".", "*", "."],
    ["*", "*", "*"],
  ])
); // 应该输出 3

// 测试用例2：所有陆地都是*的情况
console.log(
  "测试2:",
  count(3, 3, [
    ["*", "*", "*"],
    ["*", "*", "*"],
    ["*", "*", "*"],
  ])
); // 实际输出 4（因为跳跃规则，形成了4个独立的连通分量）

// 测试用例3：四个角的陆地
console.log(
  "测试3:",
  count(3, 3, [
    ["*", ".", "*"],
    [".", ".", "."],
    ["*", ".", "*"],
  ])
); // 实际输出 1（四个角可以通过跳跃相互到达，形成一个连通分量）

/**
 * ============================================
 * 详细证明：为什么算法能保证最少数量？
 * ============================================
 *
 * 核心原理：图论中的连通分量问题
 *
 * 1. 问题转化：
 *    - 将每个陆地看作图中的一个节点
 *    - 如果从陆地A可以通过跳跃到达陆地B，则在A和B之间连一条边
 *    - 问题转化为：找出图中的所有连通分量
 *
 * 2. 为什么每个连通分量只需要1个小人？
 *    - 连通分量的定义：如果两个节点在同一个连通分量中，
 *      意味着存在一条路径从A可以到达B
 *    - 因此，在连通分量的任意一个节点上放置小人，
 *      这个小人都可以通过跳跃路径到达该连通分量中的所有其他节点
 *    - 所以每个连通分量只需要1个小人
 *
 * 3. 为什么不能通过"在某个位置不放，在另一个位置放"来减少总数？
 *    - 如果两个陆地不在同一个连通分量中，它们之间不存在跳跃路径
 *    - 无论你在哪个位置放置小人，都无法用一个小人同时占领
 *      两个不同连通分量的陆地
 *    - 因此，不同连通分量必须分别放置小人
 *    - 所以最少数量 = 连通分量个数（这是下界，也是上界，因此是最优解）
 *
 * 4. 数学证明：
 *    设连通分量个数为 k
 *    - 下界（必要性）：至少需要 k 个小人（每个连通分量至少1个）
 *    - 上界（充分性）：k 个小人就足够了（每个连通分量放1个）
 *    - 因此，k 是最优解
 *
 * ============================================
 * 测试用例分析
 * ============================================
 *
 * 测试1：网格
 *   * * *
 *   . * .
 *   * * *
 *
 * 连通分量：
 * - 分量1: (0,0), (0,2), (2,0), (2,2) - 相互可达
 * - 分量2: (0,1), (2,1) - 相互可达
 * - 分量3: (1,1) - 孤立（无法跳到任何地方）
 *
 * 结果：3个小人（每个分量1个）
 *
 * 为什么不能更少？
 * - 分量1、分量2、分量3之间无法通过跳跃连通
 * - 所以必须分别放置小人，3个是必须的
 *
 * 测试2：全*网格
 *   * * *
 *   * * *
 *   * * *
 *
 * 连通分量（根据跳跃规则分析）：
 * - 分量1: (0,0), (0,2), (2,0), (2,2) - 四个角
 * - 分量2: (0,1), (2,1) - 中间列
 * - 分量3: (1,0), (1,2) - 中间行
 * - 分量4: (1,1) - 中心（孤立）
 *
 * 结果：4个小人
 *
 * 测试3：四个角
 *   * . *
 *   . . .
 *   * . *
 *
 * 连通分量：
 * - 分量1: (0,0), (0,2), (2,0), (2,2) - 四个角相互可达
 *
 * 结果：1个小人（所有角都在一个连通分量中）
 */
