# JavaScript 垃圾回收与对象引用管理

## 核心概念

当内部函数返回对象给上层时，**只要上层持有对该对象的引用，该对象就不会被垃圾回收**。

### 基本原理

```javascript
function createObject() {
  const obj = { name: "John", age: 30 };
  return obj; // 返回对象引用
}

const myObj = createObject();
// myObj 持有对象的引用，对象不会被回收

// 当 myObj = null 或函数执行完毕且无引用时，对象才会被回收
```

---

## JavaScript 垃圾回收机制

### 1. 标记清除算法（Mark-and-Sweep）- 主流方式

**工作原理**：

```
步骤 1: 标记阶段（Mark）
┌─────────────────────────────────┐
│ 从根对象（Global, Window）开始  │
│ 遍历所有可达对象                 │
│ 标记所有能访问到的对象           │
└─────────────────────────────────┘
         ↓
步骤 2: 清除阶段（Sweep）
┌─────────────────────────────────┐
│ 遍历堆内存                       │
│ 回收未被标记的对象               │
│ 释放内存                         │
└─────────────────────────────────┘
```

**示例**：

```javascript
// 根对象（全局）
const globalObj = { data: "global" };

function outer() {
  const outerObj = { name: "outer" }; // ① 可达（通过调用栈）

  function inner() {
    const innerObj = { name: "inner" }; // ② 可达（通过调用栈）
    return innerObj;
  }

  const returned = inner(); // ③ 可达（returned 引用）
  return returned;
}

const result = outer();
// ✅ result 引用的对象：可达，不会被回收
// ✅ globalObj：可达，不会被回收
// ❌ outerObj：不可达（函数执行完毕），会被回收

result = null;
// ❌ 之前 result 引用的对象：不可达，会被回收
```

### 2. 引用计数算法（Reference Counting）- 辅助方式

**工作原理**：

```javascript
// 每个对象都有一个引用计数器
const obj = { name: "John" }; // 引用计数 = 1

const ref1 = obj; // 引用计数 = 2
const ref2 = obj; // 引用计数 = 3

ref1 = null; // 引用计数 = 2
ref2 = null; // 引用计数 = 1
obj = null; // 引用计数 = 0 → 回收
```

**局限性**：无法处理循环引用

```javascript
// ❌ 循环引用问题
function createCircular() {
  const obj1 = {};
  const obj2 = {};

  obj1.ref = obj2; // obj2 引用计数 +1
  obj2.ref = obj1; // obj1 引用计数 +1

  return obj1;
}

const circular = createCircular();
circular = null;

// 问题：obj1 和 obj2 互相引用，引用计数永远 > 0
// 但实际上已经不可达，应该被回收
// 解决：现代引擎使用标记清除算法
```

---

## 内部函数返回对象的详细分析

### 场景 1：简单返回

```javascript
function createUser() {
  const user = {
    name: "Alice",
    age: 25,
  };

  return user;
}

const myUser = createUser();

// 内存状态：
// ✅ user 对象：被 myUser 引用，不会被回收
// ❌ createUser 的执行上下文：函数执行完毕，被销毁
```

**内存图**：

```
调用栈（执行完后销毁）
┌─────────────────┐
│ createUser()    │
│  └─ user ──┐    │ (局部变量)
└────────────┼────┘
             │
             ↓ return
堆内存（持续存在）
┌─────────────────┐
│ { name, age }   │ ← myUser 引用
└─────────────────┘
  ✅ 不会被回收
```

### 场景 2：闭包返回

```javascript
function createCounter() {
  let count = 0; // ① 被闭包引用

  return {
    increment() {
      count++; // 引用外部变量
    },
    getCount() {
      return count; // 引用外部变量
    },
  };
}

const counter = createCounter();

// 内存状态：
// ✅ 返回的对象：被 counter 引用，不会被回收
// ✅ count 变量：被闭包引用，不会被回收
// ❌ createCounter 的其他局部变量：会被回收

counter.increment();
console.log(counter.getCount()); // 1

counter = null;
// ❌ 现在对象和 count 都不可达，会被回收
```

**内存图**：

```
堆内存
┌──────────────────────────────┐
│ Closure Scope                │
│  count = 0 ←──────┐          │
└───────────────────┼──────────┘
                    │
┌───────────────────┼──────────┐
│ { increment, getCount }      │ ← counter 引用
│   两个方法都引用 count        │
└──────────────────────────────┘
  ✅ 整个闭包链都不会被回收
```

### 场景 3：多层嵌套返回

```javascript
function outer() {
  const outerData = { level: "outer" }; // ①

  function middle() {
    const middleData = { level: "middle" }; // ②

    function inner() {
      const innerData = {
        level: "inner",
        outer: outerData, // 引用外层数据
        middle: middleData, // 引用中层数据
      };

      return innerData;
    }

    return inner();
  }

  return middle();
}

const result = outer();

// 内存状态：
// ✅ result 引用的对象（innerData）：不会被回收
// ✅ outerData：被 innerData 引用，不会被回收
// ✅ middleData：被 innerData 引用，不会被回收
// ❌ outer, middle, inner 的执行上下文：已销毁

console.log(result);
// {
//   level: 'inner',
//   outer: { level: 'outer' },
//   middle: { level: 'middle' }
// }
```

---

## 常见场景分析

### 场景 1：返回的对象包含函数（闭包）

```javascript
function createModule() {
  // 私有变量
  let privateData = "secret";
  const cache = new Map();

  // 返回包含方法的对象
  return {
    getData() {
      return privateData; // 闭包引用
    },

    setData(value) {
      privateData = value; // 闭包引用
    },

    getCached(key) {
      return cache.get(key); // 闭包引用
    },

    setCached(key, value) {
      cache.set(key, value); // 闭包引用
    },
  };
}

const module = createModule();

// ✅ module 对象不会被回收
// ✅ privateData 不会被回收（被闭包引用）
// ✅ cache 不会被回收（被闭包引用）

module.setData("new value");
console.log(module.getData()); // "new value"

// 释放内存
module = null;
// ❌ 现在整个闭包链都不可达，全部被回收
```

### 场景 2：返回的对象被多处引用

```javascript
function createSharedObject() {
  return {
    data: "shared data",
    timestamp: Date.now(),
  };
}

const ref1 = createSharedObject();
const ref2 = ref1; // 增加引用
const ref3 = ref1; // 再增加引用

// 引用计数：3

ref1 = null; // 引用计数：2
ref2 = null; // 引用计数：1

// ✅ ref3 仍然持有引用，对象不会被回收

ref3 = null; // 引用计数：0
// ❌ 现在对象不可达，会被回收
```

### 场景 3：返回的对象添加到集合中

```javascript
function createUser(name) {
  return {
    name: name,
    createdAt: new Date(),
  };
}

const users = [];

// 创建并存储用户
for (let i = 0; i < 1000; i++) {
  const user = createUser(`User${i}`);
  users.push(user); // 添加到数组
}

// ✅ 所有 1000 个用户对象都不会被回收（被 users 数组引用）

// 清理部分用户
users.splice(0, 500); // 删除前 500 个
// ❌ 被删除的 500 个对象不再被引用，会被回收
// ✅ 剩余 500 个对象仍然被引用，不会被回收

users.length = 0; // 清空数组
// ❌ 所有对象都不可达，全部被回收
```

### 场景 4：事件监听器和 DOM 引用

```javascript
function attachHandler() {
  const largeData = new Array(1000000).fill("data"); // 1MB 数据

  const handler = function () {
    console.log("Clicked", largeData.length);
  };

  document.getElementById("btn").addEventListener("click", handler);

  // ⚠️ 问题：即使 attachHandler 执行完毕
  // largeData 仍然被 handler 闭包引用
  // handler 被 DOM 事件监听器引用
  // 导致 largeData 无法被回收（内存泄漏）

  return handler; // 返回 handler 引用（可选）
}

const handler = attachHandler();

// ✅ 解决方案：移除事件监听器
document.getElementById("btn").removeEventListener("click", handler);
// ❌ 现在 handler 和 largeData 都不可达，会被回收
```

---

## 内存泄漏场景

### 1. 意外的全局变量

```javascript
function createObject() {
  // ❌ 忘记使用 var/let/const
  leakedObj = { data: "leaked" };
  return leakedObj;
}

createObject();

// leakedObj 变成了全局变量，永远不会被回收
console.log(window.leakedObj); // { data: "leaked" }

// ✅ 解决方案：使用严格模式
("use strict");
function createObject() {
  leakedObj = { data: "leaked" }; // ReferenceError
  return leakedObj;
}
```

### 2. 闭包引用大对象

```javascript
function createClosure() {
  const hugeArray = new Array(10000000).fill("data"); // 约 80MB

  // ❌ 问题：闭包只需要 name，但引用了整个作用域
  const name = hugeArray[0];

  return function () {
    console.log(name);
    // 整个 hugeArray 都被保留在内存中
  };
}

const fn = createClosure();
// ⚠️ 80MB 无法释放

// ✅ 解决方案：只保留需要的数据
function createClosureOptimized() {
  const hugeArray = new Array(10000000).fill("data");
  const name = hugeArray[0]; // 提取需要的值

  // 断开对 hugeArray 的引用
  hugeArray.length = 0;

  return function () {
    console.log(name); // 只保留 name
  };
}
```

### 3. 定时器引用

```javascript
function startTimer() {
  const largeData = new Array(1000000).fill("data");

  setInterval(() => {
    console.log("Timer running", largeData.length);
  }, 1000);

  // ❌ 问题：定时器一直运行，largeData 永远不会被回收
}

startTimer();

// ✅ 解决方案：清除定时器
function startTimerFixed() {
  const largeData = new Array(1000000).fill("data");

  const timerId = setInterval(() => {
    console.log("Timer running", largeData.length);
  }, 1000);

  // 返回清理函数
  return () => {
    clearInterval(timerId);
    // 现在 largeData 可以被回收
  };
}

const cleanup = startTimerFixed();
// 需要时清理
cleanup();
```

### 4. DOM 引用

```javascript
function createDOMReference() {
  const element = document.getElementById("myDiv");
  const data = {
    element: element, // ❌ 持有 DOM 引用
    info: "some data",
  };

  return data;
}

const myData = createDOMReference();

// 即使 DOM 元素被移除
document.getElementById("myDiv").remove();

// ⚠️ myData.element 仍然持有 DOM 引用
// DOM 元素无法被回收（分离的 DOM 节点）

console.log(myData.element); // 仍然可以访问

// ✅ 解决方案：使用 WeakMap
const domDataMap = new WeakMap();

function createDOMReferenceFixed() {
  const element = document.getElementById("myDiv");
  const data = { info: "some data" };

  domDataMap.set(element, data); // 弱引用

  return data; // 不直接引用 element
}

// 当 DOM 元素被移除时，WeakMap 的条目会自动清理
```

---

## 可达性（Reachability）分析

### 根对象（GC Roots）

```javascript
// 以下是根对象，永远不会被回收：

// 1. 全局对象
window.globalVar = { data: "global" };

// 2. 当前执行上下文的局部变量
function fn() {
  const local = { data: "local" }; // 函数执行时是根对象
}

// 3. 活动的函数调用栈
function a() {
  const objA = {};
  b(objA);
}
function b(param) {
  // param 是根对象（在调用栈上）
}

// 4. 定时器、事件监听器的回调函数
setInterval(() => {
  // 这个函数是根对象
}, 1000);
```

### 可达性示例

```javascript
function example() {
  const obj1 = { name: "obj1" }; // ①
  const obj2 = { name: "obj2" }; // ②
  const obj3 = { name: "obj3" }; // ③

  obj1.ref = obj2; // obj1 → obj2
  obj2.ref = obj3; // obj2 → obj3

  return obj1; // 只返回 obj1
}

const root = example();

// 可达性分析：
// root → obj1 → obj2 → obj3
// ✅ 所有对象都可达，都不会被回收

root.ref = null; // 切断 obj1 → obj2 的引用

// 新的可达性：
// root → obj1 (只能到这里)
// ✅ obj1：可达
// ❌ obj2, obj3：不可达，会被回收
```

---

## 实际案例

### 案例 1：React 组件中的对象管理

```javascript
// React 组件
function UserProfile() {
  // ① 每次渲染都会创建新对象
  const user = {
    name: "John",
    age: 30,
  };

  // ❌ 问题：每次渲染都创建新对象，旧对象被回收
  // 可能导致性能问题

  return <div>{user.name}</div>;
}

// ✅ 优化：使用 useMemo
function UserProfileOptimized() {
  const user = useMemo(
    () => ({
      name: "John",
      age: 30,
    }),
    [] // 依赖为空，只创建一次
  );

  return <div>{user.name}</div>;
}

// ✅ 更好：提升到组件外部
const USER = { name: "John", age: 30 };

function UserProfileBest() {
  return <div>{USER.name}</div>;
}
```

### 案例 2：缓存管理

```javascript
// ❌ 问题：无限增长的缓存
const cache = {};

function getCachedData(key) {
  if (cache[key]) {
    return cache[key];
  }

  const data = fetchData(key); // 耗时操作
  cache[key] = data; // 永远不会被清理
  return data;
}

// ⚠️ cache 对象会无限增长，导致内存泄漏

// ✅ 解决方案1：使用 WeakMap
const cacheWeak = new WeakMap();

function getCachedDataWeak(keyObject) {
  if (cacheWeak.has(keyObject)) {
    return cacheWeak.get(keyObject);
  }

  const data = fetchData(keyObject);
  cacheWeak.set(keyObject, data);
  return data;
}

// 当 keyObject 不再被引用时，缓存条目自动清理

// ✅ 解决方案2：LRU 缓存
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) return null;

    const value = this.cache.get(key);
    // 移到末尾（最近使用）
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }

    this.cache.set(key, value);

    // 超过容量，删除最久未使用的
    if (this.cache.size > this.capacity) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
      // ❌ 被删除的条目现在可以被 GC 回收
    }
  }
}

const lruCache = new LRUCache(100); // 最多 100 个条目
```

### 案例 3：工厂函数返回实例

```javascript
class User {
  constructor(name, data) {
    this.name = name;
    this.data = data; // 可能很大
  }
}

function createUsers(count) {
  const users = [];

  for (let i = 0; i < count; i++) {
    const user = new User(`User${i}`, new Array(10000).fill(i));
    users.push(user);
  }

  return users;
}

const allUsers = createUsers(1000);
// ✅ 1000 个 User 实例都被 allUsers 引用，不会被回收

// 处理完某些用户后，释放内存
allUsers.splice(0, 500);
// ❌ 前 500 个用户不再被引用，会被回收
// ✅ 后 500 个用户仍然被引用，保留在内存
```

---

## 内存泄漏检测

### 1. Chrome DevTools Memory 面板

```javascript
// 测试内存泄漏的代码
let leakedObjects = [];

function createLeak() {
  const obj = {
    data: new Array(100000).fill("leak"),
    timestamp: Date.now(),
  };

  leakedObjects.push(obj); // 永远不会被清理

  return obj;
}

// 检测步骤：
// 1. 打开 Chrome DevTools → Memory
// 2. 拍摄堆快照（Heap Snapshot）
// 3. 执行 createLeak() 多次
// 4. 再次拍摄快照
// 5. 对比两次快照，找到增长的对象
```

### 2. Performance Monitor

```javascript
// 监控内存使用
if (performance.memory) {
  setInterval(() => {
    console.log({
      usedJSHeapSize:
        (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + " MB",
      totalJSHeapSize:
        (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + " MB",
      jsHeapSizeLimit:
        (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2) + " MB",
    });
  }, 1000);
}
```

### 3. 自定义内存监控

```javascript
class MemoryMonitor {
  constructor() {
    this.snapshots = [];
    this.leakThreshold = 50 * 1024 * 1024; // 50MB
  }

  takeSnapshot() {
    if (!performance.memory) {
      console.warn("performance.memory not supported");
      return;
    }

    const snapshot = {
      timestamp: Date.now(),
      usedMemory: performance.memory.usedJSHeapSize,
      totalMemory: performance.memory.totalJSHeapSize,
    };

    this.snapshots.push(snapshot);

    // 保留最近 10 个快照
    if (this.snapshots.length > 10) {
      this.snapshots.shift();
    }

    return snapshot;
  }

  detectLeak() {
    if (this.snapshots.length < 2) {
      return false;
    }

    const first = this.snapshots[0];
    const last = this.snapshots[this.snapshots.length - 1];
    const growth = last.usedMemory - first.usedMemory;

    if (growth > this.leakThreshold) {
      console.warn(`⚠️ 检测到内存泄漏: ${(growth / 1048576).toFixed(2)} MB`);
      return true;
    }

    return false;
  }

  startMonitoring(interval = 5000) {
    setInterval(() => {
      const snapshot = this.takeSnapshot();
      console.log(`内存使用: ${(snapshot.usedMemory / 1048576).toFixed(2)} MB`);

      if (this.detectLeak()) {
        // 触发警报或上报
        this.reportLeak();
      }
    }, interval);
  }

  reportLeak() {
    // 发送到监控服务
    fetch("/api/memory-leak", {
      method: "POST",
      body: JSON.stringify({
        snapshots: this.snapshots,
        url: window.location.href,
        userAgent: navigator.userAgent,
      }),
    });
  }
}

// 使用
const monitor = new MemoryMonitor();
monitor.startMonitoring();
```

---

## 最佳实践

### 1. 及时释放引用

```javascript
// ❌ 不好
function processData() {
  const data = fetchLargeData();
  const result = transform(data);

  // data 在整个函数执行期间都占用内存
  doSomethingElse();

  return result;
}

// ✅ 好
function processDataOptimized() {
  let data = fetchLargeData();
  const result = transform(data);

  data = null; // 立即释放

  doSomethingElse();

  return result;
}
```

### 2. 使用 WeakMap/WeakSet

```javascript
// ❌ 使用普通 Map
const metadataMap = new Map();

function attachMetadata(element, data) {
  metadataMap.set(element, data);
}

// 问题：即使 element 被移除，Map 仍然持有引用

// ✅ 使用 WeakMap
const metadataWeakMap = new WeakMap();

function attachMetadataWeak(element, data) {
  metadataWeakMap.set(element, data);
}

// 当 element 不再被引用时，WeakMap 条目自动清理
```

### 3. 清理事件监听器

```javascript
// ❌ 不好
class Component {
  constructor() {
    this.data = new Array(100000).fill("data");

    window.addEventListener("resize", () => {
      this.handleResize(); // 闭包引用 this.data
    });
  }

  handleResize() {
    console.log(this.data.length);
  }
}

// 组件销毁时，事件监听器仍然存在，导致内存泄漏

// ✅ 好
class ComponentFixed {
  constructor() {
    this.data = new Array(100000).fill("data");
    this.handleResize = this.handleResize.bind(this);

    window.addEventListener("resize", this.handleResize);
  }

  handleResize() {
    console.log(this.data.length);
  }

  destroy() {
    window.removeEventListener("resize", this.handleResize);
    this.data = null; // 释放数据
  }
}
```

### 4. 避免循环引用

```javascript
// ❌ 循环引用
function createCircular() {
  const obj1 = { name: "obj1" };
  const obj2 = { name: "obj2" };

  obj1.ref = obj2;
  obj2.ref = obj1; // 循环引用

  return obj1;
}

// 现代引擎的标记清除算法可以处理这种情况
// 但仍应避免不必要的循环引用

// ✅ 使用 WeakRef（ES2021）
function createWithWeakRef() {
  const obj1 = { name: "obj1" };
  const obj2 = { name: "obj2" };

  obj1.ref = new WeakRef(obj2); // 弱引用

  return obj1;
}

// 访问弱引用
const obj = createWithWeakRef();
const ref = obj.ref.deref(); // 可能返回 undefined（如果已被回收）
if (ref) {
  console.log(ref.name);
}
```

---

## V8 引擎的垃圾回收机制

### 分代回收（Generational GC）

```
┌────────────────────────────────────┐
│ 新生代（Young Generation）          │
│ - 新创建的对象                      │
│ - 生命周期短                        │
│ - 使用 Scavenge 算法                │
│ - 频繁 GC（minor GC）               │
│ - 空间小（约 1-8MB）                │
└────────────────────────────────────┘
         ↓ 晋升（多次 GC 后仍存活）
┌────────────────────────────────────┐
│ 老生代（Old Generation）            │
│ - 长期存活的对象                    │
│ - 使用 Mark-Sweep 算法              │
│ - 不频繁 GC（major GC）             │
│ - 空间大                            │
└────────────────────────────────────┘
```

### 代码示例

```javascript
function demonstrateGenerations() {
  // ① 新生代对象
  const temp = { temporary: "data" };

  // ② 短生命周期，很快被回收
  for (let i = 0; i < 1000; i++) {
    const obj = { index: i };
    // 循环结束后，这些对象都在新生代被回收
  }

  // ③ 长生命周期对象
  const persistent = { data: "persistent" };

  // ④ 经过多次 minor GC 后，persistent 晋升到老生代
  return persistent;
}

const longLived = demonstrateGenerations();
// longLived 会在老生代中长期存在
```

---

## 内存管理工具函数

### 1. 对象池模式

```javascript
class ObjectPool {
  constructor(factory, resetFn, initialSize = 10) {
    this.factory = factory; // 创建对象的工厂函数
    this.resetFn = resetFn; // 重置对象的函数
    this.pool = [];

    // 预创建对象
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.factory());
    }
  }

  acquire() {
    // 从池中取对象
    if (this.pool.length > 0) {
      return this.pool.pop();
    }

    // 池为空，创建新对象
    return this.factory();
  }

  release(obj) {
    // 重置对象
    this.resetFn(obj);

    // 放回池中
    this.pool.push(obj);
  }

  get size() {
    return this.pool.length;
  }
}

// 使用示例
const pointPool = new ObjectPool(
  () => ({ x: 0, y: 0 }), // 工厂函数
  (point) => {
    // 重置函数
    point.x = 0;
    point.y = 0;
  },
  100 // 初始大小
);

// 获取对象
const point = pointPool.acquire();
point.x = 10;
point.y = 20;
console.log(point);

// 使用完毕，释放回池
pointPool.release(point);

// 对象被重用，减少 GC 压力
```

### 2. 手动触发 GC（仅 Node.js）

```javascript
// Node.js 环境
// 启动时添加 --expose-gc 标志
// node --expose-gc app.js

function processLargeData() {
  const data = new Array(10000000).fill("data");

  // 处理数据
  const result = transform(data);

  // 手动触发 GC（仅开发/测试环境）
  if (global.gc) {
    global.gc();
    console.log("手动触发 GC");
  }

  return result;
}
```

---

## 总结

### 核心原则

| 原则             | 说明                         |
| ---------------- | ---------------------------- |
| **引用决定生命** | 有引用 = 存活，无引用 = 回收 |
| **标记清除**     | 主流算法，从根对象开始标记   |
| **分代回收**     | 新生代频繁 GC，老生代不频繁  |
| **弱引用**       | WeakMap/WeakSet 不阻止 GC    |

### 对象回收时机

```javascript
function example() {
  const obj = { data: "example" };
  return obj;
}

const result = example();
// ✅ obj 被 result 引用，不会被回收

result = null;
// ❌ obj 不再被引用，等待 GC 回收
// ⚠️ 注意：不是立即回收，而是在下次 GC 时

// GC 触发时机（不可控）：
// - 内存使用达到阈值
// - 空闲时期
// - 手动触发（仅 Node.js with --expose-gc）
```

### 避免内存泄漏的检查清单

✅ **检查清单**：

- [ ] 全局变量是否必要？
- [ ] 定时器是否清理？
- [ ] 事件监听器是否移除？
- [ ] 闭包是否引用大对象？
- [ ] DOM 引用是否及时清除？
- [ ] 缓存是否有上限？
- [ ] 循环引用是否避免？

### 关键要点

1. **内部函数返回的对象只要有引用就不会被回收**
2. **闭包会保持对外部变量的引用**
3. **使用 WeakMap/WeakSet 避免内存泄漏**
4. **及时释放不需要的引用**
5. **定期检测内存增长**

掌握这些知识，能有效避免内存泄漏，提升应用性能！
