/*
 * @lc app=leetcode.cn id=695 lang=typescript
 *
 * [695] 岛屿的最大面积
 *
 * https://leetcode.cn/problems/max-area-of-island/description/
 *
 * algorithms
 * Medium (68.74%)
 * Likes:    1166
 * Dislikes: 0
 * Total Accepted:    390.9K
 * Total Submissions: 568.5K
 * Testcase Example:  '[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]'
 *
 * 给你一个大小为 m x n 的二进制矩阵 grid 。
 *
 * 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid
 * 的四个边缘都被 0（代表水）包围着。
 *
 * 岛屿的面积是岛上值为 1 的单元格的数目。
 *
 * 计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：grid =
 * [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
 * 输出：6
 * 解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
 *
 *
 * 示例 2：
 *
 *
 * 输入：grid = [[0,0,0,0,0,0,0,0]]
 * 输出：0
 *
 *
 *
 *
 * 提示：
 *
 *
 * m == grid.length
 * n == grid[i].length
 * 1 <= m, n <= 50
 * grid[i][j] 为 0 或 1
 *
 *
 */

// @lc code=start
/**
 * 解法：深度优先搜索（DFS）
 *
 * 算法思路：
 * 1. 遍历整个二维网格的每个单元格
 * 2. 当遇到陆地（值为 1）时，启动 DFS 计算该岛屿的面积
 * 3. DFS 过程中将访问过的陆地标记为 0，避免重复计算
 * 4. 记录并返回所有岛屿中的最大面积
 *
 * 时间复杂度：O(m * n)，其中 m 和 n 分别是网格的行数和列数
 *   - 每个单元格最多被访问一次
 *
 * 空间复杂度：O(m * n)
 *   - 最坏情况下（整个网格都是陆地），递归调用栈的深度可达 m * n
 *   - 没有使用额外的数据结构（原地修改网格作为访问标记）
 */
function maxAreaOfIsland(grid: number[][]): number {
  // 边界处理：如果网格为空，直接返回 0
  if (grid.length === 0 || grid[0].length === 0) {
    return 0;
  }

  const m = grid.length; // 网格的行数
  const n = grid[0].length; // 网格的列数
  let maxArea = 0; // 记录最大岛屿面积

  /**
   * DFS 辅助函数：计算从位置 (i, j) 开始的岛屿面积
   *
   * @param i - 当前单元格的行索引
   * @param j - 当前单元格的列索引
   * @returns 从当前位置能够到达的岛屿总面积
   *
   * 工作原理：
   * 1. 递归终止条件：越界或遇到水（0）则返回 0
   * 2. 将当前陆地标记为 0（表示已访问，防止重复计算）
   * 3. 递归计算上下左右四个方向的面积
   * 4. 返回当前单元格（面积为 1）加上四个方向的总面积
   */
  const dfs = (i: number, j: number): number => {
    // 递归终止条件：
    // - i < 0 || i >= m：行索引越界
    // - j < 0 || j >= n：列索引越界
    // - grid[i][j] === 0：遇到水域或已访问过的陆地
    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] === 0) {
      return 0;
    }

    // 将当前陆地标记为 0，表示已访问
    // 这样可以避免重复计算，同时不需要额外的 visited 数组
    grid[i][j] = 0;

    // 计算岛屿面积：当前单元格（1）+ 四个方向的递归结果
    // 采用累加方式更清晰地展示面积计算过程
    let area = 1; // 当前单元格本身贡献面积 1
    area += dfs(i - 1, j); // 向上搜索
    area += dfs(i + 1, j); // 向下搜索
    area += dfs(i, j - 1); // 向左搜索
    area += dfs(i, j + 1); // 向右搜索

    return area;
  };

  // 遍历网格的每个单元格
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      // 当遇到未访问的陆地时，启动一次 DFS
      if (grid[i][j] === 1) {
        const area = dfs(i, j); // 计算当前岛屿的面积
        maxArea = Math.max(maxArea, area); // 更新最大面积
      }
    }
  }

  return maxArea;
}
// @lc code=end
