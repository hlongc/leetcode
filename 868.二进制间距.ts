/*
 * @lc app=leetcode.cn id=868 lang=typescript
 *
 * [868] 二进制间距
 *
 * 题目描述：
 * 给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。
 * 如果不存在两个相邻的 1，返回 0 。
 *
 * 如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 是 "相邻" 的。
 * 两个 1 之间的距离是它们的二进制表示中位置的绝对差。
 */

// @lc code=start
/**
 * 查找二进制表示中相邻的1之间的最长距离
 *
 * @param n 要检查的正整数
 * @returns 二进制表示中相邻1之间的最长距离
 */
function binaryGap(n: number): number {
  // 特殊情况：如果n小于3，则不可能有间距超过1的两个1
  if (n < 3) return 0;

  // 将数字转换为二进制字符串，去掉前缀"0b"
  const binary = n.toString(2);

  // 记录最大间距
  let maxGap = 0;
  // 记录上一个1的位置
  let lastOnePos = -1;

  // 遍历二进制字符串的每一位
  for (let i = 0; i < binary.length; i++) {
    // 如果当前位是1
    if (binary[i] === "1") {
      // 如果这不是第一个遇到的1
      if (lastOnePos !== -1) {
        // 计算当前1与上一个1之间的距离
        const gap = i - lastOnePos;
        // 更新最大间距
        maxGap = Math.max(maxGap, gap);
      }
      // 更新上一个1的位置
      lastOnePos = i;
    }
  }

  return maxGap;
}

/**
 * 解题思路：
 *
 * 1. 将整数转换为二进制字符串表示，这样方便我们遍历每一位
 *
 * 2. 遍历二进制字符串：
 *    - 当遇到1时，检查上一个1的位置
 *    - 如果已经遇到过1，则计算当前1与上一个1之间的距离
 *    - 更新最大间距和上一个1的位置
 *
 * 3. 特殊情况处理：
 *    - 如果n小于3，它的二进制表示不可能有间距超过1的两个1
 *      (因为n=1是"1"，n=2是"10")
 *
 * 4. 时间复杂度分析：
 *    - 转换为二进制表示：O(log n)
 *    - 遍历二进制表示的每一位：O(log n)
 *    - 总时间复杂度：O(log n)
 *
 * 5. 空间复杂度：O(log n)，用于存储二进制字符串
 *
 * 注意：一个正整数n的二进制表示长度大约是log₂(n)位
 */
// @lc code=end
