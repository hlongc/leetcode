/*
 * @lc app=leetcode.cn id=169 lang=typescript
 *
 * [169] 多数元素
 *
 * 给定一个大小为 n 的数组 nums，返回其中的多数元素。
 * 多数元素是指在数组中出现次数大于 ⌊n/2⌋ 的元素。
 * 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
 */

// @lc code=start
/**
 * 使用位运算查找多数元素
 *
 * 思路：
 * 1. 我们知道多数元素出现次数大于 n/2
 * 2. 考虑二进制表示，对于多数元素的每一位，如果该位为1，则数组中该位为1的元素超过n/2个
 * 3. 统计每一位1的个数，如果数量超过n/2，则结果的该位应该为1
 *
 * 举例：
 * nums = [3,2,3]
 * 3的二进制是 11，2的二进制是 10
 * 第0位：1+0+1 = 2个1，超过3/2，所以结果第0位是1
 * 第1位：1+1+1 = 3个1，超过3/2，所以结果第1位是1
 * 结果 = 11(二进制) = 3(十进制)
 *
 * 详细步骤示例：
 *
 * 以数组 [2,2,1,1,1,2,2] 为例：
 *
 * 2的二进制表示：10
 * 1的二进制表示：01
 *
 * 第0位统计：
 * - 2的第0位：0（四个2，所以有0个1）
 * - 1的第0位：1（三个1，所以有3个1）
 * - 总共3个1，不超过7/2=3.5，所以结果第0位是0
 *
 * 第1位统计：
 * - 2的第1位：1（四个2，所以有4个1）
 * - 1的第1位：0（三个1，所以有0个1）
 * - 总共4个1，超过7/2=3.5，所以结果第1位是1
 *
 * 结果：10(二进制) = 2(十进制)
 *
 * 注意事项：
 * 1. 这种方法只适用于找出确实存在的多数元素
 * 2. 对于处理负数，需要特别注意符号位的处理
 * 3. 在JavaScript中，位运算会将操作数转换为32位有符号整数
 *
 * 时间复杂度：O(32n)，即O(n)，n是数组长度
 * 空间复杂度：O(1)
 *
 * @param nums 输入数组
 * @returns 多数元素
 */
function majorityElement1(nums: number[]): number {
  let result = 0;
  const n = nums.length;

  // 对整数的每一位（最多32位）进行处理
  for (let i = 0; i < 32; i++) {
    let count = 0;

    // 统计所有数字在第i位上1的个数
    for (const num of nums) {
      // 检查num的第i位是否为1
      if ((num >> i) & 1) {
        count++;
      }
    }

    // 如果该位上1的个数超过n/2，说明多数元素在该位上是1
    if (count > n / 2) {
      // 将结果的第i位设置为1
      result |= 1 << i;
    }
  }

  return result;
}

/**
 * 使用摩尔投票算法查找多数元素
 *
 * 思路：
 * 1. 摩尔投票算法基于"抵消"的思想
 * 2. 维护一个候选元素和一个计数器
 * 3. 遇到与候选元素相同的元素，计数器加1；不同则减1
 * 4. 当计数器为0时，更换候选元素
 * 5. 由于多数元素出现次数 > n/2，最后剩下的候选元素必定是多数元素
 *
 * 时间复杂度：O(n)，只需遍历一次数组
 * 空间复杂度：O(1)，只使用两个变量
 *
 * @param nums 输入数组
 * @returns 多数元素
 */
function majorityElement(nums: number[]): number {
  // candidate: 当前的候选多数元素
  let candidate = 0;

  // count: 候选元素的计数器
  let count = 0;

  // 遍历数组中的每个元素
  for (const num of nums) {
    // 如果计数器为0，选择当前元素作为新的候选元素
    if (count === 0) {
      candidate = num;
    }

    // 如果当前元素等于候选元素，计数器加1；否则减1
    count += candidate === num ? 1 : -1;
  }

  // 返回候选元素，由于题目保证存在多数元素，所以candidate必定是答案
  return candidate;
}
// @lc code=end

/**
 * 摩尔投票算法示例：
 *
 * 以数组 [2,2,1,1,1,2,2] 为例：
 *
 * 初始状态：candidate = 0, count = 0
 *
 * 1. 遍历到2：count = 0，设置candidate = 2，然后count = 1
 * 2. 遍历到2：candidate = 2，count = 1+1 = 2
 * 3. 遍历到1：candidate = 2，count = 2-1 = 1
 * 4. 遍历到1：candidate = 2，count = 1-1 = 0
 * 5. 遍历到1：count = 0，设置candidate = 1，然后count = 1
 * 6. 遍历到2：candidate = 1，count = 1-1 = 0
 * 7. 遍历到2：count = 0，设置candidate = 2，然后count = 1
 *
 * 最终：candidate = 2, count = 1
 *
 * 返回结果：2（这确实是该数组的多数元素）
 *
 * 为什么摩尔投票算法有效？
 * - 如果将多数元素记为+1，其他元素记为-1
 * - 由于多数元素出现次数 > n/2，所以数组所有元素的和必定 > 0
 * - 当我们遇到计数器为0时，意味着前面的元素"两两抵消"了
 * - 无论如何抵消，多数元素的剩余数量仍然多于其他元素
 * - 因此最后的候选元素必定是多数元素
 */
