# 02 - React双缓存机制详解

> **问题**: React的双缓存机制（Double Buffering）是如何工作的？current树和workInProgress树的关系是什么？

---

## 一、什么是双缓存（Double Buffering）？

双缓存是一种在计算机图形学中常用的技术，**在React中指同时存在两棵Fiber树**：

- **current树**：当前屏幕上显示的内容对应的Fiber树
- **workInProgress树**：正在内存中构建的Fiber树

这种设计类似于**显卡的双缓冲技术**：
- 前台缓冲区（Front Buffer）→ current树 → 用户看到的页面
- 后台缓冲区（Back Buffer）→ workInProgress树 → 内存中构建

### 为什么需要双缓存？

```
没有双缓存的问题：
┌────────────────────┐
│  直接修改DOM树     │
│  ↓ 修改A组件       │
│  ↓ 修改B组件       │ ← 用户看到部分更新，页面闪烁
│  ↓ 修改C组件       │
│  ✓ 完成            │
└────────────────────┘

有双缓存的优势：
┌─────────────┐    ┌──────────────────┐
│  current树  │    │ workInProgress树 │
│  (显示中)   │    │  (内存构建)      │
│             │    │  ✓ 修改A组件      │
│  用户正常   │    │  ✓ 修改B组件      │
│  使用页面   │    │  ✓ 修改C组件      │
│             │    │  ✓ 构建完成       │
└─────────────┘    └──────────────────┘
                            ↓
                   【一次性切换指针】
                            ↓
                   ┌──────────────────┐
                   │   新的current树  │
                   │   (瞬间切换)     │
                   └──────────────────┘
```

**核心优势**：
1. **避免页面闪烁**：在内存中完成所有计算，一次性展示
2. **支持中断**：可以随时放弃workInProgress树，current树不受影响
3. **性能优化**：复用Fiber节点，通过`alternate`属性相互引用

---

## 二、双缓存的核心实现

### 1. FiberRoot与Fiber树的关系

源码：`packages/react-reconciler/src/ReactFiberRoot.js`

```javascript
// FiberRoot的创建
export function createFiberRoot(
  containerInfo: Container,
  tag: RootTag,
  // ... 其他参数
): FiberRoot {
  // 创建FiberRootNode
  const root: FiberRoot = new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    onDefaultTransitionIndicator,
    formState,
  );

  // 创建rootFiber（HostRoot类型的Fiber节点）
  const uninitializedFiber = createHostRootFiber(tag, isStrictMode);
  
  // 建立双向引用
  root.current = uninitializedFiber;        // FiberRoot指向current树
  uninitializedFiber.stateNode = root;      // rootFiber指向FiberRoot

  // 初始化缓存
  const initialCache = createCache();
  retainCache(initialCache);
  
  return root;
}
```

**数据结构关系图**：

```
┌──────────────────────┐
│   FiberRootNode      │  ← 整个应用的根节点
│   (唯一实例)         │
│                      │
│   containerInfo: div │  ← DOM容器 (ReactDOM.createRoot的参数)
│   current: ────────► │  ← 指向当前的rootFiber
│   ...                │
└──────────────────────┘
          │
          ↓ current
┌──────────────────────┐
│   rootFiber          │  ← HostRoot类型的Fiber节点
│   (current树的根)    │
│                      │
│   tag: HostRoot (3)  │
│   stateNode: ───────►│  ← 指回FiberRoot
│   alternate: ───────►│  ← 指向workInProgress树的rootFiber
│   child: ───────────►│  ← 指向App组件的Fiber
│   ...                │
└──────────────────────┘
          │
          ↓ child
┌──────────────────────┐
│   App Fiber          │
│   ...                │
└──────────────────────┘
```

### 2. alternate属性：双缓存的桥梁

源码：`packages/react-reconciler/src/ReactFiber.js`

```javascript
// 创建workInProgress树
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  let workInProgress = current.alternate;
  
  if (workInProgress === null) {
    // 首次渲染：创建新的Fiber节点
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode,
    );
    
    // 复制不变的属性
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    // 建立双向引用 - 这是双缓存的核心！
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // 更新阶段：复用已有的alternate节点
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;

    // 清空副作用标记（上次更新遗留的）
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;

    if (enableProfilerTimer) {
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  // 复制其他属性
  workInProgress.flags = current.flags & StaticMask;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  
  // 克隆dependencies
  const currentDependencies = current.dependencies;
  workInProgress.dependencies =
    currentDependencies === null
      ? null
      : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext,
        };

  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;

  return workInProgress;
}
```

**关键理解**：
- **首次渲染**：current树的每个节点都会创建对应的workInProgress节点
- **更新阶段**：直接复用上次的alternate节点，只更新必要的属性
- **双向引用**：current.alternate = workInProgress，workInProgress.alternate = current

---

## 三、双缓存的完整工作流程

### 阶段1：mount（首次渲染）

```javascript
// 用户代码
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

**步骤详解**：

```
1. 创建FiberRoot和rootFiber
┌──────────────┐
│  FiberRoot   │
│  current ───►│───► rootFiber (current树)
└──────────────┘     stateNode ───► FiberRoot
                     child: null
                     alternate: null

2. 调用render时，开始构建workInProgress树
   prepareFreshStack(root, lanes)
   ↓
   创建workInProgress rootFiber

┌──────────────┐
│  FiberRoot   │
│  current ───►│───► rootFiber (current)
└──────────────┘     ├─ alternate ──────┐
                     │                   ↓
                     │        workInProgress rootFiber
                     │        ├─ alternate ────► current rootFiber
                     │        ├─ child: null (待构建)
                     │        └─ ...

3. beginWork阶段：构建Fiber树
   workLoop() {
     while (workInProgress !== null) {
       performUnitOfWork(workInProgress)
     }
   }

   构建过程：
   workInProgress rootFiber
   └─ child ─► App Fiber (workInProgress)
               ├─ alternate: null (mount阶段)
               └─ child ─► Header Fiber
                           └─ child ─► ...

4. completeWork阶段：创建DOM节点
   - 为每个HostComponent创建真实DOM
   - 将DOM节点挂载到stateNode
   - 收集副作用

5. commit阶段：切换current树
   【核心代码】
   root.current = finishedWork;  ← 切换指针！
   
   切换后：
   ┌──────────────┐
   │  FiberRoot   │
   │  current ───►│───► workInProgress rootFiber (现在是current树)
   └──────────────┘     └─ child ─► App Fiber
                                    └─ child ─► Header Fiber
                                                └─ stateNode: <header>节点
```

**关键代码**：

```javascript
// packages/react-reconciler/src/ReactFiberWorkLoop.js

// 准备新的工作栈
function prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {
  // ... 清理工作
  
  workInProgressRoot = root;
  // 基于current树创建workInProgress树
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = lanes;
  // ...
  
  return rootWorkInProgress;
}
```

### 阶段2：update（更新阶段）

```javascript
// 用户触发更新
function App() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**更新流程**：

```
初始状态：
┌──────────────┐
│  FiberRoot   │
│  current ───►│───► rootFiber (current树)
└──────────────┘     └─ child ─► App Fiber
                                 ├─ memoizedState: { count: 0 }
                                 ├─ alternate ──────► App Fiber (旧的workInProgress)
                                 └─ child ─► div Fiber
                                             └─ child ─► p Fiber (显示 "Count: 0")

1. 用户点击按钮，触发setState
   ↓
   创建update对象，加入updateQueue
   ↓
   调度更新（scheduleUpdateOnFiber）

2. 开始render阶段
   prepareFreshStack(root, lanes)
   ↓
   复用alternate创建新的workInProgress树

   workInProgress rootFiber (基于current.alternate)
   └─ child ─► App Fiber (workInProgress)
               ├─ alternate ────► App Fiber (current)
               ├─ pendingProps: ...
               ├─ updateQueue: [update对象]
               └─ child: null (待协调)

3. beginWork阶段：协调(reconciliation)
   updateFunctionComponent(App Fiber)
   ↓
   执行App函数：const [count, setCount] = useState(0)
   ↓
   处理updateQueue，计算新state：{ count: 1 }
   ↓
   执行render：返回新的React元素树
   ↓
   reconcileChildren：diff算法
   
   对比：
   current:       div -> p("Count: 0")
   新元素:        div -> p("Count: 1")
   
   diff结果：
   - div节点可复用（key和type相同）
   - p节点可复用，但内容变化 → 标记Update flag
   
   生成新的workInProgress树：
   workInProgress rootFiber
   └─ child ─► App Fiber (wip)
               ├─ memoizedState: { count: 1 } ← 新state
               ├─ alternate ────► App Fiber (current, count: 0)
               └─ child ─► div Fiber (wip)
                           ├─ alternate ────► div Fiber (current)
                           └─ child ─► p Fiber (wip)
                                       ├─ flags: Update  ← 标记需要更新
                                       ├─ alternate ────► p Fiber (current)
                                       └─ stateNode: <p>DOM节点

4. completeWork阶段：准备DOM更新
   - 收集所有带Update flag的节点
   - 准备新的文本内容："Count: 1"
   - 向上冒泡subtreeFlags

5. commit阶段：提交更新
   
   5.1 before mutation阶段
       - 调用getSnapshotBeforeUpdate
   
   5.2 mutation阶段
       - 执行DOM操作
       - 更新p节点的textContent: "Count: 0" → "Count: 1"
       - 调用componentWillUnmount（如有删除的组件）
   
   5.3 切换current树（关键！）
       【源码位置：ReactFiberWorkLoop.js:3877】
       root.current = finishedWork;  ← finishedWork就是workInProgress树
       
       切换后：
       ┌──────────────┐
       │  FiberRoot   │
       │  current ───►│───► rootFiber (新的current树，原workInProgress)
       └──────────────┘     └─ child ─► App Fiber
                                        ├─ memoizedState: { count: 1 }
                                        └─ child ─► div Fiber
                                                    └─ child ─► p Fiber
                                                                └─ textContent: "Count: 1"
   
   5.4 layout阶段
       - 调用componentDidMount/Update
       - 调用useLayoutEffect
   
   5.5 passive阶段（异步）
       - 调用useEffect
```

**源码验证**：

```javascript
// packages/react-reconciler/src/ReactFiberWorkLoop.js

// Mutation阶段：执行DOM操作
function flushMutationEffects(): void {
  // ...
  
  const root = pendingEffectsRoot;
  const finishedWork = pendingFinishedWork;
  const lanes = pendingEffectsLanes;
  
  // 执行所有DOM变更
  commitMutationEffects(root, finishedWork, lanes);
  
  // ...
  
  // 关键：切换current树
  // 这发生在mutation之后、layout之前
  root.current = finishedWork;
  
  // 继续layout阶段
  pendingEffectsStatus = PENDING_LAYOUT_PHASE;
}
```

**为什么在mutation和layout之间切换？**

```javascript
// 时间轴
ComponentWillUnmount   Mutation阶段    切换current    Layout阶段     useEffect
      ↓                    ↓              ↓              ↓              ↓
  访问旧树               执行DOM         切换指针      访问新树       访问新树
current树有效          workInProgress   新current    新current      新current
```

这样设计的原因：
1. **componentWillUnmount**需要访问旧的组件实例（current树）
2. **DOM更新**在workInProgress树上标记，但操作的是真实DOM
3. **componentDidMount/Update**需要访问新的组件实例（新current树）

---

## 四、双缓存的内存管理策略

### 1. Fiber节点的复用

```javascript
// 首次渲染后的状态
current rootFiber
├─ alternate ─────► workInProgress rootFiber
└─ child ─► App Fiber (current)
            ├─ alternate ─────► App Fiber (workInProgress)
            └─ child ─► ...

// 下次更新时
// workInProgress树被复用，不需要重新创建对象！
workInProgress = current.alternate;  // 直接复用
```

**内存优势**：
- 只需要两棵树的内存（current + workInProgress）
- 每次更新复用alternate，避免大量对象创建
- 通过指针切换，O(1)时间复杂度

### 2. 节点的选择性创建

```javascript
// bailout优化：跳过没有变化的子树
function beginWork(current, workInProgress, renderLanes) {
  // ...
  
  // 检查是否可以复用
  if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;
    
    if (oldProps === newProps && !hasContextChanged()) {
      // props没变，可以bailout
      // 直接复用current的child，不创建新的workInProgress节点
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
  }
  
  // props变了，继续协调
  // ...
}

function bailoutOnAlreadyFinishedWork(
  current: Fiber,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  // 克隆children指针，不创建新节点
  cloneChildFibers(current, workInProgress);
  return workInProgress.child;
}
```

---

## 五、双缓存与React新特性

### 1. 并发模式（Concurrent Mode）

双缓存机制是并发模式的基础：

```javascript
function renderRootConcurrent(root, lanes) {
  // ...
  
  workLoop: while (workInProgress !== null) {
    // 可中断的工作循环
    if (shouldYield()) {
      // 时间片用完，暂停渲染
      // current树保持完整，用户看不到半完成状态
      break workLoop;
    }
    
    performUnitOfWork(workInProgress);
  }
  
  // 如果被中断，workInProgress树保留在内存中
  // 下次继续从当前进度开始
}
```

**优势**：
- **可中断**：current树始终完整，随时可以放弃workInProgress
- **优先级插队**：高优先级更新可以打断低优先级，重新构建workInProgress树
- **保持一致性**：用户始终看到完整的UI，不会出现撕裂

### 2. Suspense与双缓存

```javascript
function App() {
  return (
    <Suspense fallback={<Loading />}>
      <AsyncComponent />  {/* 抛出Promise */}
    </Suspense>
  );
}
```

**Suspense的双缓存工作流程**：

```
1. 渲染AsyncComponent时抛出Promise
   workInProgress树：
   Suspense Fiber
   └─ child ─► AsyncComponent Fiber (suspended)
   
   current树保持不变（显示旧内容或初始状态）

2. 渲染fallback
   workInProgress树：
   Suspense Fiber
   ├─ child ─► Loading Fiber (primary, hidden)
   └─ child ─► AsyncComponent Fiber (fallback, visible)
   
   提交后切换current树，显示Loading

3. Promise resolve后
   重新渲染AsyncComponent
   workInProgress树：
   Suspense Fiber
   └─ child ─► AsyncComponent Fiber (resolved)
   
   提交后切换current树，显示真实内容
```

### 3. Transitions与双缓存

```javascript
import { startTransition } from 'react';

function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    // 高优先级：立即更新
    setQuery(e.target.value);
    
    // 低优先级：可被打断
    startTransition(() => {
      setResults(search(e.target.value));
    });
  };

  return (
    <>
      <input value={query} onChange={handleChange} />
      <Results data={results} />
    </>
  );
}
```

**Transitions的双缓存流程**：

```
初始状态：
current树：query="", results=[]

用户输入"React":

1. 高优先级更新 setQuery("R")
   创建workInProgress树1
   workInProgress树1：query="R", results=[]
   提交 → current树：query="R", results=[]

2. 低优先级更新 setResults(search("R")) 开始
   创建workInProgress树2
   workInProgress树2：query="R", results=[...1000项] (渲染中...)

3. 用户继续输入 "e"，产生高优先级更新
   放弃workInProgress树2！
   创建新的workInProgress树3
   workInProgress树3：query="Re", results=[] (旧结果)
   提交 → current树：query="Re", results=[]

4. 低优先级更新 setResults(search("Re"))
   创建workInProgress树4
   workInProgress树4：query="Re", results=[...新结果]
   提交 → current树显示新结果
```

**双缓存的作用**：
- 可以随时放弃低优先级的workInProgress树
- 高优先级更新可以打断并重新开始
- current树始终保持一致性

---

## 六、实际应用场景与优化

### 场景1：条件渲染优化

```javascript
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(data => {
      setUser(data);
      setLoading(false);
    });
  }, [userId]);

  if (loading) {
    return <Loading />;
  }

  return (
    <div>
      <Avatar src={user.avatar} />
      <UserInfo user={user} />
    </div>
  );
}
```

**双缓存的好处**：

```
userId从1变为2时：

current树：                     workInProgress树：
UserProfile (userId=1)          UserProfile (userId=2)
└─ div                          └─ Loading
   ├─ Avatar(user1)
   └─ UserInfo(user1)

渲染过程中，用户仍然看到userId=1的完整内容
直到新内容准备好，一次性切换
```

### 场景2：列表diff优化

```javascript
function TodoList({ todos }) {
  return (
    <ul>
      {todos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  );
}
```

**双缓存与key的配合**：

```
current树（3个todo）:
ul
├─ TodoItem(key=1, alternate → null)
├─ TodoItem(key=2, alternate → null)
└─ TodoItem(key=3, alternate → null)

更新：删除todo2，添加todo4

workInProgress树构建过程：
1. diff发现key=1的TodoItem → 复用alternate → wip1
2. diff发现key=2的TodoItem → 标记删除
3. diff发现key=3的TodoItem → 复用alternate → wip3
4. diff发现key=4的TodoItem → 创建新的 → wip4

workInProgress树：
ul
├─ TodoItem(key=1, alternate → current1)
├─ TodoItem(key=3, alternate → current3)
└─ TodoItem(key=4, alternate → null)

删除列表：
└─ TodoItem(key=2) → 标记Deletion flag

commit阶段：
1. 删除key=2的DOM节点
2. 插入key=4的DOM节点
3. 切换current指针

结果：最小化DOM操作
```

### 场景3：错误边界与双缓存

```javascript
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }
    return this.props.children;
  }
}

function App() {
  return (
    <ErrorBoundary>
      <BuggyComponent />
    </ErrorBoundary>
  );
}
```

**双缓存的保护机制**：

```
渲染过程中BuggyComponent抛出错误：

current树（正常显示）：
ErrorBoundary (hasError: false)
└─ BuggyComponent (正常内容)

workInProgress树（构建中出错）：
ErrorBoundary (hasError: false)
└─ BuggyComponent (抛出错误！)

错误处理：
1. 捕获错误，调用getDerivedStateFromError
2. 放弃当前workInProgress树
3. 重新构建workInProgress树（hasError: true）
4. 提交新树

新current树：
ErrorBoundary (hasError: true)
└─ ErrorFallback

关键：用户不会看到半完成或错误的状态
      current树在错误发生时保持完整
```

---

## 七、性能分析与最佳实践

### 1. 内存占用分析

```javascript
// 假设一个复杂应用
const app = {
  totalComponents: 1000,
  avgFiberSize: 100bytes,  // 每个Fiber节点约100字节
};

// 没有双缓存
const memoryWithoutDoubleBuffer = 
  1000 * 100 + // Fiber树
  1000 * 32;   // 对象指针
// ≈ 132KB

// 有双缓存
const memoryWithDoubleBuffer = 
  2 * 1000 * 100 + // current + workInProgress
  2 * 1000 * 32;   // 对象指针
// ≈ 264KB

// 结论：内存翻倍，但获得了可中断渲染和避免闪烁
// 对于现代设备，这个trade-off非常值得
```

### 2. 最佳实践

#### ✅ 利用bailout优化

```javascript
// Bad: 每次都创建新对象
function App() {
  return <Child config={{ theme: 'dark' }} />;
  // 每次render，config都是新对象，无法bailout
}

// Good: 稳定引用
const config = { theme: 'dark' };
function App() {
  return <Child config={config} />;
  // config引用不变，Child可以bailout
}

// Better: useMemo
function App() {
  const config = useMemo(() => ({ theme: 'dark' }), []);
  return <Child config={config} />;
}
```

#### ✅ 合理使用key

```javascript
// Bad: 使用index作为key
{todos.map((todo, index) => (
  <TodoItem key={index} todo={todo} />
))}
// 删除第一项时，所有后续项的key都变了，无法复用alternate

// Good: 使用稳定的唯一标识
{todos.map(todo => (
  <TodoItem key={todo.id} todo={todo} />
))}
// 删除任意项，其他项的key不变，可以复用alternate
```

#### ✅ 避免在render中创建新组件

```javascript
// Bad: 每次render都创建新的组件类型
function Parent() {
  const Child = () => <div>Child</div>;  // 新的函数引用
  return <Child />;
  // type变化，无法复用alternate，必须卸载后重新挂载
}

// Good: 组件定义在外部
const Child = () => <div>Child</div>;
function Parent() {
  return <Child />;
  // type不变，可以复用alternate，只需要更新
}
```

---

## 八、调试技巧

### 1. 查看current和workInProgress树

```javascript
// 在DevTools Console中
const root = document.getElementById('root');
const fiberRoot = root._reactRootContainer._internalRoot;

// current树
console.log('Current tree:', fiberRoot.current);

// workInProgress树（渲染过程中）
console.log('WorkInProgress tree:', fiberRoot.current.alternate);

// 遍历Fiber树
function traverseFiber(fiber, depth = 0) {
  console.log('  '.repeat(depth), fiber.type, fiber.tag);
  let child = fiber.child;
  while (child) {
    traverseFiber(child, depth + 1);
    child = child.sibling;
  }
}

traverseFiber(fiberRoot.current);
```

### 2. React DevTools观察

React DevTools的Profiler可以看到：
- **Flamegraph**：每个组件的渲染时间
- **Ranked**：最慢的组件排序
- **Component**：组件为什么重新渲染

通过这些工具，可以判断：
- 哪些组件没有正确bailout
- 哪些组件应该被memo优化
- 双缓存是否被有效利用

---

## 九、源码关键路径

```
双缓存相关的核心文件：

packages/react-reconciler/src/
├── ReactFiberRoot.js            # FiberRoot创建
│   └── createFiberRoot()        # 初始化current树
│
├── ReactFiber.js                # Fiber节点创建
│   ├── createWorkInProgress()   # 创建/复用workInProgress节点
│   └── FiberNode构造函数        # Fiber节点结构
│
├── ReactFiberWorkLoop.js        # 工作循环
│   ├── prepareFreshStack()      # 准备workInProgress树
│   ├── renderRootConcurrent()   # 并发渲染（可中断）
│   ├── renderRootSync()         # 同步渲染
│   ├── commitRoot()             # 提交更新
│   └── flushMutationEffects()   # 切换current树的关键位置
│
├── ReactFiberBeginWork.js       # beginWork阶段
│   └── beginWork()              # 创建workInProgress节点
│
├── ReactFiberCompleteWork.js   # completeWork阶段
│   └── completeWork()           # 完成workInProgress节点
│
└── ReactFiberCommitWork.js      # commit阶段
    ├── commitMutationEffects()  # DOM变更
    └── commitLayoutEffects()    # Layout effects
```

---

## 十、面试要点速记

### 快速回答框架

**双缓存是什么？**
- 两棵Fiber树：current（屏幕显示）+ workInProgress（内存构建）
- 通过alternate属性相互引用
- 类似显卡的双缓冲技术

**为什么需要双缓存？**
1. **避免闪烁**：内存构建完整树，一次性切换
2. **支持中断**：current树始终完整，可随时放弃workInProgress
3. **性能优化**：复用Fiber节点，减少内存分配

**工作流程？**
1. **prepareFreshStack**：基于current创建workInProgress
2. **render阶段**：在workInProgress树上进行协调
3. **commit阶段**：执行DOM操作后切换指针（root.current = finishedWork）

**关键代码位置？**
- 创建：`ReactFiber.js:createWorkInProgress()`
- 切换：`ReactFiberWorkLoop.js:3877`（root.current = finishedWork）

### 加分项

1. **能说明与并发模式的关系**：双缓存是可中断渲染的基础
2. **能解释切换时机**：mutation阶段之后、layout阶段之前
3. **能分析性能影响**：内存翻倍 vs 用户体验提升的trade-off
4. **能结合实际场景**：Suspense、Transitions、错误边界

### 常见追问

**Q: 为什么不用虚拟DOM diff后直接更新current树？**
A: 
- 无法中断：直接修改current树，一旦中断就是不完整状态
- 无法回滚：如果中途出错，无法恢复到之前的状态
- 无法实现并发：需要保持两个版本才能实现优先级插队

**Q: workInProgress树什么时候被复用？**
A:
- 第一次更新后，current和workInProgress都有了alternate引用
- 下次更新时，直接复用current.alternate作为新的workInProgress
- 通过指针交换，避免重新创建对象

**Q: 双缓存会导致内存翻倍吗？**
A:
- 理论上是两棵树，但有很多优化：
  1. bailout优化：跳过没变化的子树，不创建workInProgress节点
  2. 共享stateNode：两棵树共享同一个DOM节点
  3. 延迟创建：只在需要时才创建workInProgress节点
- 实际内存增长远小于2倍

---

**参考资料**：
- React源码：`packages/react-reconciler/src/ReactFiberWorkLoop.js`
- [Lin Clark - A Cartoon Intro to Fiber](https://www.youtube.com/watch?v=ZCuYPiUIONs)
- [React Fiber Architecture](https://github.com/acdlite/react-fiber-architecture)

**最后更新**: 2025-11-05

