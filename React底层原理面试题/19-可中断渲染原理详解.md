# 19 - 可中断渲染原理详解

> **问题**: 什么是可中断渲染？React如何保存和恢复渲染进度？

---

## 一、可中断渲染是什么？

**可中断渲染（Interruptible Rendering）是React Fiber架构的核心能力**，允许render阶段被中断，稍后再恢复继续执行。

### 为什么需要可中断渲染？

```
传统同步渲染的问题：
┌────────────────────────────────────┐
│ render（1000个组件）               │
│ [========================]         │
│ 100ms，主线程被完全阻塞            │
└────────────────────────────────────┘
  ↓
❌ 用户点击、输入无响应
❌ 动画卡顿
❌ 页面frozen

可中断渲染的解决方案：
┌────────────────────────────────────┐
│ [==] 让出 [==] 让出 [==] 让出       │
│  5ms   ↓    5ms   ↓    5ms   ↓     │
│     浏览器   用户   浏览器           │
│     渲染    交互    渲染             │
└────────────────────────────────────┘
  ↓
✅ 应用保持响应
✅ 动画流畅
✅ 可以处理紧急更新
```

---

## 二、可中断渲染的核心实现

### 全局状态：workInProgress

源码：`packages/react-reconciler/src/ReactFiberWorkLoop.js`

```javascript
// ========== 渲染进度的全局状态 ==========

// 当前正在工作的root
let workInProgressRoot: FiberRoot | null = null;

// 当前正在工作的Fiber节点
let workInProgress: Fiber | null = null;

// 当前渲染的lanes
let workInProgressRootRenderLanes: Lanes = NoLanes;

// 渲染退出状态
type RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5 | 6;
const RootInProgress = 0;          // 渲染进行中
const RootFatalErrored = 1;        // 致命错误
const RootErrored = 2;             // 错误
const RootSuspended = 3;           // 挂起
const RootSuspendedWithDelay = 4;  // 延迟挂起
const RootCompleted = 5;           // 完成
const RootSuspendedAtTheShell = 6; // 在外壳挂起

let workInProgressRootExitStatus: RootExitStatus = RootInProgress;

// 挂起原因
export opaque type SuspendedReason = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
const NotSuspended: SuspendedReason = 0;
const SuspendedOnError: SuspendedReason = 1;
const SuspendedOnData: SuspendedReason = 2;
const SuspendedOnImmediate: SuspendedReason = 3;
const SuspendedOnInstance: SuspendedReason = 4;
// ... 更多原因

let workInProgressSuspendedReason: SuspendedReason = NotSuspended;
let workInProgressThrownValue: mixed = null;

// 其他状态
let workInProgressRootDidSkipSuspendedSiblings: boolean = false;
let workInProgressRootIsPrerendering: boolean = false;
let workInProgressRootDidAttachPingListener: boolean = false;
let workInProgressRootSkippedLanes: Lanes = NoLanes;
let workInProgressRootInterleavedUpdatedLanes: Lanes = NoLanes;
let workInProgressRootPingedLanes: Lanes = NoLanes;
let workInProgressDeferredLane: Lane = NoLane;
```

**这些全局变量的作用**：

```
workInProgressRoot + workInProgress + workInProgressRootRenderLanes
= 完整的渲染上下文

中断时：
- 这些变量保持不变
- 记录了当前渲染到哪个Fiber
- 记录了正在处理哪些lanes

恢复时：
- 检查这些变量
- 判断是否可以继续
- 或者需要重新开始
```

---

## 三、可中断的工作循环

### workLoopConcurrent

```javascript
// 并发工作循环（可中断）
function workLoopConcurrent(nonIdle: boolean) {
  // nonIdle: true表示Transition/Retry，false表示Idle
  
  if (workInProgress !== null) {
    // ========== 计算yield时间点 ==========
    // Transition/Retry: 25ms（降低到30fps）
    // Idle: 5ms（保持60fps）
    const yieldAfter = now() + (nonIdle ? 25 : 5);
    
    do {
      // ========== 处理一个Fiber节点 ==========
      performUnitOfWork(workInProgress);
      
      // ========== 检查是否需要yield ==========
    } while (workInProgress !== null && now() < yieldAfter);
  }
}

// 使用Scheduler的shouldYield
function workLoopConcurrentByScheduler() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

// 对比：同步工作循环（不可中断）
function workLoopSync() {
  // 没有shouldYield检查，一直执行到完成
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```

**可中断的关键**：

```
1. while循环 + 中断条件
   while (workInProgress !== null && !shouldYield())

2. shouldYield()返回true时：
   - 退出循环
   - workInProgress保留当前值
   - 返回RootInProgress状态

3. 下次render时：
   - 检查workInProgress
   - 继续从当前节点执行
```

---

## 四、中断的触发

### 场景1：时间片用完

```javascript
// workLoopConcurrent中
if (now() >= yieldAfter) {
  // 时间片用完，退出循环
  break;
}

// renderRootConcurrent返回
if (workInProgress !== null) {
  // Still work remaining.
  return RootInProgress;  // 标记未完成
} else {
  // Completed the tree.
  return workInProgressRootExitStatus;
}
```

**完整流程**：

```
t=0: renderRootConcurrent开始
  → workInProgress = rootFiber
  → yieldAfter = now() + 5 = 5

t=1-4: performUnitOfWork循环
  → 处理rootFiber → App Fiber → div Fiber ...

t=5: now() >= yieldAfter
  → 退出workLoopConcurrent
  → workInProgress = 当前正在处理的Fiber
  → return RootInProgress

t=5.1: performWorkOnRoot收到RootInProgress
  → 不调用commit
  → 保留workInProgress等全局变量
  → 等待下次调度

t=10: 继续render（没有新的高优先级更新）
  → renderRootConcurrent(root, lanes)
  → 检查：workInProgressRoot === root ✓
  → 检查：workInProgressRootRenderLanes === lanes ✓
  → 不调用prepareFreshStack（继续之前的工作）
  → workLoopConcurrent()
  → 从workInProgress继续执行
```

### 场景2：高优先级打断

```javascript
// performWorkOnRoot中
const nextLanes = getNextLanes(root, wipLanes);

if (wipLanes !== nextLanes) {
  // lanes变了，说明有新的更高优先级更新
  // 中断当前render，开始新的render
  prepareFreshStack(root, nextLanes);
}
```

**完整流程**：

```
t=0: TransitionLane render开始
  → workInProgressRoot = root
  → workInProgressRootRenderLanes = TransitionLane
  → workInProgress = 某个Fiber

t=10: SyncLane更新进来
  → scheduleUpdateOnFiber(root, fiber, SyncLane)
  → ensureRootIsScheduled(root)
  → getNextLanes(root, TransitionLane) → SyncLane

t=11: performWorkOnRoot(root, SyncLane, forceSync)
  → 检查：workInProgressRoot === root ✓
  → 检查：workInProgressRootRenderLanes !== SyncLane ✓
  → lanes不同，需要中断！

t=12: prepareFreshStack(root, SyncLane)
  → resetWorkInProgressStack()
    清理TransitionLane的workInProgress
  → workInProgress = createWorkInProgress(root.current, null)
  → workInProgressRootRenderLanes = SyncLane
  → 开始新的render（SyncLane）

t=13-20: 处理SyncLane更新
  → renderRootSync完成
  → commit

t=30: TransitionLane重新调度
  → 从头开始render（因为被清理了）
```

---

## 五、prepareFreshStack：准备新的工作栈

```javascript
function prepareFreshStack(root: FiberRoot, lanes: Lanes): Fiber {
  // ========== 1. 清理timeout ==========
  const timeoutHandle = root.timeoutHandle;
  if (timeoutHandle !== noTimeout) {
    root.timeoutHandle = noTimeout;
    cancelTimeout(timeoutHandle);
  }
  
  const cancelPendingCommit = root.cancelPendingCommit;
  if (cancelPendingCommit !== null) {
    root.cancelPendingCommit = null;
    cancelPendingCommit();
  }

  // ========== 2. 清理旧的workInProgress ==========
  resetWorkInProgressStack();

  // ========== 3. 设置新的全局状态 ==========
  workInProgressRoot = root;
  const rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = NotSuspended;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = false;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
  workInProgressRootDidAttachPingListener = false;
  
  // ========== 4. 清理各种状态 ==========
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootInterleavedUpdatedLanes = NoLanes;
  workInProgressRootRenderPhaseUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;
  workInProgressDeferredLane = NoLane;
  workInProgressSuspendedRetryLanes = NoLanes;
  workInProgressRootConcurrentErrors = null;
  workInProgressRootRecoverableErrors = null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = false;

  // ========== 5. Profiling相关 ==========
  // ... profiling初始化

  return rootWorkInProgress;
}
```

### resetWorkInProgressStack：清理工作栈

```javascript
function resetWorkInProgressStack() {
  if (workInProgress === null) return;
  
  let interruptedWork;
  if (workInProgressSuspendedReason === NotSuspended) {
    // ========== 正常中断：从return向上清理 ==========
    interruptedWork = workInProgress.return;
  } else {
    // ========== 挂起状态：从当前节点开始清理 ==========
    resetSuspendedWorkLoopOnUnwind(workInProgress);
    interruptedWork = workInProgress;
  }
  
  // ========== 向上遍历，清理每个节点 ==========
  while (interruptedWork !== null) {
    const current = interruptedWork.alternate;
    unwindInterruptedWork(
      current,
      interruptedWork,
      workInProgressRootRenderLanes,
    );
    interruptedWork = interruptedWork.return;
  }
  
  // ========== 清空workInProgress ==========
  workInProgress = null;
}
```

### unwindInterruptedWork：清理单个Fiber

源码：`packages/react-reconciler/src/ReactFiberUnwindWork.js`

```javascript
function unwindInterruptedWork(
  current: Fiber | null,
  interruptedWork: Fiber,
  renderLanes: Lanes,
) {
  // 根据tag清理不同类型的Fiber
  popTreeContext(interruptedWork);
  
  switch (interruptedWork.tag) {
    case ClassComponent: {
      const childContextTypes = interruptedWork.type.childContextTypes;
      if (childContextTypes !== null) {
        popLegacyContext(interruptedWork);
      }
      break;
    }
    
    case HostRoot: {
      const root: FiberRoot = interruptedWork.stateNode;
      const cache: Cache = interruptedWork.memoizedState.cache;
      popCacheProvider(interruptedWork, cache);
      popRootTransition(interruptedWork, root, renderLanes);
      popHostContainer(interruptedWork);
      popTopLevelLegacyContextObject(interruptedWork);
      break;
    }
    
    case HostComponent: {
      popHostContext(interruptedWork);
      break;
    }
    
    case SuspenseComponent:
      popSuspenseHandler(interruptedWork);
      break;
    
    case ContextProvider:
      const context: ReactContext<any> = interruptedWork.type;
      popProvider(context, interruptedWork);
      break;
    
    // ... 其他类型
  }
}
```

**清理的作用**：

```
为什么要清理？
render阶段会push各种context到stack：
- HostContext
- SuspenseContext
- CacheContext
- LegacyContext
- 等等

中断时必须清理这些stack，否则：
1. 下次render时stack状态错乱
2. 内存泄漏
3. context读取错误

示例：
render开始：
  pushHostContext(div)
    pushHostContext(span)
      pushHostContext(p)  ← 在这里中断
      
清理：
  popHostContext(p)
  popHostContext(span)
  popHostContext(div)
  
下次render从头开始，stack是干净的
```

---

## 六、恢复渲染

### renderRootConcurrent：检查是否可以继续

```javascript
function renderRootConcurrent(
  root: FiberRoot,
  lanes: Lanes,
): RootExitStatus {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;

  // ========== 关键检查：是否可以继续之前的工作 ==========
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    // 不同的root或lanes，不能继续
    // 清理旧的工作，重新开始
    prepareFreshStack(root, lanes);
  } else {
    // 相同的root和lanes，可以继续！
    // 保留workInProgress
    // 继续之前的进度
    
    // 检查是否是预渲染
    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
  }

  // ========== 开始/继续工作循环 ==========
  outer: do {
    try {
      if (
        workInProgressSuspendedReason !== NotSuspended &&
        workInProgress !== null
      ) {
        // 之前挂起了，需要特殊处理
        const unitOfWork = workInProgress;
        const thrownValue = workInProgressThrownValue;
        
        // 根据挂起原因决定如何恢复
        resumeOrUnwind: switch (workInProgressSuspendedReason) {
          case SuspendedOnError:
            // 错误：unwind然后继续
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);
            break;
          case SuspendedOnData:
            // 数据：replay组件
            // ...
            break;
          // ... 其他挂起原因
        }
      } else {
        // ========== 正常工作循环 ==========
        if (enableThrottledScheduling) {
          workLoopConcurrent(includesNonIdleWork(lanes));
        } else {
          workLoopConcurrentByScheduler();
        }
      }
      break;
    } catch (thrownValue) {
      handleThrow(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();
  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;

  // ========== 检查是否完成 ==========
  if (workInProgress !== null) {
    // ========== 还有工作，返回InProgress ==========
    return RootInProgress;
  } else {
    // ========== 完成了，清理并返回状态 ==========
    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes;
    finishQueueingConcurrentUpdates();
    
    return workInProgressRootExitStatus;  // RootCompleted
  }
}
```

---

## 七、完整案例：时间片中断和恢复

### 场景代码

```javascript
function App() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>
      
      {/* 1000个耗时组件 */}
      {Array(1000).fill(0).map((_, i) => (
        <ExpensiveComponent key={i} index={i} />
      ))}
    </div>
  );
}

function ExpensiveComponent({ index }) {
  // 每个组件耗时0.1ms
  heavyComputation();
  return <div>Item {index}</div>;
}
```

### 执行流程（时间片中断）

```
========== 用户点击按钮 ==========

t=0: onClick触发
  → setCount(1)
  → lane = SyncLane
  → scheduleUpdateOnFiber

t=1: 微任务执行
  → performSyncWorkOnRoot(root, SyncLane)

========== render阶段开始 ==========

t=2: renderRootSync(root, SyncLane)
  → prepareFreshStack(root, SyncLane)
    workInProgress = wip rootFiber
  → workLoopSync()

t=3: performUnitOfWork(rootFiber)
  → beginWork → updateHostRoot
  → reconcileChildren
  → workInProgress = App Fiber

t=4: performUnitOfWork(App Fiber)
  → beginWork → updateFunctionComponent
  → renderWithHooks(App)
    useState处理，count变成1
  → reconcileChildren
  → workInProgress = div Fiber

t=5: performUnitOfWork(div Fiber)
  → beginWork → updateHostComponent
  → reconcileChildren（1000个子节点）
  → workInProgress = button Fiber

t=6: 处理button
  → workInProgress = ExpensiveComponent(0)

t=7-11: 处理ExpensiveComponent(0-49)
  → 每个0.1ms，共5ms

t=11: 时间片检查
  → now() = 11 >= yieldAfter(6) ✓
  → 但这是同步render（workLoopSync）
  → 继续执行，不中断

========== 如果是并发render ==========

假设是TransitionLane：

t=0: startTransition(() => setCount(1))
  → lane = TransitionLane
  
t=1: renderRootConcurrent(root, TransitionLane)
  → workLoopConcurrent(true)  // nonIdle = true
  → yieldAfter = 0 + 25 = 25

t=2-26: performUnitOfWork循环
  → 处理约250个ExpensiveComponent

t=26: now() >= yieldAfter
  → 退出workLoopConcurrent
  → workInProgress = ExpensiveComponent(251)
  → return RootInProgress

全局状态保存：
  workInProgressRoot = root
  workInProgress = ExpensiveComponent(251) Fiber
  workInProgressRootRenderLanes = TransitionLane
  workInProgressRootExitStatus = RootInProgress

t=27: performWorkOnRoot收到RootInProgress
  → 不commit
  → ensureRootIsScheduled(root)
  → 调度下次render

t=50: 没有新的高优先级更新
  → performWorkOnRoot(root, TransitionLane)
  → renderRootConcurrent(root, TransitionLane)
  
t=51: 检查是否可以继续
  → workInProgressRoot === root ✓
  → workInProgressRootRenderLanes === TransitionLane ✓
  → 不调用prepareFreshStack
  → 直接进入workLoopConcurrent

t=52: workLoopConcurrent
  → workInProgress = ExpensiveComponent(251)
  → 从第251个组件继续！

t=52-76: 处理剩余的750个组件（又中断3次）

t=100: 所有组件处理完
  → workInProgress = null
  → return RootCompleted
  → commit
```

---

## 八、Fiber链表结构支持可中断

### 为什么链表可以暂停和恢复？

```javascript
// Fiber的链表结构
type Fiber = {
  return: Fiber | null,   // 父节点
  child: Fiber | null,    // 第一个子节点
  sibling: Fiber | null,  // 兄弟节点
  // ...
};

// 遍历过程
function performUnitOfWork(unitOfWork: Fiber) {
  // 1. 处理当前节点
  const next = beginWork(current, unitOfWork, renderLanes);
  
  if (next === null) {
    // 2. 没有子节点，complete
    completeUnitOfWork(unitOfWork);
  } else {
    // 3. 有子节点，继续
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork: Fiber) {
  let completedWork = unitOfWork;
  
  do {
    // 1. complete当前节点
    completeWork(current, completedWork, renderLanes);
    
    // 2. 找兄弟节点
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    
    // 3. 没有兄弟，返回父节点
    completedWork = completedWork.return;
    workInProgress = completedWork;
  } while (completedWork !== null);
}
```

**暂停和恢复的过程**：

```
Fiber树：
     A
    / \
   B   C
  /|\  |
 D E F G

遍历顺序：A → B → D → E → F → (中断) → B → C → G

t=0: workInProgress = A
  → beginWork(A) → 返回B

t=1: workInProgress = B
  → beginWork(B) → 返回D

t=2: workInProgress = D
  → beginWork(D) → 返回null
  → completeWork(D)
  → 找到兄弟E

t=3: workInProgress = E
  → 处理E，找到兄弟F

t=4: workInProgress = F
  → shouldYield() = true
  → 退出循环

【中断】workInProgress = F（保存进度）

t=10: 恢复render
  → workInProgress = F（从F继续）
  → beginWork(F) → 返回null
  → completeWork(F)
  → 没有兄弟，返回父B

t=11: workInProgress = B
  → completeWork(B)
  → 找到兄弟C

t=12: workInProgress = C
  → 继续...

关键：
- workInProgress = F时中断
- 恢复时从F继续
- 链表结构天然支持从任意节点继续
```

---

## 九、源码关键路径

```
可中断渲染核心文件：

packages/react-reconciler/src/
├── ReactFiberWorkLoop.js               # 核心实现
│   ├── 全局变量定义                    # workInProgress等
│   ├── RootExitStatus定义              # 渲染状态
│   ├── workLoopConcurrent()            # 可中断工作循环
│   ├── workLoopSync()                  # 不可中断工作循环
│   ├── renderRootConcurrent()          # 并发render入口
│   ├── prepareFreshStack()             # 准备/重置工作栈
│   ├── resetWorkInProgressStack()      # 清理工作栈
│   └── performUnitOfWork()             # 处理单个工作单元
│
├── ReactFiberUnwindWork.js             # 清理工作
│   └── unwindInterruptedWork()         # 清理中断的Fiber
│
└── ReactFiber.js                       # Fiber创建
    ├── createWorkInProgress()          # 创建workInProgress
    └── resetWorkInProgress()           # 重置workInProgress
```

---

## 十、面试要点速记

### 快速回答框架

**可中断渲染是什么？**
- render阶段可以被中断
- 保存workInProgress进度
- 稍后可以恢复继续执行

**如何实现可中断？**
1. **时间片检查**：workLoopConcurrent中检查shouldYield
2. **保存进度**：workInProgress等全局变量保存状态
3. **退出循环**：shouldYield()返回true时break
4. **返回状态**：return RootInProgress

**如何恢复？**
1. **检查状态**：workInProgressRoot和lanes是否相同
2. **继续工作**：相同则不调用prepareFreshStack
3. **从当前节点继续**：workInProgress保留
4. **链表遍历**：Fiber链表结构天然支持

**为什么Fiber链表支持暂停？**
- 链表可以从任意节点开始遍历
- return、child、sibling指针记录了位置
- 不依赖调用栈（递归）
- 纯数据结构，易于保存和恢复

### 加分项

1. **能说明全局状态的作用**：
   - workInProgress保存当前节点
   - workInProgressRoot保存root
   - workInProgressRootRenderLanes保存lanes

2. **能解释prepareFreshStack**：
   - 什么时候调用（root或lanes变化）
   - 做什么（清理+创建新的workInProgress）

3. **能说明清理的必要性**：
   - context stack需要清理
   - 避免状态错乱
   - unwindInterruptedWork的作用

4. **能对比同步和并发**：
   - workLoopSync vs workLoopConcurrent
   - 是否检查shouldYield

### 常见追问

**Q: workInProgress保存在哪里？**
A:
- 模块级全局变量
- 在ReactFiberWorkLoop.js中
- render阶段一直保持
- commit后清空

**Q: 中断会丢失数据吗？**
A:
- 不会，workInProgress树保留在内存中
- current树不受影响
- 可以随时放弃workInProgress重新开始
- 或者继续完成workInProgress

**Q: 什么情况会重新开始而不是继续？**
A:
- root变化（不同的应用）
- lanes变化（不同的优先级）
- 高优先级打断低优先级
- 这时会调用prepareFreshStack清理并重新开始

**Q: Fiber链表和调用栈递归的区别？**
A:
- **递归**：依赖JavaScript调用栈，不可中断
- **链表**：数据结构，可以随时暂停
- **递归**：中断会丢失栈信息
- **链表**：workInProgress保存位置，可恢复

**Q: 中断的开销大吗？**
A:
- 开销很小：
  - 检查now() < yieldAfter（一次减法和比较）
  - 退出循环
  - 保留全局变量（无需复制）
- 收益很大：
  - 保持应用响应
  - 避免长时间阻塞

---

**参考资料**：
- React源码：`packages/react-reconciler/src/ReactFiberWorkLoop.js`
- React源码：`packages/react-reconciler/src/ReactFiberUnwindWork.js`
- [Fiber架构](https://github.com/acdlite/react-fiber-architecture)

**最后更新**: 2025-11-05
