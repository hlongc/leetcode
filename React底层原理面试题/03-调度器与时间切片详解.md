# 03 - 调度器（Scheduler）与时间切片详解

> **问题**: React的调度器（Scheduler）的作用是什么？它是如何实现时间切片（Time Slicing）的？

---

## 一、Scheduler是什么？

**Scheduler（调度器）是React的一个独立包**，负责在浏览器环境中调度任务的执行，是实现时间切片和并发渲染的核心。

### 为什么需要Scheduler？

```
浏览器的单线程模型：
┌────────────────────────────────────────────┐
│         JavaScript主线程（唯一）           │
├────────────────────────────────────────────┤
│ JS执行 → 样式计算 → 布局 → 绘制 → 合成    │
│   ↑                                        │
│   └──── 一帧(16.6ms @60fps)               │
└────────────────────────────────────────────┘

问题：长时间JS执行会阻塞渲染
┌──JS执行(100ms)──┐
                    ↓
    ❌ 6帧被阻塞，用户看到卡顿

Scheduler的解决方案：时间切片
┌─JS(5ms)─┐渲染┐├─JS(5ms)─┐渲染┐├─JS(5ms)─┐
          ↓          ↓          ↓
    ✅ 每5ms让出控制权，保持流畅
```

**核心价值**：
1. **时间切片**：将长任务拆分，定期让出主线程
2. **优先级调度**：高优先级任务优先执行
3. **任务管理**：维护任务队列，支持取消和延迟

---

## 二、Scheduler的核心实现

### 1. 包结构与入口

源码：`packages/scheduler/src/forks/Scheduler.js`

```javascript
// Scheduler的核心数据结构
export opaque type Task = {
  id: number,                    // 任务唯一ID
  callback: Callback | null,     // 任务回调函数
  priorityLevel: PriorityLevel,  // 优先级
  startTime: number,             // 开始时间
  expirationTime: number,        // 过期时间（startTime + timeout）
  sortIndex: number,             // 排序依据（用于堆排序）
  isQueued?: boolean,            // 是否在队列中（Profiling用）
};

// 两个任务队列
var taskQueue: Array<Task> = [];    // 就绪队列（最小堆，按expirationTime排序）
var timerQueue: Array<Task> = [];   // 延迟队列（最小堆，按startTime排序）

// 当前正在执行的任务
var currentTask = null;
var currentPriorityLevel: PriorityLevel = NormalPriority;

// 全局标记
var isPerformingWork = false;        // 是否正在执行任务
var isHostCallbackScheduled = false; // 是否已调度主回调
var isHostTimeoutScheduled = false;  // 是否已调度延迟回调
```

### 2. 五种优先级

源码：`packages/scheduler/src/SchedulerPriorities.js`

```javascript
export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5;

export const NoPriority = 0;           // 无优先级
export const ImmediatePriority = 1;    // 立即执行（过期时间：-1ms）
export const UserBlockingPriority = 2; // 用户阻塞（过期时间：250ms）
export const NormalPriority = 3;       // 正常优先级（过期时间：5000ms）
export const LowPriority = 4;          // 低优先级（过期时间：10000ms）
export const IdlePriority = 5;         // 空闲优先级（过期时间：永不过期）
```

**过期时间的计算**：

```javascript
// packages/scheduler/src/forks/Scheduler.js

// 不同优先级的超时时间
var IMMEDIATE_PRIORITY_TIMEOUT = -1;           // 立即过期
var USER_BLOCKING_PRIORITY_TIMEOUT = 250;      // 250ms后过期
var NORMAL_PRIORITY_TIMEOUT = 5000;            // 5s后过期
var LOW_PRIORITY_TIMEOUT = 10000;              // 10s后过期
var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // 永不过期（1073741823ms）

function unstable_scheduleCallback(
  priorityLevel: PriorityLevel,
  callback: Callback,
  options?: {delay: number},
): Task {
  var currentTime = getCurrentTime();

  // 计算开始时间（支持延迟任务）
  var startTime;
  if (typeof options === 'object' && options !== null) {
    var delay = options.delay;
    if (typeof delay === 'number' && delay > 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  // 根据优先级计算超时时间
  var timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;      // -1
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;  // 250
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;           // maxInt
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;            // 10000
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;         // 5000
      break;
  }

  // 过期时间 = 开始时间 + 超时时间
  var expirationTime = startTime + timeout;

  // 创建任务对象
  var newTask: Task = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: -1,  // 稍后设置
  };

  if (startTime > currentTime) {
    // 延迟任务：放入timerQueue，按startTime排序
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);
    
    // 如果taskQueue为空且这是最早的延迟任务，设置定时器
    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      if (isHostTimeoutScheduled) {
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      }
      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    // 就绪任务：放入taskQueue，按expirationTime排序
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    
    // 调度主回调
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}
```

**关键理解**：
- **expirationTime越小，优先级越高**（最小堆）
- **过期的任务必须同步执行**，不能被中断（防止饥饿）
- **延迟任务**在startTime到达后才会移到taskQueue

---

## 三、时间切片的实现

### 1. 时间切片的核心：shouldYieldToHost

源码：`packages/scheduler/src/forks/Scheduler.js`

```javascript
// 默认每帧让出的时间
let frameInterval: number = frameYieldMs;  // 5ms
let startTime = -1;  // 任务开始时间

function shouldYieldToHost(): boolean {
  if (!enableAlwaysYieldScheduler && enableRequestPaint && needsPaint) {
    // 如果标记了需要绘制，立即让出
    return true;
  }
  
  // 计算已执行时间
  const timeElapsed = getCurrentTime() - startTime;
  
  if (timeElapsed < frameInterval) {
    // 执行时间小于5ms，继续执行
    return false;
  }
  
  // 执行时间≥5ms，应该让出
  return true;
}
```

**frameYieldMs的配置**：

```javascript
// packages/scheduler/src/SchedulerFeatureFlags.js
export const frameYieldMs = 5;  // 默认5ms
```

**为什么是5ms？**

```
60fps的帧预算：
一帧时间 = 1000ms / 60 = 16.6ms

一帧内的任务分配：
┌─────────────────────────────────────┐
│ JS执行(5ms) + 样式/布局(5ms) +      │
│ 绘制(3ms) + 合成(2ms) + 余量(1.6ms)│
└─────────────────────────────────────┘
         ↓
React选择5ms作为JS执行的时间片
保证剩余11.6ms给浏览器渲染
```

### 2. workLoop：Scheduler的核心循环

```javascript
function workLoop(initialTime: number) {
  let currentTime = initialTime;
  
  // 检查timerQueue中是否有任务到期，移到taskQueue
  advanceTimers(currentTime);
  
  // 取出最高优先级任务（expirationTime最小）
  currentTask = peek(taskQueue);
  
  while (currentTask !== null) {
    // 关键判断：任务未过期 && 应该让出
    if (currentTask.expirationTime > currentTime && shouldYieldToHost()) {
      // 时间片用完，退出循环
      break;
    }
    
    const callback = currentTask.callback;
    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;
      
      // 判断任务是否超时
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
      
      // 执行任务
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      
      // 如果返回函数，说明任务未完成，需要继续
      if (typeof continuationCallback === 'function') {
        currentTask.callback = continuationCallback;
        advanceTimers(currentTime);
        return true;  // 还有工作，需要继续调度
      } else {
        // 任务完成，从队列中移除
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
        advanceTimers(currentTime);
      }
    } else {
      // callback为null，移除任务
      pop(taskQueue);
    }
    
    // 取下一个任务
    currentTask = peek(taskQueue);
  }
  
  // 返回是否还有任务
  if (currentTask !== null) {
    return true;  // 还有任务，但时间片用完了
  } else {
    // taskQueue为空，检查timerQueue
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;  // 没有任务了
  }
}
```

**流程图**：

```
unstable_scheduleCallback(callback)
         ↓
    创建Task对象
         ↓
  是否延迟任务？
    /           \
  是            否
   ↓             ↓
timerQueue   taskQueue
   ↓             ↓
定时器回调    requestHostCallback
   ↓             ↓
handleTimeout  flushWork
   ↓             ↓
移到taskQueue  workLoop
               ↓
        ┌──────┴──────┐
        │  执行任务     │
        │  callback()  │
        └──────┬──────┘
               ↓
        shouldYield?
        /          \
      是            否
       ↓             ↓
   退出循环      继续下一个
   return true   任务
       ↓
   继续调度
```

### 3. MessageChannel实现异步调度

为什么不用`setTimeout`？

```javascript
// setTimeout的问题：
setTimeout(() => {
  console.log('执行');
}, 0);

// 实际延迟：
// - Chrome/Firefox: 最少1ms
// - 嵌套4次以上: 最少4ms（浏览器节流）
// 问题：延迟太长，影响响应速度
```

**Scheduler选择MessageChannel**：

```javascript
// packages/scheduler/src/forks/Scheduler.js

let schedulePerformWorkUntilDeadline;

if (typeof localSetImmediate === 'function') {
  // Node.js环境：使用setImmediate
  schedulePerformWorkUntilDeadline = () => {
    localSetImmediate(performWorkUntilDeadline);
  };
} else if (typeof MessageChannel !== 'undefined') {
  // 浏览器环境：使用MessageChannel
  const channel = new MessageChannel();
  const port = channel.port2;
  
  channel.port1.onmessage = performWorkUntilDeadline;
  
  schedulePerformWorkUntilDeadline = () => {
    port.postMessage(null);
  };
} else {
  // 降级方案：使用setTimeout
  schedulePerformWorkUntilDeadline = () => {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
}

// 主调度函数
function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    schedulePerformWorkUntilDeadline();
  }
}

// 执行任务直到截止时间
const performWorkUntilDeadline = () => {
  if (scheduledHostCallback !== null) {
    const currentTime = getCurrentTime();
    
    // 记录开始时间（用于shouldYieldToHost判断）
    startTime = currentTime;
    
    const hasTimeRemaining = true;
    let hasMoreWork = true;
    
    try {
      // 执行workLoop
      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
    } finally {
      if (hasMoreWork) {
        // 还有任务，继续调度
        schedulePerformWorkUntilDeadline();
      } else {
        isMessageLoopRunning = false;
        scheduledHostCallback = null;
      }
    }
  } else {
    isMessageLoopRunning = false;
  }
  
  needsPaint = false;
};
```

**MessageChannel的优势**：

```
对比三种方案：

1. setTimeout(fn, 0)
   延迟：≥1ms，嵌套后≥4ms
   优点：兼容性好
   缺点：延迟高，被浏览器节流

2. setImmediate(fn)
   延迟：几乎没有
   优点：专为异步任务设计
   缺点：只有IE和Node.js支持

3. MessageChannel
   延迟：<1ms（宏任务，比setTimeout快）
   优点：现代浏览器都支持，延迟低
   缺点：需要polyfill旧浏览器

React选择MessageChannel，在Node.js降级到setImmediate
```

---

## 四、Scheduler与React的集成

### 1. React如何调用Scheduler

源码：`packages/react-reconciler/src/ReactFiberRootScheduler.js`

```javascript
// React调度一个并发渲染任务
function performWorkOnRootViaSchedulerTask(
  root: FiberRoot,
  didTimeout: boolean,
): RenderTaskFn | null {
  // 这是通过Scheduler调度的并发任务的入口
  
  // 刷新pending的副作用
  const originalCallbackNode = root.callbackNode;
  const didFlushPassiveEffects = flushPendingEffectsDelayed();
  
  if (didFlushPassiveEffects) {
    // 副作用可能取消了当前任务
    if (root.callbackNode !== originalCallbackNode) {
      return null;
    }
  }

  // 获取下一批要处理的lanes
  const workInProgressRoot = getWorkInProgressRoot();
  const workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();
  const lanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );
  
  if (lanes === NoLanes) {
    // 没有工作了
    return null;
  }

  // 进入工作循环
  const forceSync = !disableSchedulerTimeoutInWorkLoop && didTimeout;
  performWorkOnRoot(root, lanes, forceSync);
  
  // 如果root上还有工作，返回自己以继续
  if (root.callbackNode === originalCallbackNode) {
    return performWorkOnRootViaSchedulerTask.bind(null, root);
  }
  
  return null;
}

// 调度任务
function scheduleCallback(
  priorityLevel: PriorityLevel,
  callback: RenderTaskFn,
) {
  if (__DEV__ && ReactSharedInternals.actQueue !== null) {
    // act环境下的特殊处理
    ReactSharedInternals.actQueue.push(callback);
    return fakeActCallbackNode;
  } else {
    // 调用Scheduler的scheduleCallback
    return Scheduler.unstable_scheduleCallback(priorityLevel, callback);
  }
}
```

### 2. workLoop与shouldYield的配合

源码：`packages/react-reconciler/src/ReactFiberWorkLoop.js`

```javascript
// 并发渲染的工作循环
function renderRootConcurrent(root: FiberRoot, lanes: Lanes) {
  // ...
  
  // 开始工作循环
  outer: do {
    try {
      if (
        workInProgressSuspendedReason !== NotSuspended &&
        workInProgress !== null
      ) {
        // 处理挂起的工作
        // ...
      } else {
        // 正常工作循环
        workLoopConcurrent();
      }
      break;
    } catch (thrownValue) {
      // 错误处理
      handleThrow(root, thrownValue);
    }
  } while (true);
  
  // ...
}

// 可中断的工作循环
function workLoopConcurrent() {
  // 当有工作 且 不应该让出时，继续执行
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

// shouldYield来自Scheduler
import { unstable_shouldYield as shouldYield } from 'scheduler';
```

**完整流程**：

```
用户触发更新（setState）
         ↓
   requestUpdateLane
         ↓
   scheduleUpdateOnFiber
         ↓
   ensureRootIsScheduled
         ↓
   Scheduler.unstable_scheduleCallback(
     NormalPriority,
     performWorkOnRootViaSchedulerTask
   )
         ↓
   Scheduler.workLoop执行任务
         ↓
   performWorkOnRootViaSchedulerTask
         ↓
   renderRootConcurrent
         ↓
   workLoopConcurrent
         ↓
   ┌──────────────────────┐
   │ while (workInProgress│
   │    && !shouldYield()) │
   │   performUnitOfWork() │
   └──────────────────────┘
         ↓
   shouldYield() === true
         ↓
   退出workLoopConcurrent
         ↓
   返回continuation
         ↓
   Scheduler继续调度
```

---

## 五、实际应用场景

### 场景1：大型列表渲染

```javascript
function LargeList() {
  const items = Array(5000).fill(0).map((_, i) => ({
    id: i,
    title: `Item ${i}`,
  }));

  return (
    <div>
      {items.map(item => (
        <ExpensiveItem key={item.id} item={item} />
      ))}
    </div>
  );
}

function ExpensiveItem({ item }) {
  // 假设每个组件渲染需要1ms
  const result = complexCalculation(item);
  return <div>{result}</div>;
}
```

**没有时间切片**：

```
渲染5000个组件：
┌────────────────────────────────────┐
│ JS执行5000ms                       │
└────────────────────────────────────┘
  ↓
❌ 主线程被阻塞5秒
❌ 用户无法滚动、点击
❌ 页面完全卡死
```

**有时间切片**：

```
渲染5000个组件：
┌─JS(5ms)─┐  ┌─JS(5ms)─┐  ┌─JS(5ms)─┐ ... ┌─JS(5ms)─┐
│5个组件  │  │5个组件  │  │5个组件  │     │5个组件  │
└────────┘  └────────┘  └────────┘     └────────┘
    ↓ yield   ↓ yield   ↓ yield         ↓ yield
  浏览器    浏览器     浏览器          浏览器
  渲染      渲染       渲染            渲染
  
✅ 每5ms让出一次
✅ 用户可以滚动、点击
✅ 页面保持响应
✅ 总时间可能略长（5秒+调度开销），但体验好
```

### 场景2：优先级插队

```javascript
function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const deferredQuery = useDeferredValue(query);

  useEffect(() => {
    // 低优先级：搜索结果
    const filtered = expensiveSearch(deferredQuery);
    setResults(filtered);
  }, [deferredQuery]);

  return (
    <div>
      {/* 高优先级：输入框 */}
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      
      {/* 低优先级：结果列表 */}
      <ResultsList results={results} />
    </div>
  );
}
```

**时间轴**：

```
时刻0: 用户输入 "R"
  → Scheduler调度高优先级任务（UserBlockingPriority）
  → expirationTime = currentTime + 250ms

时刻1: 开始渲染输入框
  → workLoop执行

时刻6: 渲染完成
  → 输入框显示 "R"

时刻10: useDeferredValue触发搜索
  → Scheduler调度低优先级任务（NormalPriority）
  → expirationTime = currentTime + 5000ms

时刻15: 开始渲染结果（低优先级）
  → workLoop执行
  → 渲染50个结果项...

时刻20: 用户继续输入 "e"
  → 新的高优先级任务！
  → shouldYield()检查：当前任务expirationTime > 新任务
  → 中断低优先级渲染
  
时刻21: 开始渲染新的输入框状态
  → 输入框显示 "Re"

时刻26: 输入框渲染完成

时刻30: 继续渲染低优先级的搜索结果
  → 使用新的query "Re"
```

**关键机制**：

```javascript
// Scheduler的优先级判断
function workLoop(initialTime: number) {
  // ...
  while (currentTask !== null) {
    // 如果有更高优先级的任务进来
    // taskQueue会重新排序（最小堆）
    // 高优先级任务的expirationTime更小，会排在前面
    
    if (currentTask.expirationTime > currentTime && shouldYieldToHost()) {
      // 当前任务未过期 且 时间片用完
      // 让出，下次循环会先执行高优先级任务
      break;
    }
    
    // 执行任务...
  }
}
```

### 场景3：防止任务饥饿

```javascript
function App() {
  const [count, setCount] = useState(0);

  // 持续的低优先级更新
  useEffect(() => {
    const timer = setInterval(() => {
      startTransition(() => {
        setCount(c => c + 1);  // 低优先级
      });
    }, 10);  // 每10ms更新一次
    
    return () => clearInterval(timer);
  }, []);

  return <div>Count: {count}</div>;
}
```

**过期时间保护**：

```
时间轴：
t=0:     调度低优先级任务1 (expirationTime = 5000ms)
t=10:    调度低优先级任务2 (expirationTime = 5010ms)
t=20:    调度低优先级任务3 (expirationTime = 5020ms)
...
t=5000:  任务1过期！
         ↓
  workLoop检测到 currentTask.expirationTime <= currentTime
         ↓
  忽略shouldYieldToHost()，强制执行完成
         ↓
  确保任务不会永远等待（防止饥饿）
```

---

## 六、性能优化与最佳实践

### 1. 合理使用优先级

```javascript
import { unstable_scheduleCallback, unstable_UserBlockingPriority } from 'scheduler';

// ❌ 不好：所有更新都是相同优先级
function handleClick() {
  setCounter(c => c + 1);
  setData(expensiveComputation());
}

// ✅ 好：区分优先级
function handleClick() {
  // 高优先级：用户反馈
  setCounter(c => c + 1);
  
  // 低优先级：耗时计算
  startTransition(() => {
    setData(expensiveComputation());
  });
}
```

### 2. 避免阻塞渲染

```javascript
// ❌ 不好：同步阻塞
function processData(data) {
  for (let i = 0; i < 10000; i++) {
    heavyCalculation(data[i]);
  }
}

// ✅ 好：使用Web Worker
function processData(data) {
  const worker = new Worker('processor.js');
  worker.postMessage(data);
  worker.onmessage = (e) => {
    setResult(e.data);
  };
}

// ✅ 更好：React并发特性
function ProcessData({ data }) {
  const [result, setResult] = useState([]);

  useEffect(() => {
    startTransition(() => {
      const processed = data.map(item => heavyCalculation(item));
      setResult(processed);
    });
  }, [data]);

  return <ResultDisplay result={result} />;
}
```

### 3. 监控性能

```javascript
// 使用React Profiler
import { Profiler } from 'react';

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime,
) {
  console.log(`${id} (${phase}) 渲染耗时: ${actualDuration}ms`);
  
  if (actualDuration > 16) {
    console.warn('渲染超过一帧时间，可能导致卡顿！');
  }
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <YourComponent />
    </Profiler>
  );
}
```

---

## 七、Scheduler的演进

### React 16-17: 基于expirationTime

```javascript
// 旧版本
const expirationTime = computeExpirationTime(currentTime, priorityLevel);

// 问题：
// 1. 无法同时处理多个优先级
// 2. 优先级表达能力有限
// 3. 难以实现批量更新
```

### React 18+: 基于Lane模型

```javascript
// 新版本
const lane = requestUpdateLane(fiber);

// 优势：
// 1. 支持31个优先级（二进制位）
// 2. 可以用位运算快速判断和合并
// 3. 支持更复杂的并发场景
```

### 未来: Scheduler.postTask

```javascript
// 浏览器原生API（实验性）
scheduler.postTask(
  callback,
  { priority: 'user-blocking' }  // 浏览器原生优先级
);

// React正在迁移到这个API
// packages/scheduler/src/forks/SchedulerPostTask.js
```

---

## 八、源码关键路径

```
Scheduler核心文件：

packages/scheduler/src/
├── Scheduler.js                      # 主实现（浏览器环境）
│   ├── unstable_scheduleCallback()   # 调度任务
│   ├── workLoop()                    # 执行任务循环
│   ├── shouldYieldToHost()           # 时间切片判断
│   └── performWorkUntilDeadline()    # MessageChannel回调
│
├── SchedulerPriorities.js            # 优先级定义
├── SchedulerFeatureFlags.js          # 特性开关（frameYieldMs等）
├── SchedulerMinHeap.js               # 最小堆实现
│
└── forks/
    ├── SchedulerPostTask.js          # 使用postTask API的版本
    ├── SchedulerMock.js              # 测试用的mock版本
    └── SchedulerNative.js            # React Native版本

React集成：

packages/react-reconciler/src/
├── ReactFiberRootScheduler.js        # React调用Scheduler
│   └── scheduleCallback()            # 包装Scheduler
│
└── ReactFiberWorkLoop.js             # React工作循环
    ├── renderRootConcurrent()        # 并发渲染入口
    ├── workLoopConcurrent()          # 可中断的工作循环
    └── shouldYield()                 # 从Scheduler导入
```

---

## 九、调试技巧

### 1. 查看Scheduler状态

```javascript
// 在DevTools Console中
import * as Scheduler from 'scheduler';

// 查看当前优先级
console.log(Scheduler.unstable_getCurrentPriorityLevel());

// 手动调度任务
Scheduler.unstable_scheduleCallback(
  Scheduler.unstable_NormalPriority,
  () => {
    console.log('任务执行');
  }
);

// 检查是否应该让出
console.log(Scheduler.unstable_shouldYield());
```

### 2. Performance面板分析

```
Chrome DevTools → Performance:

1. 录制用户交互
2. 查看Main线程
3. 找到 "performWorkUntilDeadline" 调用
4. 观察:
   - 每个任务的执行时间（应该≤5ms）
   - 任务之间的间隔（浏览器渲染时间）
   - Long Task（超过50ms的任务）

理想状态：
┌─Task(5ms)─┐ 间隔 ┌─Task(5ms)─┐ 间隔 ┌─Task(5ms)─┐
└───────────┘      └───────────┘      └───────────┘
      浏览器渲染         浏览器渲染         浏览器渲染
```

### 3. React DevTools Profiler

```
React DevTools → Profiler:

1. Flamegraph视图：
   - 查看组件渲染时间
   - 识别耗时组件

2. Ranked视图：
   - 按渲染时间排序
   - 找出最慢的组件

3. Timeline视图：
   - 查看渲染过程中的让出点
   - 观察时间切片效果
```

---

## 十、面试要点速记

### 快速回答框架

**Scheduler是什么？**
- React的独立调度器包
- 负责任务调度和时间切片
- 支持优先级和可中断渲染

**时间切片如何实现？**
1. **默认5ms切片**：`frameYieldMs = 5`
2. **shouldYieldToHost()**：检查执行时间
3. **MessageChannel**：异步调度（比setTimeout快）
4. **workLoop**：执行任务，定期检查shouldYield

**五种优先级？**
1. Immediate（-1ms）：立即执行
2. UserBlocking（250ms）：用户交互
3. Normal（5s）：普通更新
4. Low（10s）：低优先级
5. Idle（永不）：空闲时执行

**如何防止饥饿？**
- 过期时间机制
- 任务过期后必须同步执行
- 忽略shouldYield，强制完成

### 加分项

1. **能解释MessageChannel的优势**：比setTimeout快，不被节流
2. **能说明过期时间的计算**：startTime + timeout
3. **能结合React的workLoop**：说明shouldYield的调用时机
4. **能分析性能影响**：5ms切片 vs 一帧16.6ms的关系

### 常见追问

**Q: 为什么不用requestIdleCallback？**
A:
- 浏览器兼容性差（Safari不支持）
- 只在浏览器空闲时执行，不够可控
- React需要更精确的时间控制
- requestIdleCallback的触发时机不稳定

**Q: 5ms的时间片是如何确定的？**
A:
- 60fps = 16.6ms/帧
- JS执行目标：≤5ms
- 剩余时间：11.6ms给浏览器渲染
- 权衡：太短增加调度开销，太长影响响应

**Q: 时间切片会导致性能损失吗？**
A:
- 有轻微开销：
  1. 调度开销（MessageChannel）
  2. 保存/恢复状态
  3. shouldYield检查
- 但收益更大：
  1. 页面保持响应
  2. 避免长时间阻塞
  3. 更好的用户体验
- 实际测量：开销<5%

**Q: concurrent模式下如何保证数据一致性？**
A:
- 双缓存机制：current树始终完整
- 用户看到的是current树
- workInProgress树可以被中断/重建
- commit阶段才切换，保证原子性

---

**参考资料**：
- React源码：`packages/scheduler/src/forks/Scheduler.js`
- [Scheduler RFC](https://github.com/facebook/react/pull/13206)
- [Building a Custom React Scheduler](https://philippspiess.com/scheduling-in-react/)

**最后更新**: 2025-11-05

