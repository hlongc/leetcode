# 12 - React更新优先级详解

> **问题**: React中有几种更新优先级（Priority）？不同优先级的更新是如何被调度和处理的？

---

## 一、优先级系统概述

React有**两套优先级体系**：
1. **事件优先级（EventPriority）**：用户交互事件的优先级
2. **Lane优先级（Lane）**：Fiber更新的优先级

它们之间可以相互转换。

### 事件优先级（EventPriority）

源码：`packages/react-reconciler/src/ReactEventPriorities.js`

```javascript
export opaque type EventPriority = Lane;

export const NoEventPriority: EventPriority = NoLane;           // 0
export const DiscreteEventPriority: EventPriority = SyncLane;   // 离散事件（最高）
export const ContinuousEventPriority: EventPriority = InputContinuousLane;  // 连续事件
export const DefaultEventPriority: EventPriority = DefaultLane; // 默认优先级
export const IdleEventPriority: EventPriority = IdleLane;       // 空闲优先级（最低）
```

**四种事件优先级**：

```javascript
// 1. DiscreteEventPriority（离散事件，最高优先级）
// 触发：click、input、focus、blur、submit等
// 特点：用户直接交互，需要立即响应
onClick, onInput, onFocus, onBlur, onSubmit

// 2. ContinuousEventPriority（连续事件）
// 触发：drag、scroll、mouse move、touch move等
// 特点：连续触发，但仍需要较快响应
onDrag, onScroll, onMouseMove, onTouchMove

// 3. DefaultEventPriority（默认优先级）
// 触发：setTimeout、网络请求回调等
// 特点：没有直接用户交互的更新
setTimeout(() => setState(...))
fetch().then(() => setState(...))

// 4. IdleEventPriority（空闲优先级，最低）
// 触发：requestIdleCallback等
// 特点：不紧急的更新，可以延迟执行
requestIdleCallback(() => setState(...))
```

### Lane优先级（31个lane）

源码：`packages/react-reconciler/src/ReactFiberLane.js`

```javascript
export type Lanes = number;  // 32位二进制数
export type Lane = number;

export const TotalLanes = 31;  // 共31个lane（位0-30）

// ========== 同步优先级 ==========
export const SyncLane: Lane = 0b0000000000000000000000000000010;

// ========== 输入优先级 ==========
export const InputContinuousLane: Lane = 0b0000000000000000000000000001000;

// ========== 默认优先级 ==========
export const DefaultLane: Lane = 0b0000000000000000000000000100000;

// ========== 手势优先级 ==========
export const GestureLane: Lane = 0b0000000000000000000000001000000;

// ========== 过渡优先级（14个） ==========
const TransitionLane1: Lane  = 0b0000000000000000000000100000000;
const TransitionLane2: Lane  = 0b0000000000000000000001000000000;
const TransitionLane3: Lane  = 0b0000000000000000000010000000000;
// ... TransitionLane4-14

// ========== 重试优先级（4个） ==========
const RetryLane1: Lane = 0b0000000010000000000000000000000;
const RetryLane2: Lane = 0b0000000100000000000000000000000;
const RetryLane3: Lane = 0b0000001000000000000000000000000;
const RetryLane4: Lane = 0b0000010000000000000000000000000;

// ========== 空闲优先级 ==========
export const IdleLane: Lane = 0b0010000000000000000000000000000;

// ========== 离屏/延迟优先级 ==========
export const OffscreenLane: Lane = 0b0100000000000000000000000000000;
export const DeferredLane: Lane = 0b1000000000000000000000000000000;
```

**Lane的优先级规则**：

```
二进制位越小，优先级越高

SyncLane          = 0b...010 （位1，最高优先级）
InputContinuous   = 0b...001000 （位3）
DefaultLane       = 0b...0100000 （位5）
TransitionLane1   = 0b...100000000 （位8）
IdleLane          = 0b010... （位29，低优先级）

优先级：SyncLane > InputContinuous > Default > Transition > Idle
```

---

## 二、优先级的获取与分配

### requestUpdateLane：分配lane

```javascript
export function requestUpdateLane(fiber: Fiber): Lane {
  // 1. 获取当前更新优先级
  const updatePriority = getCurrentUpdatePriority();
  if (updatePriority !== NoEventPriority) {
    return eventPriorityToLane(updatePriority);
  }

  // 2. 从事件中推断优先级
  const eventPriority = getCurrentEventPriority();
  return eventPriorityToLane(eventPriority);
}
```

**不同场景的lane分配**：

```javascript
// 场景1：用户点击按钮
<button onClick={() => setState(1)}>Click</button>

执行流程：
1. 浏览器click事件
2. React事件系统识别为DiscreteEvent
3. setCurrentUpdatePriority(DiscreteEventPriority)
4. setState触发更新
5. requestUpdateLane() → SyncLane
6. update.lane = SyncLane

// 场景2：setTimeout中更新
setTimeout(() => {
  setState(1);
}, 1000);

执行流程：
1. setTimeout回调执行
2. 没有事件上下文
3. getCurrentEventPriority() → DefaultEventPriority
4. requestUpdateLane() → DefaultLane
5. update.lane = DefaultLane

// 场景3：startTransition中更新
startTransition(() => {
  setState(1);
});

执行流程：
1. startTransition设置Transition标记
2. requestUpdateLane() → TransitionLane1
3. update.lane = TransitionLane1
```

---

## 三、优先级的调度

### scheduleUpdateOnFiber：调度更新

```javascript
export function scheduleUpdateOnFiber(
  root: FiberRoot,
  fiber: Fiber,
  lane: Lane,
) {
  // 1. 标记fiber和root上的lanes
  markRootUpdated(root, lane);

  // 2. 根据lane决定调度方式
  if (lane === SyncLane) {
    // 同步lane：立即调度
    if (executionContext === NoContext) {
      flushSyncWork();
    }
  } else {
    // 异步lane：通过Scheduler调度
    ensureRootIsScheduled(root);
  }
}

function ensureRootIsScheduled(root: FiberRoot) {
  // 获取下一批要处理的lanes（最高优先级）
  const nextLanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,
  );

  if (nextLanes === NoLanes) {
    // 没有工作
    return;
  }

  // 获取lane对应的事件优先级
  const newCallbackPriority = getHighestPriorityLane(nextLanes);

  // 如果已经调度了相同或更高优先级的任务，跳过
  const existingCallbackPriority = root.callbackPriority;
  if (existingCallbackPriority === newCallbackPriority) {
    return;
  }

  // 取消旧的调度
  if (existingCallbackNode !== null) {
    cancelCallback(existingCallbackNode);
  }

  // 根据优先级选择调度方式
  if (includesSyncLane(newCallbackPriority)) {
    // 同步优先级：微任务调度
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
    queueMicrotask(flushSyncCallbacks);
  } else {
    // 异步优先级：Scheduler调度
    const schedulerPriorityLevel = lanesToSchedulerPriority(newCallbackPriority);
    
    newCallbackNode = scheduleCallback(
      schedulerPriorityLevel,
      performConcurrentWorkOnRoot.bind(null, root)
    );
  }

  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}
```

**调度流程图**：

```
setState()
    ↓
requestUpdateLane() → 分配Lane
    ↓
scheduleUpdateOnFiber(root, fiber, lane)
    ↓
markRootUpdated(root, lane)  // 标记lanes
    ↓
ensureRootIsScheduled(root)
    ↓
getNextLanes(root) → 获取最高优先级lanes
    ↓
    ┌────────────────┐
    │ 优先级判断     │
    └────┬──────┬────┘
      Sync  │  其他
         ↓  ↓
    微任务  Scheduler调度
         ↓
    performSyncWorkOnRoot
         或
    performConcurrentWorkOnRoot
```

---

## 四、优先级的处理

### 高优先级打断低优先级

```javascript
// 示例
function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  return (
    <>
      {/* 高优先级：点击事件 */}
      <button onClick={() => setCount(c => c + 1)}>
        Count: {count}
      </button>
      
      {/* 低优先级：Transition更新 */}
      <button onClick={() => {
        startTransition(() => {
          setText('Loading...');
        });
      }}>
        Update Text
      </button>
      
      <ExpensiveList text={text} />
    </>
  );
}
```

**执行时序**：

```
t=0: 点击"Update Text"
  → startTransition(() => setText(...))
  → 分配TransitionLane
  → 开始render（低优先级）

t=10: 低优先级render进行中（ExpensiveList渲染很慢）
  → workInProgress树构建中...

t=20: 用户点击"Count"按钮（高优先级）
  → onClick触发
  → 分配SyncLane
  → scheduleUpdateOnFiber
  
  检测到：
  - 当前正在render（workInProgressRoot !== null）
  - 新update优先级(SyncLane) > 当前优先级(TransitionLane)
  
  → 中断当前render！
  → 保存workInProgress状态
  → 开始新的高优先级render

t=21: 高优先级render
  → renderRootSync（同步渲染）
  → 只处理SyncLane的更新
  → count: 0 → 1
  → commit并显示

t=30: 恢复低优先级render
  → renderRootConcurrent
  → 处理TransitionLane的更新
  → text: '' → 'Loading...'
  → ExpensiveList重新渲染
  → commit并显示
```

### getNextLanes：选择要处理的lanes

```javascript
export function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes {
  // 1. 获取所有pending的lanes
  const pendingLanes = root.pendingLanes;
  if (pendingLanes === NoLanes) {
    return NoLanes;
  }

  let nextLanes: Lanes = NoLanes;

  // 2. 排除已暂停的lanes
  const nonIdlePendingLanes = pendingLanes & NonIdleLanes;
  if (nonIdlePendingLanes !== NoLanes) {
    // 有非Idle的工作
    const nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
    if (nonIdleUnblockedLanes !== NoLanes) {
      // 选择最高优先级的lanes
      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
    } else {
      // 所有lanes都被suspend，选择suspend中最高优先级的
      const nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
      if (nonIdlePingedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
      }
    }
  } else {
    // 只有Idle工作
    const unblockedLanes = pendingLanes & ~suspendedLanes;
    if (unblockedLanes !== NoLanes) {
      nextLanes = getHighestPriorityLanes(unblockedLanes);
    } else {
      if (pingedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(pingedLanes);
      }
    }
  }

  if (nextLanes === NoLanes) {
    return NoLanes;
  }

  // 3. 处理entanglement（纠缠）
  // 某些lanes需要一起处理
  nextLanes = entangleLanes(root, nextLanes);

  return nextLanes;
}
```

---

## 五、Lane的位运算

### 基本操作

```javascript
// 1. 检查是否包含某个lane
function includesLane(set: Lanes, lane: Lane): boolean {
  return (set & lane) !== NoLanes;
}

// 示例
const lanes = 0b0000000000000000000000000101010;  // 包含多个lane
const syncLane = 0b0000000000000000000000000000010;
includesLane(lanes, syncLane);  // true

// 2. 合并lanes
function mergeLanes(a: Lanes, b: Lanes): Lanes {
  return a | b;
}

const lane1 = 0b010;
const lane2 = 0b100;
mergeLanes(lane1, lane2);  // 0b110

// 3. 移除lane
function removeLanes(set: Lanes, subset: Lanes): Lanes {
  return set & ~subset;
}

const lanes = 0b111;
const toRemove = 0b010;
removeLanes(lanes, toRemove);  // 0b101

// 4. 获取最高优先级lane
function getHighestPriorityLane(lanes: Lanes): Lane {
  return lanes & -lanes;  // 提取最低位的1
}

// 原理：
// lanes = 0b10110
// -lanes = ...11111111111111111101010（补码）
// lanes & -lanes = 0b00010（最低位的1）
```

**为什么使用二进制位？**

```
优势：
1. 位运算极快（CPU原生支持）
2. 可以用一个数字表示多个lane
3. 支持批量操作（多个更新合并）
4. 天然支持优先级比较（数值大小）

示例：
lanes = 0b0000000000000000000000000101010
表示同时有：
  - 位1的lane（SyncLane）
  - 位3的lane（InputContinuousLane）  
  - 位5的lane（DefaultLane）

一次render可以同时处理多个lane的更新
```

---

## 六、实际应用场景

### 场景1：用户输入与搜索

```javascript
function SearchBox() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    // 高优先级：立即更新输入框
    setQuery(e.target.value);  // DiscreteEventPriority → SyncLane
    
    // 低优先级：搜索结果可以延迟
    startTransition(() => {
      const filtered = searchData(e.target.value);
      setResults(filtered);  // TransitionLane
    });
  };

  return (
    <>
      <input value={query} onChange={handleChange} />
      <ResultsList results={results} />
    </>
  );
}

// 优先级处理：
// 1. 输入框更新：SyncLane，立即render
//    → 用户立即看到输入
// 2. 搜索结果：TransitionLane，可中断
//    → 如果用户继续输入，中断搜索render
//    → 优先处理新的输入
```

### 场景2：动画与数据加载

```javascript
function Dashboard() {
  const [animationFrame, setAnimationFrame] = useState(0);
  const [data, setData] = useState([]);

  useEffect(() => {
    // 高优先级：动画每帧更新
    let rafId;
    const animate = () => {
      setAnimationFrame(f => f + 1);  // ContinuousEventPriority
      rafId = requestAnimationFrame(animate);
    };
    rafId = requestAnimationFrame(animate);
    
    return () => cancelAnimationFrame(rafId);
  }, []);

  useEffect(() => {
    // 低优先级：数据加载
    startTransition(() => {
      fetchData().then(setData);  // TransitionLane
    });
  }, []);

  return (
    <>
      <Animation frame={animationFrame} />  {/* 60fps */}
      <DataTable data={data} />             {/* 可中断 */}
    </>
  );
}

// 效果：
// 动画流畅（高优先级）
// 数据加载不影响动画（低优先级，被打断）
```

### 场景3：多个优先级并发

```javascript
function App() {
  const [urgent, setUrgent] = useState(0);
  const [normal, setNormal] = useState(0);
  const [idle, setIdle] = useState(0);

  const handleClick = () => {
    // 紧急更新
    flushSync(() => {
      setUrgent(u => u + 1);  // SyncLane
    });

    // 普通更新
    setNormal(n => n + 1);  // DefaultLane

    // 空闲更新
    startTransition(() => {
      setIdle(i => i + 1);  // TransitionLane
    });
  };

  return (
    <>
      <div>Urgent: {urgent}</div>
      <div>Normal: {normal}</div>
      <div>Idle: {idle}</div>
      <button onClick={handleClick}>Update All</button>
    </>
  );
}

// 执行顺序：
// 1. flushSync立即同步执行，urgent更新
// 2. normal和idle的更新入队
// 3. 调度render
// 4. 先处理DefaultLane（normal）
// 5. 再处理TransitionLane（idle）
```

---

## 七、优先级与过期时间

### 防止饥饿机制

```javascript
// Lane的过期时间
const syncLaneExpirationMs = 250;          // 同步：250ms
const transitionLaneExpirationMs = 5000;   // 过渡：5s
const retryLaneExpirationMs = 5000;        // 重试：5s

// 过期检测
export function markStarvedLanesAsExpired(
  root: FiberRoot,
  currentTime: number,
): void {
  const pendingLanes = root.pendingLanes;
  const suspendedLanes = root.suspendedLanes;
  const pingedLanes = root.pingedLanes;

  const expirationTimes = root.expirationTimes;

  let lanes = pendingLanes & ~suspendedLanes;
  while (lanes > 0) {
    const index = pickArbitraryLaneIndex(lanes);
    const lane = 1 << index;

    const expirationTime = expirationTimes[index];
    if (expirationTime === NoTimestamp) {
      // 首次调度，设置过期时间
      expirationTimes[index] = computeExpirationTime(lane, currentTime);
    } else if (expirationTime <= currentTime) {
      // 已过期！强制同步执行
      root.expiredLanes |= lane;
    }

    lanes &= ~lane;
  }
}

// 过期的lane会被升级为同步执行
// 防止低优先级任务永远得不到执行（饥饿）
```

**过期示例**：

```
t=0: TransitionLane更新
  → expirationTime = currentTime + 5000ms = 5000

t=1000: 高优先级更新插队
  → TransitionLane被跳过

t=3000: 又一个高优先级更新
  → TransitionLane继续等待

t=5100: 检查过期
  → currentTime = 5100 > expirationTime = 5000
  → TransitionLane过期！
  → expiredLanes |= TransitionLane
  → 下次render必须处理，不能再被打断
```

---

## 八、优先级转换

### EventPriority ↔ Lane

```javascript
// EventPriority → Lane
export function eventPriorityToLane(eventPriority: EventPriority): Lane {
  return eventPriority;  // 直接相等
}

// Lane → EventPriority
export function lanesToEventPriority(lanes: Lanes): EventPriority {
  const lane = getHighestPriorityLane(lanes);
  
  if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
    return DiscreteEventPriority;
  }
  if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
    return ContinuousEventPriority;
  }
  if (includesNonIdleWork(lane)) {
    return DefaultEventPriority;
  }
  return IdleEventPriority;
}
```

### Lane ↔ SchedulerPriority

```javascript
// Lane → Scheduler优先级
export function lanesToSchedulerPriority(lanes: Lanes): SchedulerPriority {
  const lane = getHighestPriorityLane(lanes);
  
  if (includesSyncLane(lane)) {
    return ImmediateSchedulerPriority;
  }
  if (includesInputContinuousLane(lane)) {
    return UserBlockingSchedulerPriority;
  }
  if (includesTransitionLane(lane)) {
    return NormalSchedulerPriority;
  }
  if (includesIdleLane(lane)) {
    return IdleSchedulerPriority;
  }
  
  return NormalSchedulerPriority;
}

// 对应关系：
SyncLane            → ImmediateSchedulerPriority    (-1ms)
InputContinuousLane → UserBlockingSchedulerPriority (250ms)
DefaultLane         → NormalSchedulerPriority       (5000ms)
TransitionLane      → NormalSchedulerPriority       (5000ms)
IdleLane            → IdleSchedulerPriority         (maxInt)
```

---

## 九、源码关键路径

```
优先级系统核心文件：

packages/react-reconciler/src/
├── ReactEventPriorities.js             # 事件优先级定义
│   ├── DiscreteEventPriority          # 离散事件（click等）
│   ├── ContinuousEventPriority        # 连续事件（scroll等）
│   ├── DefaultEventPriority           # 默认优先级
│   ├── IdleEventPriority              # 空闲优先级
│   └── lanesToEventPriority()         # Lane转EventPriority
│
├── ReactFiberLane.js                  # Lane优先级系统
│   ├── 31个Lane定义                   # SyncLane、TransitionLane等
│   ├── getHighestPriorityLane()       # 位运算提取最高优先级
│   ├── mergeLanes()                   # 合并lanes
│   ├── removeLanes()                  # 移除lanes
│   ├── includesLane()                 # 检查是否包含
│   ├── getNextLanes()                 # 选择下一批lanes
│   └── markStarvedLanesAsExpired()    # 过期检测
│
├── ReactFiberWorkLoop.js              # 调度逻辑
│   ├── requestUpdateLane()            # 分配lane
│   ├── scheduleUpdateOnFiber()        # 调度更新
│   ├── ensureRootIsScheduled()        # 确保调度
│   ├── performSyncWorkOnRoot()        # 同步工作
│   └── performConcurrentWorkOnRoot()  # 并发工作
│
└── ReactFiberRootScheduler.js         # 根调度器
    └── lanesToSchedulerPriority()     # Lane转Scheduler优先级
```

---

## 十、面试要点速记

### 快速回答框架

**React有几种优先级？**
- 事件优先级：4种（Discrete、Continuous、Default、Idle）
- Lane优先级：31个lane
- Scheduler优先级：5种（Immediate、UserBlocking、Normal、Low、Idle）

**不同优先级如何调度？**
1. 根据事件类型分配lane
2. 标记fiber和root的lanes
3. 选择最高优先级的lanes
4. 同步lane用微任务，异步lane用Scheduler
5. 高优先级可以打断低优先级

**Lane模型的优势？**
- 位运算快速
- 支持批量操作
- 31个优先级级别
- 自然支持过期机制

**如何防止饥饿？**
- 过期时间机制
- 低优先级任务过期后升级为同步
- 强制执行，不能被打断

### 加分项

1. **能解释Lane的位运算**：
   - 位越小优先级越高
   - & | ~ 等操作

2. **能说明优先级打断机制**：
   - 保存workInProgress
   - 处理高优先级
   - 恢复低优先级

3. **能给出实际场景**：
   - 输入框+搜索
   - 动画+数据加载
   - flushSync强制同步

4. **能对比三套优先级**：
   - EventPriority
   - Lane
   - SchedulerPriority

### 常见追问

**Q: Lane模型相比expirationTime有什么优势？**
A:
- expirationTime：单一优先级，无法表达复杂场景
- Lane：31个优先级，支持批量处理
- 位运算快速，支持entanglement（纠缠）

**Q: 为什么需要这么多优先级？**
A:
- 不同类型的更新需要不同响应速度
- 用户交互需要立即响应
- 数据加载可以延迟
- 动画需要稳定帧率
- 细粒度优先级提升用户体验

**Q: startTransition的原理是什么？**
A:
- 设置Transition上下文
- 内部的setState分配TransitionLane
- 低优先级，可被打断
- 适合非紧急的UI更新

**Q: flushSync如何实现同步更新？**
A:
```javascript
flushSync(() => {
  setState(1);
});

// 1. 设置executionContext包含BatchedContext
// 2. setState分配SyncLane
// 3. 立即同步执行render和commit
// 4. 不走Scheduler，直接执行
```

---

**参考资料**：
- React源码：`packages/react-reconciler/src/ReactEventPriorities.js`
- React源码：`packages/react-reconciler/src/ReactFiberLane.js`
- [Lane Model RFC](https://github.com/facebook/react/pull/18796)

**最后更新**: 2025-11-05

