# 18 - 并发渲染（Concurrent Rendering）详解

> **问题**: React 18的并发渲染（Concurrent Rendering）是如何实现的？startTransition的底层原理是什么？

---

## 一、并发渲染是什么？

**并发渲染（Concurrent Rendering）是React 18的核心特性**，它允许React中断正在进行的渲染，去处理更高优先级的更新，然后再恢复之前的渲染。

### 传统渲染 vs 并发渲染

```
传统渲染（同步，React 17及之前）：
用户触发更新
     ↓
┌────────────────────────────────────┐
│ render阶段（不可中断）              │
│ [====================]             │
│ 阻塞主线程，无法响应用户操作        │
└──────────────┬─────────────────────┘
               ↓
          commit阶段
               ↓
          用户看到更新

问题：
- 长时间render阻塞主线程
- 用户点击、输入无响应
- 页面卡顿

并发渲染（可中断，React 18）：
用户触发低优先级更新
     ↓
┌────────────────────────────────────┐
│ render阶段（可中断）                │
│ [====] 让出 [====] 让出 [====]     │
│   5ms   ↓     5ms   ↓     5ms      │
│      浏览器    高优先  浏览器        │
│      渲染      级更新   渲染         │
└──────────────┬─────────────────────┘
               ↓
          commit阶段
               ↓
          用户看到更新

优势：
- 定期让出主线程（时间切片）
- 高优先级可以打断低优先级
- 保持应用响应
```

---

## 二、并发渲染的三大核心机制

### 1. 时间切片（Time Slicing）

源码：`packages/react-reconciler/src/ReactFiberWorkLoop.js`

```javascript
// 并发工作循环
function workLoopConcurrent(nonIdle: boolean) {
  // Transition/Retry：25ms一次yield（30fps）
  // Idle：5ms一次yield（60fps）
  if (workInProgress !== null) {
    const yieldAfter = now() + (nonIdle ? 25 : 5);
    do {
      performUnitOfWork(workInProgress);
    } while (workInProgress !== null && now() < yieldAfter);
  }
}

// 或使用Scheduler的shouldYield
function workLoopConcurrentByScheduler() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

**为什么Transition是25ms？**

```
帧率控制：
- 60fps = 16.6ms/帧
- 30fps = 33.3ms/帧

React的策略：
- Idle work：5ms yield → 保持60fps流畅
- Transition work：25ms yield → 降低到30fps
  
为什么Transition要降低帧率？
- Transition通常是大量UI更新（如搜索结果）
- 故意降低帧率，避免动画等高频任务被饿死
- 平衡：既不阻塞，也不过于激进
```

### 2. 优先级调度

```javascript
// 判断是否使用时间切片
const shouldTimeSlice =
  (!forceSync &&
    !includesBlockingLane(lanes) &&
    !includesExpiredLane(root, lanes)) ||
  checkIfRootIsPrerendering(root, lanes);

let exitStatus: RootExitStatus = shouldTimeSlice
  ? renderRootConcurrent(root, lanes)  // 并发渲染，可中断
  : renderRootSync(root, lanes, true);  // 同步渲染，不可中断
```

**优先级打断机制**：

```javascript
// 在performWorkOnRoot中
if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
  // 不同的root或lanes，需要重新开始
  // 这包括高优先级打断低优先级的情况
  prepareFreshStack(root, lanes);
}

// 示例
t=0: TransitionLane render开始
  → workInProgressRoot = root
  → workInProgressRootRenderLanes = TransitionLane
  → renderRootConcurrent()

t=10: SyncLane更新进来
  → getNextLanes(root, TransitionLane) → SyncLane（更高优先级）
  → performWorkOnRoot(root, SyncLane, forceSync)
  → workInProgressRoot !== root? 否
  → workInProgressRootRenderLanes !== SyncLane? 是
  → prepareFreshStack(root, SyncLane)  // 中断，重新开始
    → resetWorkInProgressStack()  // 清理旧的workInProgress
    → 创建新的workInProgress树
```

### 3. 可恢复渲染

```javascript
// workInProgress保存渲染进度
let workInProgress: Fiber | null = null;
let workInProgressRoot: FiberRoot | null = null;
let workInProgressRootRenderLanes: Lanes = NoLanes;

// 中断时
if (shouldYield()) {
  // 保存当前状态
  // workInProgress不清空
  // 下次render时检查是否可以继续
  return RootInProgress;
}

// 恢复时
function renderRootConcurrent(root, lanes) {
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    // 不同的工作，重新开始
    prepareFreshStack(root, lanes);
  } else {
    // 相同的工作，继续之前的进度
  }
  
  workLoopConcurrent();
}
```

---

## 三、startTransition的完整实现

### 用户API

源码：`packages/react/src/ReactStartTransition.js`

```javascript
export function startTransition(
  scope: () => void,
  options?: StartTransitionOptions,
): void {
  // ========== 1. 保存之前的Transition上下文 ==========
  const prevTransition = ReactSharedInternals.T;
  
  // ========== 2. 创建新的Transition对象 ==========
  const currentTransition: Transition = {};
  
  if (enableViewTransition) {
    // View Transition相关
    currentTransition.types = prevTransition !== null
      ? prevTransition.types
      : null;
  }
  
  if (enableTransitionTracing) {
    currentTransition.name =
      options !== undefined && options.name !== undefined ? options.name : null;
    currentTransition.startTime = -1;
  }
  
  if (__DEV__) {
    currentTransition._updatedFibers = new Set();
  }
  
  // ========== 3. 设置Transition上下文 ==========
  ReactSharedInternals.T = currentTransition;

  try {
    // ========== 4. 执行scope函数 ==========
    const returnValue = scope();
    
    // ========== 5. 处理回调 ==========
    const onStartTransitionFinish = ReactSharedInternals.S;
    if (onStartTransitionFinish !== null) {
      onStartTransitionFinish(currentTransition, returnValue);
    }
    
    // ========== 6. 处理async transition ==========
    if (
      typeof returnValue === 'object' &&
      returnValue !== null &&
      typeof returnValue.then === 'function'
    ) {
      // scope返回了Promise
      if (__DEV__) {
        ReactSharedInternals.asyncTransitions++;
        returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
      }
      returnValue.then(noop, reportGlobalError);
    }
  } catch (error) {
    reportGlobalError(error);
  } finally {
    // ========== 7. 恢复之前的Transition上下文 ==========
    ReactSharedInternals.T = prevTransition;
  }
}
```

**关键点**：

```
startTransition的作用：
1. 设置ReactSharedInternals.T = currentTransition
2. 执行scope()
3. scope中的setState会检查ReactSharedInternals.T
4. 如果T不为null，分配TransitionLane
5. 恢复之前的Transition上下文

示例：
startTransition(() => {
  setState(newValue);  // 这个setState会分配TransitionLane
});

// setState内部
function dispatchSetState(...) {
  const lane = requestUpdateLane(fiber);
  // requestUpdateLane会检查ReactSharedInternals.T
  // 如果T不为null，返回TransitionLane
}
```

---

## 四、useTransition的实现

### mountTransition

源码：`packages/react-reconciler/src/ReactFiberHooks.js`

```javascript
function mountTransition(): [
  boolean,
  (callback: () => void, options?: StartTransitionOptions) => void,
] {
  // ========== 1. 创建isPending state ==========
  const stateHook = mountStateImpl(false);
  
  // ========== 2. 创建start函数（稳定引用）==========
  const start = startTransition.bind(
    null,
    currentlyRenderingFiber,  // 闭包捕获fiber
    stateHook.queue,          // isPending的queue
    true,                     // 需要更新isPending
    false,                    // 不是revert
  );
  
  // ========== 3. 保存start到Hook ==========
  const hook = mountWorkInProgressHook();
  hook.memoizedState = start;
  
  return [false, start];  // [isPending, startTransition]
}

function updateTransition(): [
  boolean,
  (callback: () => void, options?: StartTransitionOptions) => void,
] {
  // ========== 1. 更新isPending state ==========
  const [booleanOrThenable] = updateState(false);
  
  // ========== 2. 获取稳定的start函数 ==========
  const hook = updateWorkInProgressHook();
  const start = hook.memoizedState;
  
  // ========== 3. 处理isPending值 ==========
  const isPending =
    typeof booleanOrThenable === 'boolean'
      ? booleanOrThenable
      : useThenable(booleanOrThenable);  // 可能是async action
  
  return [isPending, start];
}
```

**useTransition的使用**：

```javascript
function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleChange = (e) => {
    const value = e.target.value;
    
    // 高优先级：立即更新输入框
    setQuery(value);
    
    // 低优先级：在transition中更新结果
    startTransition(() => {
      setResults(search(value));
    });
  };

  return (
    <>
      <input value={query} onChange={handleChange} />
      {isPending && <Spinner />}  {/* 显示loading状态 */}
      <ResultsList results={results} />
    </>
  );
}

// 执行流程
t=0: 用户输入"R"
  → setQuery("R")
    lane = SyncLane
  → startTransition(() => setResults(...))
    ReactSharedInternals.T = currentTransition
    setResults(...)
      lane = TransitionLane（因为T不为null）
    ReactSharedInternals.T = null

t=1: 微任务执行
  → getNextLanes() → SyncLane（最高优先级）
  → renderRootSync()
    query变成"R"，isPending变成false
  → commit，用户看到输入框更新

t=10: TransitionLane render开始
  → renderRootConcurrent()
  → workLoopConcurrent()
  → 计算search结果...

t=15: 用户继续输入"e"
  → SyncLane更新
  → 中断TransitionLane render
  → 处理SyncLane，query变成"Re"

t=20: 恢复TransitionLane
  → 基于新的query "Re"重新计算
  → results更新
```

---

## 五、useDeferredValue的实现

### mountDeferredValue

```javascript
function mountDeferredValue<T>(value: T, initialValue?: T): T {
  const hook = mountWorkInProgressHook();
  return mountDeferredValueImpl(hook, value, initialValue);
}

function mountDeferredValueImpl<T>(
  hook: Hook,
  value: T,
  initialValue?: T,
): T {
  if (
    initialValue !== undefined &&
    !isRenderingDeferredWork()
  ) {
    // ========== 有initialValue，先渲染初始值 ==========
    hook.memoizedState = initialValue;

    // ========== 调度deferred render ==========
    const deferredLane = requestDeferredLane();
    currentlyRenderingFiber.lanes = mergeLanes(
      currentlyRenderingFiber.lanes,
      deferredLane,
    );
    markSkippedUpdateLanes(deferredLane);

    return initialValue;
  } else {
    // ========== 没有initialValue，直接使用value ==========
    hook.memoizedState = value;
    return value;
  }
}

function updateDeferredValue<T>(value: T, initialValue?: T): T {
  const hook = updateWorkInProgressHook();
  const resolvedCurrentHook: Hook = currentHook;
  const prevValue: T = resolvedCurrentHook.memoizedState;
  return updateDeferredValueImpl(hook, prevValue, value, initialValue);
}

function updateDeferredValueImpl<T>(
  hook: Hook,
  prevValue: T,
  value: T,
  initialValue?: T,
): T {
  if (is(value, prevValue)) {
    // ========== value没变，返回缓存值 ==========
    return value;
  } else {
    // ========== value变了 ==========
    
    if (isRenderingDeferredWork()) {
      // 当前正在render deferred work
      // 使用新值
      hook.memoizedState = value;
      return value;
    } else {
      // ========== 当前不是deferred render ==========
      
      // 调度deferred render
      const deferredLane = requestDeferredLane();
      currentlyRenderingFiber.lanes = mergeLanes(
        currentlyRenderingFiber.lanes,
        deferredLane,
      );
      markSkippedUpdateLanes(deferredLane);

      // 本次render仍然使用旧值
      hook.memoizedState = prevValue;
      return prevValue;
    }
  }
}
```

**useDeferredValue的使用**：

```javascript
function SearchResults({ query }) {
  // query变化时，deferredQuery延迟更新
  const deferredQuery = useDeferredValue(query);

  // 基于deferredQuery渲染（低优先级）
  const results = useMemo(
    () => search(deferredQuery),
    [deferredQuery]
  );

  return (
    <>
      {/* 高优先级render */}
      {query !== deferredQuery && <Spinner />}
      
      {/* 低优先级render */}
      <ResultsList results={results} />
    </>
  );
}

// 执行流程
t=0: query从"a"变成"ab"
  → 第1次render（高优先级）
    deferredQuery = "a"（返回旧值）
    query !== deferredQuery → 显示Spinner
    results基于"a"（不变）
  → commit

t=1: 用户立即看到Spinner

t=10: 第2次render（低优先级，deferred lane）
  → deferredQuery = "ab"（返回新值）
  → query === deferredQuery → 隐藏Spinner
  → results = search("ab")（计算新结果）
  → commit

t=15: 用户看到新结果
```

---

## 六、requestDeferredLane：分配deferred lane

```javascript
export function requestDeferredLane(): Lane {
  if (workInProgressDeferredLane === NoLane) {
    // ========== 决定deferred的优先级 ==========
    
    const isPrerendering =
      includesSomeLane(workInProgressRootRenderLanes, OffscreenLane) &&
      !getIsHydrating();
      
    if (isPrerendering) {
      // 预渲染中：使用OffscreenLane
      workInProgressDeferredLane = OffscreenLane;
    } else {
      // 其他情况：使用TransitionDeferredLane
      workInProgressDeferredLane = claimNextTransitionDeferredLane();
    }
  }

  // ========== 标记父Suspense边界 ==========
  const suspenseHandler = getSuspenseHandler();
  if (suspenseHandler !== null) {
    suspenseHandler.flags |= DidDefer;
  }

  return workInProgressDeferredLane;
}
```

---

## 七、实际应用场景

### 场景1：大型列表搜索

```javascript
function ProductSearch() {
  const [query, setQuery] = useState('');
  const [isPending, startTransition] = useTransition();
  const [products, setProducts] = useState([]);

  const handleSearch = (e) => {
    const value = e.target.value;
    
    // 高优先级：立即更新输入框
    setQuery(value);
    
    // 低优先级：搜索和过滤（耗时操作）
    startTransition(() => {
      const filtered = allProducts
        .filter(p => p.name.toLowerCase().includes(value.toLowerCase()))
        .sort((a, b) => b.score - a.score)
        .slice(0, 100);
      setProducts(filtered);
    });
  };

  return (
    <>
      <input
        value={query}
        onChange={handleSearch}
        placeholder="Search products..."
      />
      {isPending && <LoadingSpinner />}
      
      <ProductList products={products} />
    </>
  );
}

// 用户体验：
// 1. 输入流畅，不卡顿
// 2. 看到loading状态
// 3. 可以继续输入（新输入会中断旧的搜索）
```

### 场景2：Tab切换

```javascript
function TabContainer() {
  const [tab, setTab] = useState('home');
  const [isPending, startTransition] = useTransition();

  const switchTab = (newTab) => {
    startTransition(() => {
      setTab(newTab);
    });
  };

  return (
    <>
      <TabBar activeTab={tab} onSwitch={switchTab} />
      {isPending && <ProgressBar />}
      
      {tab === 'home' && <HomePage />}      {/* 1000个组件 */}
      {tab === 'profile' && <ProfilePage />}  {/* 2000个组件 */}
      {tab === 'settings' && <SettingsPage />}
    </>
  );
}

// 并发渲染的好处：
// 1. 点击tab立即响应（显示ProgressBar）
// 2. 渲染新页面时可以继续交互
// 3. 如果用户点击其他tab，中断当前渲染
```

### 场景3：useDeferredValue优化

```javascript
function AutoComplete({ searchText }) {
  // searchText变化时，deferredText延迟更新
  const deferredText = useDeferredValue(searchText);
  
  // 基于deferredText的昂贵计算
  const suggestions = useMemo(() => {
    // 昂贵的搜索和排序
    return expensiveSearch(deferredText);
  }, [deferredText]);

  return (
    <>
      <input value={searchText} />
      
      {/* 显示是否在加载 */}
      {searchText !== deferredText && <Spinner />}
      
      <SuggestionList suggestions={suggestions} />
    </>
  );
}

// 执行过程：
// 用户快速输入"react"（5个字符）：
t=0: "r"
  → 高优先级render：input显示"r"，deferredText=""，显示Spinner
  → 调度低优先级render

t=20: "e"（用户继续输入，低优先级还没开始）
  → 高优先级render：input显示"re"，deferredText=""
  → 取消之前的低优先级
  → 调度新的低优先级

t=40: "a"
t=60: "c"
t=80: "t"
  → 每次都是：高优先级更新input，取消旧的低优先级

t=100: 用户停止输入
  → 低优先级render开始
  → deferredText变成"react"
  → suggestions = expensiveSearch("react")
  → commit

结果：
- expensiveSearch只执行1次（不是5次）
- input响应流畅
- 自动debounce效果
```

---

## 八、并发特性对比

### startTransition vs useDeferredValue vs useTransition

| 特性 | startTransition | useTransition | useDeferredValue |
|------|----------------|---------------|------------------|
| **类型** | 函数API | Hook | Hook |
| **返回值** | void | [isPending, start] | deferredValue |
| **isPending** | 无 | 有 | 需自己比较 |
| **使用场景** | 手动控制transition | 需要loading状态 | 值的延迟更新 |
| **适用对象** | setState | 任何更新 | props/state值 |

**关系**：

```javascript
// startTransition
import { startTransition } from 'react';
startTransition(() => {
  setState(newValue);
});

// useTransition = startTransition + isPending
const [isPending, start] = useTransition();
start(() => {
  setState(newValue);
});
// isPending自动管理

// useDeferredValue = useTransition的值版本
const deferredValue = useDeferredValue(value);
// 等价于
const [isPending, startTransition] = useTransition();
const [deferredValue, setDeferredValue] = useState(value);
useEffect(() => {
  startTransition(() => {
    setDeferredValue(value);
  });
}, [value]);
```

---

## 九、源码关键路径

```
并发渲染核心文件：

packages/react/src/
└── ReactStartTransition.js             # startTransition API
    └── startTransition()               # 设置Transition上下文

packages/react-reconciler/src/
├── ReactFiberWorkLoop.js               # 并发工作循环
│   ├── renderRootConcurrent()          # 并发render入口
│   ├── workLoopConcurrent()            # 可中断工作循环
│   ├── workLoopConcurrentByScheduler() # 使用Scheduler的版本
│   ├── shouldTimeSlice判断             # 是否使用时间切片
│   └── performWorkOnRoot()             # 处理优先级打断
│
├── ReactFiberHooks.js                  # Transition Hooks
│   ├── mountTransition()               # useTransition mount
│   ├── updateTransition()              # useTransition update
│   ├── mountDeferredValue()            # useDeferredValue mount
│   ├── updateDeferredValue()           # useDeferredValue update
│   └── requestDeferredLane()           # 分配deferred lane
│
└── ReactFiberLane.js                   # Lane管理
    ├── TransitionLane1-14              # 14个Transition lanes
    ├── claimNextTransitionUpdateLane() # 分配Transition lane
    └── claimNextTransitionDeferredLane()  # 分配deferred lane
```

---

## 十、面试要点速记

### 快速回答框架

**并发渲染的核心机制？**
1. **时间切片**：每5-25ms让出主线程
2. **优先级调度**：高优先级可以打断低优先级
3. **可恢复渲染**：workInProgress保存进度

**startTransition的原理？**
1. 设置ReactSharedInternals.T = currentTransition
2. 执行scope函数
3. scope中的setState分配TransitionLane
4. 恢复之前的Transition上下文

**useTransition vs useDeferredValue？**
- **useTransition**：手动包装更新，返回isPending
- **useDeferredValue**：自动延迟值的更新，需自己比较判断loading

**并发渲染的好处？**
1. 保持应用响应
2. 避免长时间阻塞
3. 更好的用户体验
4. 自动优先级管理

### 加分项

1. **能说明时间切片的具体实现**：
   - workLoopConcurrent
   - 5ms vs 25ms的区别

2. **能解释优先级打断**：
   - prepareFreshStack重新开始
   - workInProgress的保存和清理

3. **能对比三个API**：
   - startTransition、useTransition、useDeferredValue
   - 使用场景的差异

4. **能举实际案例**：
   - 搜索框优化
   - Tab切换
   - 自动debounce

### 常见追问

**Q: 并发渲染和时间切片的关系？**
A:
- 时间切片是并发渲染的基础
- 通过时间切片实现可中断
- 可中断才能实现优先级调度
- 三者配合实现并发渲染

**Q: startTransition中的更新一定是低优先级吗？**
A:
- 是的，分配TransitionLane
- TransitionLane是低优先级
- 可被SyncLane、DefaultLane打断
- 但比IdleLane优先级高

**Q: 并发渲染会影响性能吗？**
A:
- 有轻微开销（时间切片、保存/恢复状态）
- 但收益远大于开销
- 提升用户体验
- 避免长时间阻塞

**Q: 所有组件都能用并发渲染吗？**
A:
- 需要使用createRoot（ConcurrentRoot）
- Legacy模式（ReactDOM.render）不支持
- 组件需要遵循纯函数规则
- 不能依赖render的执行次数

---

**参考资料**：
- React源码：`packages/react/src/ReactStartTransition.js`
- React源码：`packages/react-reconciler/src/ReactFiberHooks.js`
- [React 18 并发特性](https://react.dev/blog/2022/03/29/react-v18)
- [startTransition RFC](https://github.com/reactwg/react-18/discussions/41)

**最后更新**: 2025-11-05
