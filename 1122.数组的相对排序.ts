/*
 * @lc app=leetcode.cn id=1122 lang=typescript
 *
 * [1122] 数组的相对排序
 *
 * 题目要求：
 * 给你两个数组，arr1 和 arr2，arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中。
 * 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。
 * 未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。
 */

// @lc code=start
/**
 * 对数组arr1进行相对排序，使其元素顺序按照arr2中元素的顺序排列，
 * 不在arr2中的元素按升序排列在最后
 *
 * 算法思路：使用计数排序的变种
 * 1. 统计arr1中每个元素出现的次数
 * 2. 按照arr2的顺序输出对应元素
 * 3. 按升序输出剩余元素
 *
 * 时间复杂度：O(n + m + 1001)，其中n是arr1的长度，m是arr2的长度
 * 空间复杂度：O(1001)，计数数组的空间
 *
 * @param arr1 待排序的数组
 * @param arr2 决定相对顺序的数组
 * @returns 排序后的数组
 */
function relativeSortArray(arr1: number[], arr2: number[]): number[] {
  // 根据题目提示，元素的最大值为1000，所以用长度1001的数组
  // 索引表示元素值，存储的值表示该元素在arr1中出现的次数
  const counts: number[] = new Array(1001).fill(0);

  // 第一步：统计arr1中每个数字出现的次数
  for (const num of arr1) {
    counts[num]++; // 将对应元素的计数加1
  }

  // 用于存储最终排序结果的数组
  const res: number[] = [];

  // 第二步：按照arr2的顺序处理arr1中的元素
  for (const num of arr2) {
    // 当arr1中存在该元素时
    while (counts[num] > 0) {
      res.push(num); // 将该元素添加到结果数组
      counts[num]--; // 减少该元素的计数，表示处理了一个
    }
    // 循环结束后，arr1中所有等于arr2[i]的元素都已经被加入结果数组
  }

  // 第三步：处理arr1中剩余的元素（即不在arr2中的元素）
  // 从小到大遍历counts数组，确保剩余元素按升序添加
  for (let i = 0; i < counts.length; i++) {
    // 如果当前元素在arr1中出现过且尚未被处理（计数大于0）
    while (counts[i] > 0) {
      res.push(i); // 将元素值i添加到结果数组
      counts[i]--; // 减少该元素的计数
    }
  }

  // 返回相对排序后的结果数组
  return res;
}

/**
 * 示例分析：
 *
 * 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
 *
 * 计数过程：
 * counts[1] = 1 (1出现1次)
 * counts[2] = 3 (2出现3次)
 * counts[3] = 2 (3出现2次)
 * counts[4] = 1 (4出现1次)
 * counts[6] = 1 (6出现1次)
 * counts[7] = 1 (7出现1次)
 * counts[9] = 1 (9出现1次)
 * counts[19] = 1 (19出现1次)
 *
 * 按arr2顺序处理：
 * 先处理所有的2: [2,2,2]
 * 再处理所有的1: [2,2,2,1]
 * 再处理所有的4: [2,2,2,1,4]
 * 再处理所有的3: [2,2,2,1,4,3,3]
 * 再处理所有的9: [2,2,2,1,4,3,3,9]
 * 再处理所有的6: [2,2,2,1,4,3,3,9,6]
 *
 * 最后按升序处理剩余元素:
 * 处理7: [2,2,2,1,4,3,3,9,6,7]
 * 处理19: [2,2,2,1,4,3,3,9,6,7,19]
 *
 * 输出：[2,2,2,1,4,3,3,9,6,7,19]
 */
// @lc code=end
