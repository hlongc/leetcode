/*
 * @lc app=leetcode.cn id=137 lang=typescript
 *
 * [137] 只出现一次的数字 II
 *
 * 给你一个整数数组 nums，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。
 * 请你找出并返回那个只出现了一次的元素。
 */

// @lc code=start
/**
 * 找出数组中只出现一次的数字（其他数字都出现三次）
 *
 * 思路：使用位运算
 * 1. 对于每个数字的每一位，统计所有数字在该位上1的个数
 * 2. 如果某位上1的个数不是3的倍数，说明只出现一次的数字在该位上是1
 * 3. 将所有这样的位组合起来，就是最终结果
 *
 * 举例说明：
 * 假设数组为 [2, 2, 3, 2, 3, 3, 5]
 * 数字的二进制表示：
 * 2: 0010
 * 2: 0010
 * 3: 0011
 * 2: 0010
 * 3: 0011
 * 3: 0011
 * 5: 0101
 *
 * 按位统计1的个数：
 * 第0位：1+1+1+1+1+1+1 = 7个1，7%3=1，说明只出现一次的数字在第0位是1
 * 第1位：0+0+1+0+1+1+0 = 3个1，3%3=0，说明只出现一次的数字在第1位是0
 * 第2位：1+1+0+1+0+0+1 = 4个1，4%3=1，说明只出现一次的数字在第2位是1
 * 第3位：0+0+0+0+0+0+0 = 0个1，0%3=0，说明只出现一次的数字在第3位是0
 *
 * 组合起来就是 0101(二进制) = 5(十进制)，即只出现一次的数字是5
 * 详细步骤示例：
 *
 * 以数组 [2, 2, 3, 2, 3, 3, 5] 为例：
 *
 * 第0位（最低位）：
 * 2 的二进制是 0010，第0位为 0
 * 3 的二进制是 0011，第0位为 1
 * 5 的二进制是 0101，第0位为 1
 * 所以第0位上有 0+0+1+0+1+1+1 = 4 个1
 * 4 % 3 = 1，说明单一元素在第0位上是1
 *
 * 第1位：
 * 2 的二进制是 0010，第1位为 1
 * 3 的二进制是 0011，第1位为 1
 * 5 的二进制是 0101，第1位为 0
 * 所以第1位上有 1+1+1+1+1+1+0 = 6 个1
 * 6 % 3 = 0，说明单一元素在第1位上是0
 *
 * 第2位：
 * 2 的二进制是 0010，第2位为 0
 * 3 的二进制是 0011，第2位为 0
 * 5 的二进制是 0101，第2位为 1
 * 所以第2位上有 0+0+0+0+0+0+1 = 1 个1
 * 1 % 3 = 1，说明单一元素在第2位上是1
 *
 * 第3位及更高位全为0
 *
 * 所以单一元素的二进制是 0101，即十进制的 5
 *
 * 为什么这种方法有效？
 * - 如果一个数字出现3次，那么它在每一位上的1也会出现3次
 * - 对于所有出现3次的数字，它们在每一位上的1的个数一定是3的倍数
 * - 因此，如果某一位上1的总数不是3的倍数，那么这个"多余"的1一定来自于只出现一次的那个数字
 *
 * 时间复杂度：O(n)，其中n是数组长度
 * 空间复杂度：O(1)，只使用了常数个变量
 *
 * @param nums 包含所有数字的数组，其中只有一个数字出现一次，其余都出现三次
 * @returns 只出现一次的数字
 */
function singleNumber(nums: number[]): number {
  let result = 0;

  // 遍历32位整数的每一位（JavaScript中的Number为64位浮点数，但整数部分实际上是32位）
  for (let i = 0; i < 32; i++) {
    let sum = 0;
    // 统计所有数字在第i位上的1的个数
    for (const num of nums) {
      // 右移i位后与1进行与运算，得到第i位的值（0或1）
      // (num >> i) 将num右移i位，使得第i位变成最低位
      // & 1 与1进行位与操作，提取最低位的值
      sum += (num >> i) & 1;
    }

    // 如果1的个数不是3的倍数，说明只出现一次的数字在该位上是1
    // 对于出现三次的数字，它们在每一位上的1的个数一定是3的倍数
    if (sum % 3 !== 0) {
      // 将结果在该位上设置为1
      // 1 << i 创建一个第i位为1的数
      // result |= ... 使用位或操作将结果的第i位设置为1
      result |= 1 << i;
    }
  }

  return result;
}
// @lc code=end
